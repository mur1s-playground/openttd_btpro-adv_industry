diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 631eaf6de..4a5193201 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -54,6 +54,8 @@ add_files(
     autoreplace_gui.h
     autoreplace_type.h
     autoslope.h
+    base64.cpp
+    base64.h
     base_consist.cpp
     base_consist.h
     base_media_base.h
@@ -68,6 +70,8 @@ add_files(
     bridge_map.cpp
     bridge_map.h
     build_vehicle_gui.cpp
+    cargo_table_gui.cpp
+    cargo_table_gui.h
     cargo_type.h
     cargoaction.cpp
     cargoaction.h
@@ -88,6 +92,8 @@ add_files(
     command.cpp
     command_func.h
     command_type.h
+    commands_token_gui.cpp
+    commands_token_gui.h
     company_base.h
     company_cmd.cpp
     company_func.h
@@ -446,6 +452,9 @@ add_files(
     tree_cmd.cpp
     tree_gui.cpp
     tree_map.h
+    triphistory.h
+    triphistory_cmd.cpp
+    triphistory_gui.cpp
     tunnel_map.cpp
     tunnel_map.h
     tunnelbridge.h
@@ -470,6 +479,8 @@ add_files(
     void_cmd.cpp
     void_map.h
     walltime_func.h
+    watch_gui_1.cpp
+    watch_gui_1.h
     water.h
     water_cmd.cpp
     water_map.h
@@ -486,4 +497,7 @@ add_files(
     window_type.h
     zoom_func.h
     zoom_type.h
+    zoning.h
+    zoning_cmd.cpp
+    zoning_gui.cpp
 )
diff --git a/src/base64.cpp b/src/base64.cpp
new file mode 100644
index 000000000..a9eee8ce2
--- /dev/null
+++ b/src/base64.cpp
@@ -0,0 +1,122 @@
+/*
+   base64.cpp and base64.h
+
+   base64 encoding and decoding with C++.
+
+   Version: 1.01.00
+
+   Copyright (C) 2004-2017 René Nyffenegger
+
+   This source code is provided 'as-is', without any express or implied
+   warranty. In no event will the author be held liable for any damages
+   arising from the use of this software.
+
+   Permission is granted to anyone to use this software for any purpose,
+   including commercial applications, and to alter it and redistribute it
+   freely, subject to the following restrictions:
+
+   1. The origin of this source code must not be misrepresented; you must not
+      claim that you wrote the original source code. If you use this source code
+      in a product, an acknowledgment in the product documentation would be
+      appreciated but is not required.
+
+   2. Altered source versions must be plainly marked as such, and must not be
+      misrepresented as being the original source code.
+
+   3. This notice may not be removed or altered from any source distribution.
+
+   René Nyffenegger rene.nyffenegger@adp-gmbh.ch
+
+*/
+
+#include "base64.h"
+#include <iostream>
+
+static const std::string base64_chars =
+             "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+             "abcdefghijklmnopqrstuvwxyz"
+             "0123456789+/";
+
+
+static inline bool is_base64(unsigned char c) {
+  return (isalnum(c) || (c == '+') || (c == '/'));
+}
+
+std::string base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len) {
+  std::string ret;
+  int i = 0;
+  int j = 0;
+  unsigned char char_array_3[3];
+  unsigned char char_array_4[4];
+
+  while (in_len--) {
+    char_array_3[i++] = *(bytes_to_encode++);
+    if (i == 3) {
+      char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+      char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
+      char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
+      char_array_4[3] = char_array_3[2] & 0x3f;
+
+      for(i = 0; (i <4) ; i++)
+        ret += base64_chars[char_array_4[i]];
+      i = 0;
+    }
+  }
+
+  if (i)
+  {
+    for(j = i; j < 3; j++)
+      char_array_3[j] = '\0';
+
+    char_array_4[0] = ( char_array_3[0] & 0xfc) >> 2;
+    char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
+    char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
+
+    for (j = 0; (j < i + 1); j++)
+      ret += base64_chars[char_array_4[j]];
+
+    while((i++ < 3))
+      ret += '=';
+
+  }
+
+  return ret;
+
+}
+
+std::string base64_decode(std::string const& encoded_string) {
+  size_t in_len = encoded_string.size();
+  int i = 0;
+  int j = 0;
+  int in_ = 0;
+  unsigned char char_array_4[4], char_array_3[3];
+  std::string ret;
+
+  while (in_len-- && ( encoded_string[in_] != '=') && is_base64(encoded_string[in_])) {
+    char_array_4[i++] = encoded_string[in_]; in_++;
+    if (i ==4) {
+      for (i = 0; i <4; i++)
+        char_array_4[i] = base64_chars.find(char_array_4[i]) & 0xff;
+
+      char_array_3[0] = ( char_array_4[0] << 2       ) + ((char_array_4[1] & 0x30) >> 4);
+      char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+      char_array_3[2] = ((char_array_4[2] & 0x3) << 6) +   char_array_4[3];
+
+      for (i = 0; (i < 3); i++)
+        ret += char_array_3[i];
+      i = 0;
+    }
+  }
+
+  if (i) {
+    for (j = 0; j < i; j++)
+      char_array_4[j] = base64_chars.find(char_array_4[j]) & 0xff;
+
+    char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+    char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+
+    for (j = 0; (j < i - 1); j++) ret += char_array_3[j];
+  }
+
+  return ret;
+}
diff --git a/src/base64.h b/src/base64.h
new file mode 100644
index 000000000..dd1134c30
--- /dev/null
+++ b/src/base64.h
@@ -0,0 +1,14 @@
+//
+//  base64 encoding and decoding with C++.
+//  Version: 1.01.00
+//
+
+#ifndef BASE64_H_C0CE2A47_D10E_42C9_A27C_C883944E704A
+#define BASE64_H_C0CE2A47_D10E_42C9_A27C_C883944E704A
+
+#include <string>
+
+std::string base64_encode(unsigned char const* , unsigned int len);
+std::string base64_decode(std::string const& s);
+
+#endif /* BASE64_H_C0CE2A47_D10E_42C9_A27C_C883944E704A */
diff --git a/src/bridge_gui.cpp b/src/bridge_gui.cpp
index 74c7234d5..dce6b0015 100644
--- a/src/bridge_gui.cpp
+++ b/src/bridge_gui.cpp
@@ -23,6 +23,7 @@
 #include "cmd_helper.h"
 #include "tunnelbridge_map.h"
 #include "road_gui.h"
+#include "tilehighlight_func.h"
 
 #include "widgets/bridge_widget.h"
 
@@ -72,6 +73,7 @@ void CcBuildBridge(const CommandCost &result, TileIndex end_tile, uint32 p1, uin
 		DiagDirection start_direction = ReverseDiagDir(GetTunnelBridgeDirection(p1));
 		ConnectRoadToStructure(p1, start_direction);
 	}
+	StoreRailPlacementEndpoints(p1, end_tile, (TileX(p1) == TileX(end_tile)) ? TRACK_Y : TRACK_X, false);
 }
 
 /** Window class for handling the bridge-build GUI. */
diff --git a/src/build_vehicle_gui.cpp b/src/build_vehicle_gui.cpp
index 547ac3e00..27a8bb979 100644
--- a/src/build_vehicle_gui.cpp
+++ b/src/build_vehicle_gui.cpp
@@ -32,7 +32,7 @@
 #include "autoreplace_func.h"
 
 #include "widgets/build_vehicle_widget.h"
-
+#include "hotkeys.h"
 #include "table/strings.h"
 
 #include "safeguards.h"
@@ -1666,13 +1666,28 @@ struct BuildVehicleWindow : Window {
 	{
 		this->vscroll->SetCapacityFromWidget(this, WID_BV_LIST);
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		if (this->owner != _local_company) return ES_NOT_HANDLED;
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
+};
+
+static Hotkey build_vehicle_hotkeys[] = {
+	Hotkey('R', "build_vehicle", WID_BV_BUILD),
+	HOTKEY_LIST_END
 };
+HotkeyList BuildVehicleWindow::hotkeys("build_vehicle", build_vehicle_hotkeys);
 
 static WindowDesc _build_vehicle_desc(
 	WDP_AUTO, "build_vehicle", 240, 268,
 	WC_BUILD_VEHICLE, WC_NONE,
 	WDF_CONSTRUCTION,
-	_nested_build_vehicle_widgets, lengthof(_nested_build_vehicle_widgets)
+	_nested_build_vehicle_widgets, lengthof(_nested_build_vehicle_widgets),
+	&BuildVehicleWindow::hotkeys
 );
 
 void ShowBuildVehicleWindow(TileIndex tile, VehicleType type)
diff --git a/src/cargo_table_gui.cpp b/src/cargo_table_gui.cpp
new file mode 100644
index 000000000..b3ee843fd
--- /dev/null
+++ b/src/cargo_table_gui.cpp
@@ -0,0 +1,231 @@
+/* $Id: cargo_table_gui.cpp 21909 2011-01-26 08:14:36Z TheDude $ */
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "window_func.h"
+#include "strings_func.h"
+#include "company_func.h"
+#include "company_base.h"
+#include "table/strings.h"
+#include "textbuf_gui.h"
+#include "cargotype.h"
+#include "zoom_func.h"
+#include "table/sprites.h"
+#include "widgets/dropdown_type.h"
+
+#include "widgets/cargo_table_widget.h"
+
+static const uint CT_LINESPACE  = 3;      ///< Amount of vertical space for a horizontal (sub-)total line.
+static const uint CT_ICON_MARGIN = 2;     ///< Amount of space between cargo icon and text
+
+enum CargoOption {
+	WID_CT_OPTION_CARGO_TOTAL = 0,
+	WID_CT_OPTION_CARGO_MONTH,
+};
+
+static void DrawPrice(Money amount, int left, int right, int top)
+{
+	SetDParam(0, amount);
+	DrawString(left, right, top, STR_FINANCES_POSITIVE_INCOME, TC_FROMSTRING, SA_RIGHT);
+}
+
+void InvalidateCargosWindows(CompanyID cid)
+{
+	if (cid == _local_company) SetWindowDirty(WC_STATUS_BAR, 0);
+	SetWindowDirty(WC_CARGOS, cid);
+}
+
+/** Cargos window handler. */
+struct CargosWindow : Window {
+
+	CargoOption cargoPeriod;
+	CargosWindow(WindowDesc *desc, WindowNumber window_number) : Window(desc)
+	{
+		this->InitNested(window_number);
+		this->owner = (Owner)this->window_number;
+		this->cargoPeriod = WID_CT_OPTION_CARGO_TOTAL;
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if(widget != WID_CT_CAPTION) return;
+		SetDParam(0, (CompanyID)this->window_number);
+		SetDParam(1, (CompanyID)this->window_number);
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		if(widget != WID_CT_HEADER_CARGO) return;
+		this->cargoPeriod = (this->cargoPeriod == WID_CT_OPTION_CARGO_TOTAL) ? WID_CT_OPTION_CARGO_MONTH : WID_CT_OPTION_CARGO_TOTAL;
+		this->SetDirty();
+	}
+
+	void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		Dimension icon_size = this->GetMaxIconSize();
+		int line_height = std::max(FONT_HEIGHT_NORMAL, (int)icon_size.height);
+		int icon_space = icon_size.width + ScaleGUITrad(CT_ICON_MARGIN);
+		switch(widget) {
+			case WID_CT_HEADER_AMOUNT:
+			case WID_CT_HEADER_INCOME:
+			case WID_CT_AMOUNT:
+			case WID_CT_INCOME: {
+				break;
+			}
+			case WID_CT_HEADER_CARGO:
+			case WID_CT_LIST: {
+
+				for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+					size->width = std::max(GetStringBoundingBox(cs->name).width + icon_space, size->width);
+				}
+				size->width = std::max(GetStringBoundingBox(STR_TOOLBAR_CARGOS_HEADER_TOTAL_MONTH).width, size->width);
+				break;
+			}
+		}
+		switch(widget) {
+			case WID_CT_HEADER_AMOUNT:
+			case WID_CT_HEADER_INCOME:
+				size->height = FONT_HEIGHT_NORMAL;
+				break;
+			case WID_CT_HEADER_CARGO:
+				break;
+			case WID_CT_AMOUNT:
+			case WID_CT_INCOME:
+			case WID_CT_LIST: {
+				size->height = _sorted_standard_cargo_specs.size() * line_height + CT_LINESPACE + FONT_HEIGHT_NORMAL;
+				break;
+			}
+		}
+	}
+
+	Dimension GetMaxIconSize() const {
+		Dimension size = {0, 0};
+		for (const CargoSpec *cs : CargoSpec::Iterate()) {
+			Dimension icon_size = GetSpriteSize(cs->GetCargoIcon());
+			size.width = std::max(size.width, icon_size.width);
+			size.height = std::max(size.height, icon_size.height);
+		}
+		return size;
+	}
+
+	void DrawWidget(const Rect &r, int widget) const
+	{
+		const Company *c = Company::Get((CompanyID)this->window_number);
+		uint32 sum_cargo_amount = 0;
+		Money sum_cargo_income = 0;
+		int y = r.top;
+		Dimension max_icon_size = this->GetMaxIconSize();
+		int line_height = std::max(FONT_HEIGHT_NORMAL, (int)(max_icon_size.height));
+		int icon_space = max_icon_size.width + ScaleGUITrad(CT_ICON_MARGIN);
+		int text_y_ofs = (line_height - FONT_HEIGHT_NORMAL);
+
+		switch(widget){
+			case WID_CT_HEADER_CARGO:
+				break;
+			case WID_CT_HEADER_AMOUNT:
+				DrawString(r.left, r.right, y, STR_TOOLBAR_CARGOS_HEADER_AMOUNT, TC_FROMSTRING, SA_RIGHT);
+				break;
+			case WID_CT_HEADER_INCOME:
+				DrawString(r.left, r.right, y, STR_TOOLBAR_CARGOS_HEADER_INCOME, TC_FROMSTRING, SA_RIGHT);
+				break;
+
+			case WID_CT_LIST: {
+				int rect_x = r.left + WD_FRAMERECT_LEFT;
+				for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+					Dimension icon_size = GetSpriteSize(cs->GetCargoIcon());
+					DrawSprite(cs->GetCargoIcon(), PAL_NONE,
+					           r.left + max_icon_size.width - icon_size.width,
+					           y + (line_height - (int)icon_size.height) / 2);
+
+					SetDParam(0, cs->name);
+					DrawString(r.left + icon_space, r.right, y + text_y_ofs, STR_TOOLBAR_CARGOS_NAME);
+
+					y += line_height;
+				}
+
+				GfxFillRect(r.left, y + 1, r.right, y + 1, PC_BLACK);
+				y += CT_LINESPACE;
+
+				StringID string_to_draw = STR_TOOLBAR_CARGOS_HEADER_TOTAL;
+				if (this->cargoPeriod != WID_CT_OPTION_CARGO_TOTAL) string_to_draw++;
+				DrawString(r.left, r.right, y, string_to_draw);
+				break;
+			}
+			case WID_CT_AMOUNT:
+				for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+
+					if (this->cargoPeriod == WID_CT_OPTION_CARGO_MONTH) {
+						sum_cargo_amount += c->cargo_units_period[0][cs->Index()];
+						SetDParam(0,  c->cargo_units_period[0][cs->Index()]);
+					} else {
+						sum_cargo_amount += c->cargo_units[cs->Index()];
+						SetDParam(0,  c->cargo_units[cs->Index()]);
+					}
+
+					DrawString(r.left, r.right, y + text_y_ofs, STR_TOOLBAR_CARGOS_UNITS, TC_FROMSTRING, SA_RIGHT); //cargo amount in pcs
+					y += line_height;
+				}
+
+				GfxFillRect(r.left, y + 1, r.right, y + 1, PC_BLACK);
+				y += CT_LINESPACE;
+				SetDParam(0, sum_cargo_amount);
+				DrawString(r.left, r.right, y, STR_TOOLBAR_CARGOS_UNITS_TOTAL, TC_FROMSTRING, SA_RIGHT);
+				break;
+
+			case WID_CT_INCOME:
+				for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+
+					if (this->cargoPeriod == WID_CT_OPTION_CARGO_MONTH) {
+						sum_cargo_income += c->cargo_income_period[0][cs->Index()];
+						DrawPrice(c->cargo_income_period[0][cs->Index()], r.left, r.right, y + text_y_ofs);
+					} else {
+						sum_cargo_income += c->cargo_income[cs->Index()];
+						DrawPrice(c->cargo_income[cs->Index()], r.left, r.right, y + text_y_ofs);
+					}
+
+					y += line_height;
+				}
+
+				GfxFillRect(r.left, y + 1, r.right, y + 1, PC_BLACK);
+				y += CT_LINESPACE;
+				DrawPrice(sum_cargo_income, r.left, r.right, y);
+				break;
+		}
+	}
+};
+
+static const NWidgetPart _nested_cargos_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_CT_CAPTION), SetDataTip(STR_TOOLBAR_CARGOS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY), SetResize(1, 1),
+		NWidget(NWID_HORIZONTAL), SetPadding(WD_FRAMERECT_TOP, WD_FRAMERECT_RIGHT, WD_FRAMERECT_BOTTOM, WD_FRAMERECT_LEFT), SetPIP(0, 9, 0),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_CT_HEADER_CARGO), SetFill(1, 0), SetPadding(2,2,2,2), SetDataTip(STR_TOOLBAR_CARGOS_HEADER_CARGO, STR_TOOLBAR_CARGOS_HEADER_CARGO),
+			NWidget(WWT_TEXT, COLOUR_GREY, WID_CT_HEADER_AMOUNT), SetMinimalSize(108, 16), SetFill(1, 0), SetPadding(2,2,2,2), SetDataTip(STR_NULL, STR_NULL),
+			NWidget(WWT_TEXT, COLOUR_GREY, WID_CT_HEADER_INCOME), SetMinimalSize(108, 16), SetFill(1, 0), SetPadding(2,2,2,2), SetDataTip(STR_NULL, STR_NULL),
+		EndContainer(),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY), SetResize(1, 1),
+		NWidget(NWID_HORIZONTAL), SetPadding(WD_FRAMERECT_TOP, WD_FRAMERECT_RIGHT, WD_FRAMERECT_BOTTOM, WD_FRAMERECT_LEFT), SetPIP(0, 9, 0),
+			NWidget(WWT_EMPTY, COLOUR_GREY, WID_CT_LIST),SetFill(1, 0), SetPadding(2,2,2,2), SetResize(1, 1),
+			NWidget(WWT_EMPTY, COLOUR_GREY, WID_CT_AMOUNT),SetMinimalSize(108, 0),SetFill(1, 0), SetPadding(2,2,2,2), SetResize(1, 1),
+			NWidget(WWT_EMPTY, COLOUR_GREY, WID_CT_INCOME),SetMinimalSize(108, 0),SetFill(1, 0), SetPadding(2,2,2,2), SetResize(1, 1),
+		EndContainer(),
+	EndContainer(),
+};
+
+static WindowDesc _cargos_desc(
+	WDP_AUTO, NULL, 0, 0,
+	WC_CARGOS, WC_NONE,
+	WDF_CONSTRUCTION,
+	_nested_cargos_widgets, lengthof(_nested_cargos_widgets)
+);
+
+void ShowCompanyCargos(CompanyID company)
+{
+	if (!Company::IsValidID(company)) return;
+	AllocateWindowDescFront<CargosWindow>(&_cargos_desc, company);
+}
diff --git a/src/cargo_table_gui.h b/src/cargo_table_gui.h
new file mode 100644
index 000000000..a997899ae
--- /dev/null
+++ b/src/cargo_table_gui.h
@@ -0,0 +1,14 @@
+/* $Id: cargo_table_gui.h 21700 2011-01-03 11:55:08Z  $ */
+
+/** @file cargo_table_gui.h GUI Functions related to cargos. */
+
+#ifndef CARGO_TABLE_H
+#define CARGO_TABLE_H
+
+#include "company_type.h"
+#include "gfx_type.h"
+
+void ShowCompanyCargos(CompanyID company);
+void InvalidateCargosWindows(CompanyID cid);
+
+#endif /* CARGO_TABLE_H */
diff --git a/src/command.cpp b/src/command.cpp
index 7d1a72dec..d2ef3f2a6 100644
--- a/src/command.cpp
+++ b/src/command.cpp
@@ -22,9 +22,12 @@
 #include "company_func.h"
 #include "company_base.h"
 #include "signal_func.h"
+#include "window_func.h"
 #include "core/backup_type.hpp"
 #include "object_base.h"
 
+#include "watch_gui_1.h"
+
 #include "table/strings.h"
 
 #include "safeguards.h"
@@ -570,6 +573,7 @@ bool DoCommandP(TileIndex tile, uint32 p1, uint32 p2, uint32 cmd, CommandCallbac
 			!(cmd & CMD_NETWORK_COMMAND) &&
 			!(GetCommandFlags(cmd) & CMD_NO_EST);
 
+
 	/* We're only sending the command, so don't do
 	 * fancy things for 'success'. */
 	bool only_sending = _networking && !(cmd & CMD_NETWORK_COMMAND);
@@ -768,6 +772,16 @@ CommandCost DoCommandPInternal(TileIndex tile, uint32 p1, uint32 p2, uint32 cmd,
 	/* update signals if needed */
 	UpdateSignalsInBuffer();
 
+  /* Send Tile Number to Watching Company Windows - Original */
+	int watching_window = 0;
+	WatchCompany1 *wc;
+	wc = dynamic_cast<WatchCompany1*>(FindWindowById(WC_WATCH_COMPANY1, watching_window));
+	while (wc!=NULL) {
+		wc->OnDoCommand( _current_company, tile );
+		watching_window++;
+		wc = dynamic_cast<WatchCompany1*>(FindWindowById(WC_WATCH_COMPANY1, watching_window));
+	}
+
 	return_dcpi(res2);
 }
 #undef return_dcpi
diff --git a/src/command_type.h b/src/command_type.h
index 61154ea04..abab2deb1 100644
--- a/src/command_type.h
+++ b/src/command_type.h
@@ -378,6 +378,7 @@ DECLARE_ENUM_AS_BIT_SET(DoCommandFlag)
  */
 enum FlaggedCommands {
 	CMD_NETWORK_COMMAND       = 0x0100, ///< execute the command without sending it on the network
+	CMD_NO_ESTIMATE           = 0x0200, ///< execute command instead of doing estimate even if shift is pressed
 	CMD_FLAGS_MASK            = 0xFF00, ///< mask for all command flags
 	CMD_ID_MASK               = 0x00FF, ///< mask for the command ID
 };
diff --git a/src/commands_token_gui.cpp b/src/commands_token_gui.cpp
new file mode 100644
index 000000000..b2c91284f
--- /dev/null
+++ b/src/commands_token_gui.cpp
@@ -0,0 +1,126 @@
+/* $Id: commands_token_gui.cpp	23663 2011-12-23 18:01:50	me $ */
+
+#include "stdafx.h"
+#include "widget_type.h"
+#include "window_func.h"
+#include "strings_func.h"
+#include "commands_token_gui.h"
+#include "network/network.h"
+#include "network/network_func.h"
+#include "network/network_base.h"
+#include "network/network_type.h"
+#include "table/strings.h"
+#include "console_func.h"
+#include "error.h"
+#include "base64.h"
+#include <iostream>
+
+#include "safeguards.h"
+
+enum TokenLoginWidgets {
+	NIC_TOKEN_USER,
+	NIC_TOKEN_LOGIN,
+	NIC_TOKEN_COMMUNITY,
+	NIC_TOKEN_WEBSITE,
+	NIC_TOKEN_WIKI,
+	NIC_OTHER_WIKI_RULES,
+	NIC_OTHER_IRC_CHAT,
+	NIC_OTHER_IRC_SERVERS,
+};
+
+class TokenLoginGui : public Window
+{
+	public:
+		TokenLoginGui(WindowDesc *desc, int window_number) : Window(desc)
+		{
+			this->InitNested(window_number);
+		}
+
+	virtual void OnPaint()
+	{
+		this->DrawWidgets();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if(widget == NIC_TOKEN_USER) SetDParamStr(0, _settings_client.network.community_user[_settings_client.gui.community-1]);
+		else if(widget == NIC_TOKEN_COMMUNITY) SetDParam(0, (STR_CC_SEPARATOR_DEFAULT + (uint16)_settings_client.gui.community));
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		extern void OpenBrowser(const char *url);
+		switch (widget) {
+			case NIC_TOKEN_LOGIN:
+        if ((_networking) && (_settings_client.gui.community != 0)) {
+          //LoginToken();
+          //loginmgr.initiateLoginSequence();
+          CommunityLoginManagerSend();
+        } else {
+          // do nothing
+        }
+				break;
+			case NIC_TOKEN_WEBSITE:
+          if(_settings_client.gui.community == 1) OpenBrowser("http://www.n-ice.org/openttd");
+          else if(_settings_client.gui.community == 2) OpenBrowser("https://openttd.btpro.nl");
+				break;
+			case NIC_TOKEN_WIKI:
+          if(_settings_client.gui.community == 1) OpenBrowser("http://www.n-ice.org/openttd");
+          else if(_settings_client.gui.community == 2) OpenBrowser("https://openttd.btpro.nl/contact-us/vip-membership");
+				break;
+			case NIC_OTHER_WIKI_RULES:
+				if(_settings_client.gui.community == 1) OpenBrowser("https://wiki.x-base.info/OpenTTD/Rules");
+				else if(_settings_client.gui.community == 2) OpenBrowser("https://openttd.btpro.nl/wiki/index.php/Server_Rules");
+				break;
+			case NIC_OTHER_IRC_CHAT:
+				if(_settings_client.gui.community == 1) OpenBrowser("https://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2FOpenTTD.Chat");
+				else if(_settings_client.gui.community == 2) OpenBrowser("https://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2Fbtpro-chat");
+				break;
+			case NIC_OTHER_IRC_SERVERS:
+				if(_settings_client.gui.community == 1) OpenBrowser("https://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2FOpenTTD");
+				else if(_settings_client.gui.community == 2) OpenBrowser("https://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2Fbtpro-openttd");
+				break;
+		}
+	}
+};
+
+static const NWidgetPart _nested_token_login_widgets[] = {
+	/* Title Bar with close box, title, shade and stick boxes */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY), SetDataTip(STR_CC_GLOBAL_COMMANDS_TITLE, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY), SetFill(0, 1), SetPIP(2, 2, 2),
+		NWidget(NWID_VERTICAL), SetPadding(0, 5, 0, 5),
+			NWidget(WWT_TEXT, COLOUR_BROWN, NIC_TOKEN_USER), SetDataTip(STR_CC_TOKEN_WELCOME, STR_NULL), SetMinimalSize(110, 16),
+			NWidget(WWT_TEXT, COLOUR_BROWN), SetDataTip(STR_CC_TOKEN_CLICKME, STR_NULL), SetMinimalSize(110, 16),
+			NWidget(NWID_HORIZONTAL), SetPIP(2, 2, 2),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, NIC_TOKEN_LOGIN), SetMinimalSize(105, 40),SetFill(1, 0), SetDataTip(STR_CC_TOKEN_LOGIN, STR_CC_TOKEN_LOGIN_TOOLTIP),
+			EndContainer(),
+			NWidget(WWT_TEXT, COLOUR_BROWN), SetDataTip(STR_CC_TOKEN_ENJOY, STR_NULL), SetMinimalSize(110, 16),
+			NWidget(WWT_TEXT, COLOUR_BROWN, NIC_TOKEN_COMMUNITY), SetDataTip(STR_CC_SEPARATOR, STR_NULL), SetMinimalSize(110, 16),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, NIC_TOKEN_WEBSITE), SetMinimalSize(120, 14),SetFill(1, 0), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE, STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE_TOOLTIP),
+			NWidget(NWID_HORIZONTAL ), SetPadding(5, 0, 5, 0),
+				NWidget( WWT_PUSHTXTBTN, COLOUR_GREY, NIC_OTHER_IRC_CHAT ), SetMinimalSize(57, 14),SetFill(1, 0), SetDataTip( STR_CC_IRC_LINK_CHAT, STR_CC_IRC_LINK_CHAT_TOOLTIP ),
+				NWidget(WWT_TEXT, COLOUR_BROWN), SetDataTip(STR_CC_IRC_LINK_SERVERS_SPACER, STR_NULL), SetMinimalSize(6, 14),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, NIC_OTHER_IRC_SERVERS ), SetMinimalSize(57, 14),SetFill(1, 0), SetDataTip( STR_CC_IRC_LINK_SERVERS, STR_CC_IRC_LINK_SERVERS_TOOLTIP ),
+			EndContainer(),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, NIC_OTHER_WIKI_RULES ), SetMinimalSize(120, 14),SetFill(1, 0), SetDataTip( STR_CC_WIKI_RULES_PAGE, STR_CC_WIKI_RULES_PAGE_TOOLTIP ),
+		EndContainer(),
+		NWidget(NWID_SPACER), SetMinimalSize(2, 2), SetFill(0, 1),
+	EndContainer(),
+};
+
+static WindowDesc _token_login_desc(
+	WDP_CENTER, "commands_token_gui", 0, 0,
+	WC_CC_TOKENLOGIN, WC_NONE,
+	0,
+	_nested_token_login_widgets, lengthof(_nested_token_login_widgets)
+);
+
+void ShowTokenLogin()
+{
+	AllocateWindowDescFront<TokenLoginGui>(&_token_login_desc, 0);
+}
diff --git a/src/commands_token_gui.h b/src/commands_token_gui.h
new file mode 100644
index 000000000..9779a6fbb
--- /dev/null
+++ b/src/commands_token_gui.h
@@ -0,0 +1,12 @@
+/* $Id: commands_token_gui.h $ */
+
+#ifndef COMMANDS_TOKEN_GUI_H
+#define COMMANDS_TOKEN_GUI_H
+
+#include "window_gui.h"
+#include "company_base.h"
+
+//void LoginToken();
+void ShowTokenLogin();
+
+#endif
diff --git a/src/company_base.h b/src/company_base.h
index 065931c6c..cab27bc36 100644
--- a/src/company_base.h
+++ b/src/company_base.h
@@ -15,6 +15,7 @@
 #include "autoreplace_type.h"
 #include "tile_type.h"
 #include "settings_type.h"
+#include "cargo_type.h"
 #include "group.h"
 #include <string>
 
@@ -25,6 +26,7 @@ struct CompanyEconomyEntry {
 	CargoArray delivered_cargo; ///< The amount of delivered cargo.
 	int32 performance_history;  ///< Company score (scale 0-1000)
 	Money company_value;        ///< The value of the company.
+	Money cargo_income[NUM_CARGO]; ///< Cargo income from each cargo type
 };
 
 struct CompanyInfrastructure {
@@ -127,6 +129,12 @@ struct Company : CompanyProperties, CompanyPool::PoolItem<&_company_pool> {
 
 	CompanyInfrastructure infrastructure; ///< NOSAVE: Counts of company owned infrastructure.
 
+	uint32 cargo_units[NUM_CARGO];   ///< Total amount of transported cargo for each cargo ID
+	Money cargo_income[NUM_CARGO];   ///< Total income from transported cargo for each cargo ID
+
+	uint32 cargo_units_period[2][NUM_CARGO];   ///< Monthly amount of transported cargo for each cargo ID 
+	Money cargo_income_period[2][NUM_CARGO];   ///< Monthly income from transported cargo for each cargo ID
+
 	/**
 	 * Is this company a valid company, controlled by the computer (a NoAI program)?
 	 * @param index Index in the pool.
diff --git a/src/company_cmd.cpp b/src/company_cmd.cpp
index 754921284..7f9c980ae 100644
--- a/src/company_cmd.cpp
+++ b/src/company_cmd.cpp
@@ -37,6 +37,7 @@
 #include "story_base.h"
 #include "widgets/statusbar_widget.h"
 
+#include "cargo_type.h"
 #include "table/strings.h"
 
 #include "safeguards.h"
@@ -69,6 +70,7 @@ Company::Company(uint16 name_1, bool is_ai)
 
 	for (uint j = 0; j < 4; j++) this->share_owners[j] = INVALID_OWNER;
 	InvalidateWindowData(WC_PERFORMANCE_DETAIL, 0, INVALID_COMPANY);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
 }
 
 /** Destructor. */
@@ -89,6 +91,7 @@ void Company::PostDestructor(size_t index)
 	InvalidateWindowData(WC_PERFORMANCE_DETAIL, 0, (int)index);
 	InvalidateWindowData(WC_COMPANY_LEAGUE, 0, 0);
 	InvalidateWindowData(WC_LINKGRAPH_LEGEND, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
 	/* If the currently shown error message has this company in it, then close it. */
 	InvalidateWindowData(WC_ERRMSG, 0);
 }
@@ -580,9 +583,28 @@ Company *DoStartupNewCompany(bool is_ai, CompanyID company = INVALID_COMPANY)
 	AI::BroadcastNewEvent(new ScriptEventCompanyNew(c->index), c->index);
 	Game::NewEvent(new ScriptEventCompanyNew(c->index));
 
+	if (!is_ai) UpdateAllTownVirtCoords(); //coloured rating
+
+	for (uint j = 0; j < NUM_CARGO; j++) {
+		c->cargo_income[j] = 0;
+		c->cargo_units[j] = 0;
+	}
+	cargo_iam_free(c);
+
+  if (!is_ai) UpdateAllTownVirtCoords(); //coloured rating
+
 	return c;
 }
 
+void cargo_iam_free(Company *c){
+	for (uint j = 0; j < NUM_CARGO; j++) {
+		c->cargo_units_period[0][j] = 0;
+		c->cargo_units_period[1][j] = 0;
+		c->cargo_income_period[0][j] = 0;
+		c->cargo_income_period[1][j] = 0;
+	}
+}
+
 /** Start the next competitor now. */
 void StartupCompanies()
 {
@@ -1079,6 +1101,7 @@ CommandCost CmdRenameCompany(TileIndex tile, DoCommandFlag flags, uint32 p1, uin
 		} else {
 			c->name = text;
 		}
+		InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
 		MarkWholeScreenDirty();
 		CompanyAdminUpdate(c);
 	}
diff --git a/src/company_func.h b/src/company_func.h
index 01f585910..4a4ba98cb 100644
--- a/src/company_func.h
+++ b/src/company_func.h
@@ -29,6 +29,7 @@ void SubtractMoneyFromCompany(const CommandCost& cost);
 void SubtractMoneyFromCompanyFract(CompanyID company, const CommandCost& cost);
 CommandCost CheckOwnership(Owner owner, TileIndex tile = 0);
 CommandCost CheckTileOwnership(TileIndex tile);
+void cargo_iam_free(Company *c);
 
 extern CompanyID _local_company;
 extern CompanyID _current_company;
diff --git a/src/crashlog.cpp b/src/crashlog.cpp
index b0cda0adf..e390df6e8 100644
--- a/src/crashlog.cpp
+++ b/src/crashlog.cpp
@@ -116,7 +116,7 @@ char *CrashLog::LogCompiler(char *buffer, const char *last) const
 char *CrashLog::LogOpenTTDVersion(char *buffer, const char *last) const
 {
 	return buffer + seprintf(buffer, last,
-			"OpenTTD version:\n"
+			"OpenTTD version: N-ice patchpack (Build 12.2A) \n\n\n"
 			" Version:    %s (%d)\n"
 			" NewGRF ver: %08x\n"
 			" Bits:       %d\n"
diff --git a/src/depot_gui.cpp b/src/depot_gui.cpp
index d6f4d900c..a0d1c0c46 100644
--- a/src/depot_gui.cpp
+++ b/src/depot_gui.cpp
@@ -26,6 +26,7 @@
 #include "vehiclelist.h"
 #include "order_backup.h"
 #include "zoom_func.h"
+#include "hotkeys.h"
 
 #include "widgets/depot_widget.h"
 
@@ -79,34 +80,6 @@ static const NWidgetPart _nested_train_depot_widgets[] = {
 	EndContainer(),
 };
 
-static WindowDesc _train_depot_desc(
-	WDP_AUTO, "depot_train", 362, 123,
-	WC_VEHICLE_DEPOT, WC_NONE,
-	0,
-	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
-);
-
-static WindowDesc _road_depot_desc(
-	WDP_AUTO, "depot_roadveh", 316, 97,
-	WC_VEHICLE_DEPOT, WC_NONE,
-	0,
-	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
-);
-
-static WindowDesc _ship_depot_desc(
-	WDP_AUTO, "depot_ship", 306, 99,
-	WC_VEHICLE_DEPOT, WC_NONE,
-	0,
-	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
-);
-
-static WindowDesc _aircraft_depot_desc(
-	WDP_AUTO, "depot_aircraft", 332, 99,
-	WC_VEHICLE_DEPOT, WC_NONE,
-	0,
-	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
-);
-
 extern void DepotSortList(VehicleList *list);
 
 /**
@@ -1083,7 +1056,23 @@ struct DepotWindow : Window {
 	{
 		return (this->type == VEH_AIRCRAFT) ? ::GetStationIndex(this->window_number) : ::GetDepotIndex(this->window_number);
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		if (this->owner != _local_company) return ES_NOT_HANDLED;
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
+};
+
+static Hotkey depot_hotkeys[] = {
+	Hotkey(WKC_CTRL | 'F', "depot_go_all", WID_D_START_ALL),
+	Hotkey('R', "depot_build_vehicle", WID_D_BUILD),
+	Hotkey(WKC_NONE, "depot_clone_vehicle", WID_D_CLONE),
+	HOTKEY_LIST_END
 };
+HotkeyList DepotWindow::hotkeys("depot_gui", depot_hotkeys);
 
 static void DepotSellAllConfirmationCallback(Window *win, bool confirmed)
 {
@@ -1095,6 +1084,38 @@ static void DepotSellAllConfirmationCallback(Window *win, bool confirmed)
 	}
 }
 
+static WindowDesc _train_depot_desc(
+	WDP_AUTO, "depot_train", 362, 123,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets),
+	&DepotWindow::hotkeys
+);
+
+static WindowDesc _road_depot_desc(
+	WDP_AUTO, "depot_roadveh", 316, 97,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets),
+	&DepotWindow::hotkeys
+);
+
+static WindowDesc _ship_depot_desc(
+	WDP_AUTO, "depot_ship", 306, 99,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets),
+	&DepotWindow::hotkeys
+);
+
+static WindowDesc _aircraft_depot_desc(
+	WDP_AUTO, "depot_aircraft", 332, 99,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets),
+	&DepotWindow::hotkeys
+);
+
 /**
  * Opens a depot window
  * @param tile The tile where the depot/hangar is located
diff --git a/src/economy.cpp b/src/economy.cpp
index fc43b6506..7983ccc08 100644
--- a/src/economy.cpp
+++ b/src/economy.cpp
@@ -38,6 +38,7 @@
 #include "subsidy_func.h"
 #include "station_base.h"
 #include "waypoint_base.h"
+#include "triphistory.h"
 #include "economy_base.h"
 #include "core/pool_func.hpp"
 #include "core/backup_type.hpp"
@@ -51,6 +52,7 @@
 
 #include "table/strings.h"
 #include "table/pricebase.h"
+#include "cargo_table_gui.h"
 
 #include "safeguards.h"
 
@@ -1126,6 +1128,16 @@ static Money DeliverGoods(int num_pieces, CargoID cargo_type, StationID dest, Ti
 		}
 	}
 
+	company->cargo_income[cargo_type] += profit;
+	company->cargo_units[cargo_type] += num_pieces;
+
+	company->cargo_income_period[0][cargo_type] += profit;
+	company->cargo_units_period[0][cargo_type] += num_pieces;
+
+	company->cur_economy.cargo_income[cargo_type] += profit;	
+
+	InvalidateCargosWindows(company->index);
+
 	return profit;
 }
 
@@ -1199,6 +1211,8 @@ CargoPayment::~CargoPayment()
 				this->front->z_pos, -this->visual_profit);
 	}
 
+	this->front->trip_history.AddValue(this->route_profit, _date);
+	InvalidateWindowData(WC_VEHICLE_TRIP_HISTORY, this->front->index);
 	cur_company.Restore();
 }
 
@@ -1967,6 +1981,11 @@ void CompaniesMonthlyLoop()
 	}
 	CompaniesPayInterest();
 	HandleEconomyFluctuations();
+
+	Company *c;
+	for (Company *c : Company::Iterate()) {
+		cargo_iam_free(c);
+	}
 }
 
 static void DoAcquireCompany(Company *c)
diff --git a/src/gfx.cpp b/src/gfx.cpp
index 5e2614bc7..1b7007c2b 100644
--- a/src/gfx.cpp
+++ b/src/gfx.cpp
@@ -34,6 +34,7 @@ bool _fullscreen;
 byte _support8bpp;
 CursorVars _cursor;
 bool _ctrl_pressed;   ///< Is Ctrl pressed?
+bool _alt_pressed;    ///< Is Alt pressed?
 bool _shift_pressed;  ///< Is Shift pressed?
 uint16 _game_speed = 100; ///< Current game-speed; 100 is 1x, 0 is infinite.
 bool _left_button_down;     ///< Is left mouse button pressed?
diff --git a/src/gfx_func.h b/src/gfx_func.h
index 59b6b54f9..639f3172d 100644
--- a/src/gfx_func.h
+++ b/src/gfx_func.h
@@ -53,6 +53,7 @@ extern bool _fullscreen;
 extern byte _support8bpp;
 extern CursorVars _cursor;
 extern bool _ctrl_pressed;   ///< Is Ctrl pressed?
+extern bool _alt_pressed;    ///< Is Alt pressed?
 extern bool _shift_pressed;  ///< Is Shift pressed?
 extern uint16 _game_speed;
 
diff --git a/src/gfxinit.cpp b/src/gfxinit.cpp
index d2d33fc43..06601a55a 100644
--- a/src/gfxinit.cpp
+++ b/src/gfxinit.cpp
@@ -183,6 +183,8 @@ static void LoadSpriteTables()
 		);
 	}
 
+	LoadGrfFile("newgrf/innerhighlight.grf", SPR_INNER_HIGHLIGHT_BASE, false);
+
 	/* Initialize the unicode to sprite mapping table */
 	InitializeUnicodeGlyphMap();
 
diff --git a/src/graph_gui.cpp b/src/graph_gui.cpp
index 4779f811a..64c9eb5a9 100644
--- a/src/graph_gui.cpp
+++ b/src/graph_gui.cpp
@@ -102,6 +102,22 @@ struct GraphLegendWindow : Window {
 	}
 };
 
+/** Construct the row containing the digit keys. */
+static NWidgetBase *MakeCargoButtons(int *biggest_index)
+{
+	NWidgetVertical *ver = new NWidgetVertical;
+
+	for (int i = 0; i < _sorted_standard_cargo_specs.size(); i++) {
+		NWidgetBackground *leaf = new NWidgetBackground(WWT_PANEL, COLOUR_ORANGE, WID_CPR_MATRIX + i, NULL);
+		leaf->tool_tip = STR_GRAPH_CARGO_PAYMENT_TOGGLE_CARGO;
+		leaf->SetFill(1, 0);
+		leaf->SetLowered(true);
+		ver->Add(leaf);
+	}
+	*biggest_index = WID_CPR_MATRIX + _sorted_standard_cargo_specs.size() - 1;
+	return ver;
+}
+
 /**
  * Construct a vertical list of buttons, one for each company.
  * @param biggest_index Storage for collecting the biggest index used in the returned tree.
@@ -542,6 +558,25 @@ public:
 		return INVALID_DATAPOINT;
 	}
 
+	void UpdateExcludedData()
+	{
+		this->excluded_data = 0;
+
+		int i = 0;
+		const CargoSpec *cs;
+		for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+			if (HasBit(_legend_excluded_cargo, cs->Index())) SetBit(this->excluded_data, i);
+			i++;
+		}
+	}
+
+	void UpdateLoweredWidgets()
+	{
+		for (int i = 0; i < _sorted_standard_cargo_specs.size(); i++) {
+			this->SetWidgetLoweredState(WID_CPR_MATRIX + i, !HasBit(this->excluded_data, i));
+		}
+	}
+
 	void OnClick(Point pt, int widget, int click_count) override
 	{
 		/* Clicked on legend? */
@@ -682,8 +717,60 @@ struct IncomeGraphWindow : BaseGraphWindow {
 
 	OverflowSafeInt64 GetGraphData(const Company *c, int j) override
 	{
+		if(_legend_excluded_cargo == 0){
 		return c->old_economy[j].income;
 	}
+		uint total_income = 0;
+		const CargoSpec *cs;
+		for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+			if (!HasBit(_legend_excluded_cargo, cs->Index())){
+				total_income += c->old_economy[j].cargo_income[cs->Index()];
+			}
+		}
+		return total_income;
+	}
+
+	void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize) override
+	{
+		if (widget < WID_CPR_MATRIX) {
+			BaseGraphWindow::UpdateWidgetSize(widget, size, padding, fill, resize);
+			return;
+		}
+
+		const CargoSpec *cs = _sorted_cargo_specs[widget - WID_CPR_MATRIX];
+		SetDParam(0, cs->name);
+		Dimension d = GetStringBoundingBox(STR_GRAPH_CARGO_PAYMENT_CARGO);
+		d.width += 14; // colour field
+		d.width += WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+		d.height += WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+		*size = maxdim(d, *size);
+	}
+
+	void DrawWidget(const Rect &r, int widget) const override
+	{
+		if (widget < WID_CPR_MATRIX) {
+			BaseGraphWindow::DrawWidget(r, widget);
+			return;
+		}
+
+		const CargoSpec *cs = _sorted_cargo_specs[widget - WID_CPR_MATRIX];
+		bool rtl = _current_text_dir == TD_RTL;
+
+		/* Since the buttons have no text, no images,
+		 * both the text and the coloured box have to be manually painted.
+		 * clk_dif will move one pixel down and one pixel to the right
+		 * when the button is clicked */
+		byte clk_dif = this->IsWidgetLowered(widget) ? 1 : 0;
+		int x = r.left + WD_FRAMERECT_LEFT;
+		int y = r.top;
+
+		int rect_x = clk_dif + (rtl ? r.right - 12 : r.left + WD_FRAMERECT_LEFT);
+
+		GfxFillRect(rect_x, y + clk_dif, rect_x + 8, y + 5 + clk_dif, PC_BLACK);
+		GfxFillRect(rect_x + 1, y + 1 + clk_dif, rect_x + 7, y + 4 + clk_dif, cs->legend_colour);
+		SetDParam(0, cs->name);
+		DrawString(rtl ? r.left : x + 14 + clk_dif, (rtl ? r.right - 14 + clk_dif : r.right), y + clk_dif, STR_GRAPH_CARGO_PAYMENT_CARGO);
+	}
 };
 
 static const NWidgetPart _nested_income_graph_widgets[] = {
@@ -698,6 +785,14 @@ static const NWidgetPart _nested_income_graph_widgets[] = {
 	NWidget(WWT_PANEL, COLOUR_BROWN, WID_CV_BACKGROUND),
 		NWidget(NWID_HORIZONTAL),
 			NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CV_GRAPH), SetMinimalSize(576, 128), SetFill(1, 1), SetResize(1, 1),
+			NWidget(NWID_VERTICAL),//add
+				NWidget(NWID_SPACER), SetMinimalSize(0, 24), SetFill(0, 0), SetResize(0, 1),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_CPR_ENABLE_CARGOES), SetDataTip(STR_GRAPH_CARGO_ENABLE_ALL, STR_GRAPH_CARGO_TOOLTIP_ENABLE_ALL), SetFill(1, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_CPR_DISABLE_CARGOES), SetDataTip(STR_GRAPH_CARGO_DISABLE_ALL, STR_GRAPH_CARGO_TOOLTIP_DISABLE_ALL), SetFill(1, 0),
+				NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+				NWidgetFunction(MakeCargoButtons),
+				NWidget(NWID_SPACER), SetMinimalSize(0, 24), SetFill(0, 1), SetResize(0, 1),
+			EndContainer(),//add
 			NWidget(NWID_VERTICAL),
 				NWidget(NWID_SPACER), SetFill(0, 1), SetResize(0, 1),
 				NWidget(WWT_RESIZEBOX, COLOUR_BROWN, WID_CV_RESIZE),
@@ -731,8 +826,60 @@ struct DeliveredCargoGraphWindow : BaseGraphWindow {
 
 	OverflowSafeInt64 GetGraphData(const Company *c, int j) override
 	{
+		if(_legend_excluded_cargo == 0){
 		return c->old_economy[j].delivered_cargo.GetSum<OverflowSafeInt64>();
 	}
+		uint total_delivered = 0;
+		const CargoSpec *cs;
+		for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+			if (!HasBit(_legend_excluded_cargo, cs->Index())){
+				total_delivered += c->old_economy[j].delivered_cargo[cs->Index()];
+			}
+		}
+		return total_delivered;
+	}
+
+	void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize) override
+	{
+		if (widget < WID_CPR_MATRIX) {
+			BaseGraphWindow::UpdateWidgetSize(widget, size, padding, fill, resize);
+			return;
+		}
+
+		const CargoSpec *cs = _sorted_cargo_specs[widget - WID_CPR_MATRIX];
+		SetDParam(0, cs->name);
+		Dimension d = GetStringBoundingBox(STR_GRAPH_CARGO_PAYMENT_CARGO);
+		d.width += 14; // colour field
+		d.width += WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+		d.height += WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+		*size = maxdim(d, *size);
+	}
+
+	void DrawWidget(const Rect &r, int widget) const override
+	{
+		if (widget < WID_CPR_MATRIX) {
+			BaseGraphWindow::DrawWidget(r, widget);
+			return;
+		}
+
+		const CargoSpec *cs = _sorted_cargo_specs[widget - WID_CPR_MATRIX];
+		bool rtl = _current_text_dir == TD_RTL;
+
+		/* Since the buttons have no text, no images,
+		 * both the text and the coloured box have to be manually painted.
+		 * clk_dif will move one pixel down and one pixel to the right
+		 * when the button is clicked */
+		byte clk_dif = this->IsWidgetLowered(widget) ? 1 : 0;
+		int x = r.left + WD_FRAMERECT_LEFT;
+		int y = r.top;
+
+		int rect_x = clk_dif + (rtl ? r.right - 12 : r.left + WD_FRAMERECT_LEFT);
+
+		GfxFillRect(rect_x, y + clk_dif, rect_x + 8, y + 5 + clk_dif, PC_BLACK);
+		GfxFillRect(rect_x + 1, y + 1 + clk_dif, rect_x + 7, y + 4 + clk_dif, cs->legend_colour);
+		SetDParam(0, cs->name);
+		DrawString(rtl ? r.left : x + 14 + clk_dif, (rtl ? r.right - 14 + clk_dif : r.right), y + clk_dif, STR_GRAPH_CARGO_PAYMENT_CARGO);
+	}
 };
 
 static const NWidgetPart _nested_delivered_cargo_graph_widgets[] = {
@@ -747,6 +894,15 @@ static const NWidgetPart _nested_delivered_cargo_graph_widgets[] = {
 	NWidget(WWT_PANEL, COLOUR_BROWN, WID_CV_BACKGROUND),
 		NWidget(NWID_HORIZONTAL),
 			NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CV_GRAPH), SetMinimalSize(576, 128), SetFill(1, 1), SetResize(1, 1),
+			NWidget(NWID_VERTICAL),//add
+				NWidget(NWID_SPACER), SetMinimalSize(0, 24), SetFill(0, 0), SetResize(0, 1),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_CPR_ENABLE_CARGOES), SetDataTip(STR_GRAPH_CARGO_ENABLE_ALL, STR_GRAPH_CARGO_TOOLTIP_ENABLE_ALL), SetFill(1, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_CPR_DISABLE_CARGOES), SetDataTip(STR_GRAPH_CARGO_DISABLE_ALL, STR_GRAPH_CARGO_TOOLTIP_DISABLE_ALL), SetFill(1, 0),
+				NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+				NWidgetFunction(MakeCargoButtons),
+				NWidget(NWID_SPACER), SetMinimalSize(0, 24), SetFill(0, 1), SetResize(0, 1),
+			EndContainer(),//add
+			NWidget(NWID_SPACER), SetMinimalSize(5, 0), SetFill(0, 1), SetResize(0, 1),
 			NWidget(NWID_VERTICAL),
 				NWidget(NWID_SPACER), SetFill(0, 1), SetResize(0, 1),
 				NWidget(WWT_RESIZEBOX, COLOUR_BROWN, WID_CV_RESIZE),
diff --git a/src/gui.h b/src/gui.h
index 4eb2fb7f6..a0abf08e3 100644
--- a/src/gui.h
+++ b/src/gui.h
@@ -41,11 +41,11 @@ void ShowGenerateLandscape();
 void ShowHeightmapLoad();
 
 /* misc_gui.cpp */
-void ShowLandInfo(TileIndex tile);
 void ShowAboutWindow();
 void ShowBuildTreesToolbar();
 void ShowTownDirectory();
 void ShowIndustryDirectory();
+void ShowAdvancedIndustryDirectory();
 void ShowIndustryCargoesWindow();
 void ShowSubsidiesList();
 void ShowGoalsList(CompanyID company);
diff --git a/src/industry.h b/src/industry.h
index ce30114cb..eb3d69418 100644
--- a/src/industry.h
+++ b/src/industry.h
@@ -239,6 +239,57 @@ struct IndustryBuildData {
 
 extern IndustryBuildData _industry_builder;
 
+struct SharedIndustryMeta {
+        int industry_count = 0;
+        int allocated_industry_count = 0;
+};
+
+struct SharedIndustry {
+        uint8 industry_type;
+        byte produced_cargo[2];
+        byte accepts_cargo[3];
+        byte production_rate[2];
+        byte prod_level;
+        uint16 last_month_production[2];
+};
+
+extern SharedIndustryMeta* sharedIndustryMeta;
+extern SharedIndustry* sharedIndustry;
+
+struct SlotInfo {
+        char slotname[20];
+        int* cargo_ids;
+        float* cargo_id_weights;
+        int cargo_count;
+        int station_size;
+        int slot;
+        int limit;
+        bool autorefresh;
+        bool invalid;
+        int additive_weights;
+};
+
+extern void invalidateSlotInfos();
+extern void startAutoRefresh();
+extern void updateSharedIndustry(int industry_count, int max_idx);
+
+struct ProductionSource {
+        unsigned int last_month_production;
+
+        unsigned char industry_count;
+        short industry_indices[50];
+
+        unsigned int len;
+        unsigned int* coordinates;
+        unsigned int center;
+        unsigned int diameter;
+};
+
+struct ProductionSourceMeta {
+        unsigned int len;
+        ProductionSource* production_source;
+};
+
 
 /** Special values for the industry list window for the data parameter of #InvalidateWindowData. */
 enum IndustryDirectoryInvalidateWindowData {
diff --git a/src/industry_cmd.cpp b/src/industry_cmd.cpp
index b03a722b7..4ccf7b8fd 100644
--- a/src/industry_cmd.cpp
+++ b/src/industry_cmd.cpp
@@ -47,7 +47,10 @@
 #include "table/industry_land.h"
 #include "table/build_industry.h"
 
-#include "safeguards.h"
+//#include "safeguards.h"
+
+#include "../openttd_cuda/openttd_cuda_dll.h"
+#include "math.h"
 
 IndustryPool _industry_pool("Industry");
 INSTANTIATE_POOL_METHODS(Industry)
@@ -2922,14 +2925,105 @@ void IndustryDailyLoop()
 	InvalidateWindowData(WC_INDUSTRY_DIRECTORY, 0, IDIWD_PRODUCTION_CHANGE);
 }
 
+SharedIndustryMeta *shared_industry_meta = NULL;
+SharedIndustry *shared_industry = NULL;
+
+void copyIndustryValues() {
+	printf("copying\n");
+       int *inactive_industries = MallocT<int>(shared_industry_meta->allocated_industry_count);
+       for (int i = 0; i < shared_industry_meta->allocated_industry_count; i++) {
+               inactive_industries[i] = i;
+       }
+       for (Industry *i : Industry::Iterate()) {
+               shared_industry[i->index].industry_type = i->type;
+               shared_industry[i->index].produced_cargo[0] = i->produced_cargo[0];
+               shared_industry[i->index].produced_cargo[1] = i->produced_cargo[1];
+               shared_industry[i->index].accepts_cargo[0] = i->accepts_cargo[0];
+               shared_industry[i->index].accepts_cargo[1] = i->accepts_cargo[1];
+               shared_industry[i->index].accepts_cargo[2] = i->accepts_cargo[2];
+               shared_industry[i->index].production_rate[0] = i->production_rate[0];
+               shared_industry[i->index].production_rate[1] = i->production_rate[1];
+               shared_industry[i->index].prod_level = i->prod_level;
+               shared_industry[i->index].last_month_production[0] = i->last_month_production[0];
+               shared_industry[i->index].last_month_production[1] = i->last_month_production[1];
+               inactive_industries[i->index] = shared_industry_meta->allocated_industry_count;
+       }
+       for (int i = 0; i < shared_industry_meta->allocated_industry_count; i++) {
+               if (inactive_industries[i] < shared_industry_meta->allocated_industry_count) {
+                       shared_industry[i].industry_type = 240; // INVALID_INDUSTRYTYPE = 240 -> hardcoded in gpu/dll code
+               }
+       }
+       free(inactive_industries);
+       printf("copying done\n");
+}
+
+#ifdef _WIN32
+DWORD *copyIndustryThreadStarter(LPVOID *args) {
+       copyIndustryValues();
+       return NULL;
+}
+#elif __linux__
+void *copyIndustryThreadStarter(void *args) {
+       copyIndustryValues();
+       return NULL;
+}
+#endif
+
+pthread_t copy_industry_thread;
+
+void updateSharedIndustry(int industry_count, int max_idx) {
+       int to_allocate = std::max(industry_count, max_idx);
+       printf("to_allocate: %i\n", to_allocate);
+       if (shared_industry_meta == NULL) {
+               shared_industry_meta = MallocT<SharedIndustryMeta>(1);
+               shared_industry_meta->allocated_industry_count = 0;
+               shared_industry_meta->industry_count = 0;
+               OpenTTDCuda::OpenTTDCuda::setSharedIndustryMeta(shared_industry_meta);
+       }
+       bool needAlloc = true;
+       bool firstCall = false;
+       if (to_allocate > shared_industry_meta->allocated_industry_count) {
+    	   printf("to_allocate > allocated\n");
+               if (shared_industry_meta->allocated_industry_count > 0) {
+            	   printf("freeing\n");
+                       free(shared_industry);
+               }
+       } else {
+    	   printf("no need alloc\n");
+               needAlloc = false;
+       }
+       if (needAlloc) {
+               shared_industry_meta->industry_count = industry_count;
+               shared_industry_meta->allocated_industry_count = to_allocate + 50;
+               shared_industry = MallocT<SharedIndustry>(shared_industry_meta->allocated_industry_count);
+               OpenTTDCuda::OpenTTDCuda::setSharedIndustry(shared_industry);
+               printf("need alloc ic: %i aic: %i\n", shared_industry_meta->industry_count, shared_industry_meta->allocated_industry_count);
+       }
+#ifdef _WIN32
+       CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)copyIndustryThreadStarter, NULL, 0, 0);
+#elif __linux__
+       pthread_create(&copy_industry_thread, nullptr, copyIndustryThreadStarter, nullptr);
+#endif
+}
+
+
 void IndustryMonthlyLoop()
 {
 	Backup<CompanyID> cur_company(_current_company, OWNER_NONE, FILE_LINE);
 
 	_industry_builder.MonthlyLoop();
 
+	int industry_count = 0;
+	int max_idx = 0;
+
 	for (Industry *i : Industry::Iterate()) {
 		UpdateIndustryStatistics(i);
+
+		industry_count++;
+		if (i->index > max_idx) {
+			max_idx = i->index;
+		}
+
 		if (i->prod_level == PRODLEVEL_CLOSURE) {
 			delete i;
 		} else {
@@ -2938,6 +3032,8 @@ void IndustryMonthlyLoop()
 		}
 	}
 
+	updateSharedIndustry(industry_count, max_idx);
+
 	cur_company.Restore();
 
 	/* production-change */
diff --git a/src/industry_gui.cpp b/src/industry_gui.cpp
index 1b63191f3..a9e078539 100644
--- a/src/industry_gui.cpp
+++ b/src/industry_gui.cpp
@@ -41,10 +41,18 @@
 #include "zoom_func.h"
 
 #include "table/strings.h"
+#include "hotkeys.h"
 
 #include <bitset>
 
-#include "safeguards.h"
+//#include "safeguards.h"
+
+#include "../openttd_cuda/openttd_cuda_dll.h"
+#include "textbuf_type.h"
+#include <sstream>
+#include <iostream>
+#include <fstream>
+#include "fileio_func.h"
 
 bool _ignore_restrictions;
 std::bitset<NUM_INDUSTRYTYPES> _displayed_industries; ///< Communication from the industry chain window to the smallmap window about what industries to display.
@@ -268,14 +276,6 @@ static const NWidgetPart _nested_build_industry_widgets[] = {
 	EndContainer(),
 };
 
-/** Window definition of the dynamic place industries gui */
-static WindowDesc _build_industry_desc(
-	WDP_AUTO, "build_industry", 170, 212,
-	WC_BUILD_INDUSTRY, WC_NONE,
-	WDF_CONSTRUCTION,
-	_nested_build_industry_widgets, lengthof(_nested_build_industry_widgets)
-);
-
 /** Build (fund or prospect) a new industry, */
 class BuildIndustryWindow : public Window {
 	int selected_index;                         ///< index of the element in the matrix
@@ -386,7 +386,7 @@ class BuildIndustryWindow : public Window {
 	}
 
 public:
-	BuildIndustryWindow() : Window(&_build_industry_desc)
+	BuildIndustryWindow(WindowDesc *desc) : Window(desc)
 	{
 		this->selected_index = -1;
 		this->selected_type = INVALID_INDUSTRYTYPE;
@@ -771,13 +771,38 @@ public:
 		this->SetButtons();
 		this->SetDirty();
 	}
+
+	EventState OnHotkey(int hotkey) override
+	{
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
 };
 
+static Hotkey build_industry_hotkeys[] = {
+	Hotkey((uint16)0, "display_chain", WID_DPI_DISPLAY_WIDGET),
+	Hotkey((uint16)0, "build_button", WID_DPI_FUND_WIDGET),
+	HOTKEY_LIST_END
+};
+
+HotkeyList BuildIndustryWindow::hotkeys("industry_fund_gui", build_industry_hotkeys);
+
+/** Window definition of the dynamic place industries gui */
+static WindowDesc _build_industry_desc(
+	WDP_AUTO, "build_industry", 170, 212,
+	WC_BUILD_INDUSTRY, WC_NONE,
+	WDF_CONSTRUCTION,
+	_nested_build_industry_widgets, lengthof(_nested_build_industry_widgets),
+	&BuildIndustryWindow::hotkeys
+);
+
+
 void ShowBuildIndustryWindow()
 {
 	if (_game_mode != GM_EDITOR && !Company::IsValidID(_local_company)) return;
 	if (BringWindowToFrontById(WC_BUILD_INDUSTRY, 0)) return;
-	new BuildIndustryWindow();
+	new BuildIndustryWindow(&_build_industry_desc);
 }
 
 static void UpdateIndustryProduction(Industry *i);
@@ -1730,7 +1755,6 @@ public:
 			case WID_ID_DROPDOWN_CRITERIA:
 				ShowDropDownMenu(this, IndustryDirectoryWindow::sorter_names, this->industries.SortType(), WID_ID_DROPDOWN_CRITERIA, 0, 0);
 				break;
-
 			case WID_ID_FILTER_BY_ACC_CARGO: // Cargo filter dropdown
 				ShowDropDownMenu(this, this->cargo_filter_texts, this->accepted_cargo_filter_criteria, WID_ID_FILTER_BY_ACC_CARGO, 0, 0);
 				break;
@@ -1849,11 +1873,1112 @@ static WindowDesc _industry_directory_desc(
 	_nested_industry_directory_widgets, lengthof(_nested_industry_directory_widgets)
 );
 
+/** Widgets of the advanced industry directory window. */
+static const NWidgetPart _nested_advanced_industry_directory_widgets[] = {
+NWidget(NWID_HORIZONTAL),
+NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
+NWidget(WWT_CAPTION, COLOUR_BROWN), SetDataTip(STR_INDUSTRY_DIRECTORY_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+NWidget(WWT_SHADEBOX, COLOUR_BROWN),
+NWidget(WWT_DEFSIZEBOX, COLOUR_BROWN),
+NWidget(WWT_STICKYBOX, COLOUR_BROWN),
+EndContainer(),
+NWidget(NWID_HORIZONTAL),
+NWidget(NWID_VERTICAL),
+NWidget(WWT_PANEL, COLOUR_BROWN, WID_AD_SLOT_LIST), SetMinimalSize(132, 100), SetDataTip(0x0, STR_NULL), SetResize(0, 1), EndContainer(),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_SLOTLIST_NAME), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_NULL, STR_AD_SLOTLIST_NAME_TIP),
+NWidget(NWID_HORIZONTAL),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_NEWSLOTLIST), SetMinimalSize(64, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_AD_NEWSLOTLIST, STR_AD_NEWSLOTLIST_TIP),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_DELETESLOTLIST), SetMinimalSize(64, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_AD_DELETESLOTLIST, STR_AD_DELETESLOTLIST_TIP),
+EndContainer(),
+NWidget(NWID_HORIZONTAL),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_LOADSLOTLIST), SetMinimalSize(64, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_AD_LOADSLOTLIST, STR_AD_LOADSLOTLIST_TIP),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_SAVESLOTLIST), SetMinimalSize(64, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_AD_SAVESLOTLIST, STR_AD_SAVESLOTLIST_TIP),
+EndContainer(),
+EndContainer(),
+NWidget(NWID_VERTICAL),
+NWidget(WWT_PANEL, COLOUR_BROWN, WID_AD_SLOTINFOPANEL), SetMinimalSize(396, 92), SetResize(1, 0),
+NWidget(NWID_VERTICAL),
+NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+NWidget(WWT_LABEL, COLOUR_GREY), SetDataTip(STR_AD_SLOTNAME, STR_AD_SLOTNAME_TIP), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0),
+NWidget(NWID_SPACER), SetMinimalSize(1, 12),
+NWidget(WWT_LABEL, COLOUR_GREY), SetDataTip(STR_AD_STATIONSIZE, STR_AD_STATIONSIZE_TIP), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0),
+NWidget(NWID_SPACER), SetMinimalSize(1, 12),
+NWidget(WWT_LABEL, COLOUR_GREY), SetDataTip(STR_AD_LIMIT, STR_AD_LIMIT_TIP), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0),
+EndContainer(),
+NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_SLOTNAME), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_NULL, STR_AD_SLOTNAME_TIP),
+NWidget(NWID_SPACER), SetMinimalSize(1, 12),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_STATIONSIZE), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_NULL, STR_AD_STATIONSIZE_TIP),
+NWidget(NWID_SPACER), SetMinimalSize(1, 12),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_LIMIT), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_NULL, STR_AD_LIMIT_TIP),
+EndContainer(),
+NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+NWidget(WWT_LABEL, COLOUR_GREY), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_AD_CARGOLIST, STR_AD_CARGOLIST_TIP),
+NWidget(NWID_SPACER), SetMinimalSize(1, 12),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_ADDCARGO), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0) , SetDataTip(STR_NULL, STR_AD_CARGOLIST_TIP),
+NWidget(NWID_SPACER), SetMinimalSize(1, 12),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_AUTOREFRESH), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0) , SetDataTip(STR_AD_AUTOREFRESH, STR_AD_AUTOREFRESH_TIP),
+EndContainer(),
+NWidget(NWID_HORIZONTAL),
+NWidget(NWID_VERTICAL),
+NWidget(WWT_PANEL, COLOUR_BROWN, WID_AD_CARGOLIST), SetMinimalSize(380, 40), SetFill(1, 0), SetResize(1, 0), SetScrollbar(WID_AD_CARGOSCROLLBAR), EndContainer(),
+EndContainer(),
+NWidget(NWID_VERTICAL),
+NWidget(NWID_VSCROLLBAR, COLOUR_BROWN, WID_AD_CARGOSCROLLBAR),
+EndContainer(),
+EndContainer(),
+NWidget(NWID_HORIZONTAL),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_ADDITIVEWEIGHT), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0), SetDataTip(STR_AD_ADDITIVEWEIGHT, STR_AD_ADDITIVEWEIGHT_TIP),
+NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_AD_SEARCH), SetMinimalSize(132, 12), SetFill(1, 0), SetResize(1, 0) , SetDataTip(STR_AD_SEARCH, STR_AD_SEARCH_TIP),
+EndContainer(),
+EndContainer(),
+EndContainer(),
+NWidget(NWID_HORIZONTAL),
+NWidget(NWID_VERTICAL),
+NWidget(WWT_PANEL, COLOUR_BROWN, WID_AD_INDUSTRY_LIST), SetDataTip(0x0, STR_INDUSTRY_DIRECTORY_LIST_CAPTION), SetResize(1, 1), SetScrollbar(WID_AD_SCROLLBAR), EndContainer(),
+EndContainer(),
+NWidget(NWID_VERTICAL),
+NWidget(NWID_VSCROLLBAR, COLOUR_BROWN, WID_AD_SCROLLBAR),
+NWidget(WWT_RESIZEBOX, COLOUR_BROWN),
+EndContainer(),
+EndContainer(),
+EndContainer(),
+EndContainer(),
+};
+
+typedef GUIList<SlotInfo*> GUISlotList;
+static GUISlotList slotlist;
+static bool* used_cuda_slots;
+
+static std::vector<std::string> slotlist_names;
+static int active_slot_list = 0;
+static int active_slot = 0;
+static bool slotlist_invalidated = true;
+
+
+void startSearch(SlotInfo* slot_info) {
+        OpenTTDCuda::OpenTTDCuda::calculateAndReduceCombinedProductionMapToSourceSlot(slot_info->cargo_ids, slot_info->cargo_id_weights, slot_info->cargo_count, slot_info->station_size, slot_info->slot, slot_info->limit, slot_info->additive_weights);
+}
+
+#ifdef _WIN32
+DWORD* startSearchThreadStarter(LPVOID* args) {
+        SlotInfo* slot_info = (SlotInfo*)args;
+        startSearch(slot_info);
+        return NULL;
+}
+#elif __linux__
+void* startSearchThreadStarter(void* args) {
+        SlotInfo* slot_info = (SlotInfo*)args;
+        startSearch(slot_info);
+        return NULL;
+}
+#endif
+
+void invalidateSlotInfos() {
+        for (int sl = 0; sl < slotlist.size(); sl++) {
+                slotlist[sl]->invalid = true;
+        }
+}
+
+void startAutoRefresh() {
+        if (slotlist.size() > active_slot) {
+                if (slotlist[active_slot]->autorefresh) {
+                        if (slotlist[active_slot]->invalid) {
+                                slotlist[active_slot]->invalid = false;
+#ifdef _WIN32
+                                CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)startSearchThreadStarter, (LPVOID*)slotlist[active_slot], 0, 0);
+#elif __linux__
+                                pthread_t thread_start_search;
+                                pthread_create(&thread_start_search, NULL, startSearchThreadStarter, slotlist[active_slot]);
+#endif
+                        }
+                }
+        }
+}
+
+/**
++* The advanced list of industries.
++*/
+class AdvancedIndustryDirectoryWindow : public Window {
+protected:
+        const static int QUERYWINDOW_SLOTLISTNAME = 0;
+        const static int QUERYWINDOW_SLOTNAME = QUERYWINDOW_SLOTLISTNAME + 1;
+        const static int QUERYWINDOW_STATIONSIZE = QUERYWINDOW_SLOTNAME + 1;
+        const static int QUERYWINDOW_LIMIT = QUERYWINDOW_STATIONSIZE + 1;
+        const static int QUERYWINDOW_CARGOLIST_BASE = QUERYWINDOW_LIMIT + 1;
+        int _querywindow_current;
+
+        bool slot_list_load = false;;
+        int production_sources_slots = 0;
+        ProductionSourceMeta* production_sources_meta;
+
+        CargoID available_cargos[NUM_CARGO];
+        StringID available_cargos_text[NUM_CARGO + 1];
+
+        Scrollbar* vscroll_cargo;
+        Scrollbar* vscroll;
+
+        void loadSlotList(int id) {
+                if (!isSlotListSaved() && id != active_slot_list) {
+                        slotlist_names.erase(slotlist_names.begin() + active_slot_list);
+                }
+                if (!isSlotListSaved() && id == active_slot_list) {
+                        return;
+                }
+                char filename_buf[260];
+                seprintf(filename_buf, lastof(filename_buf), "%s%s%i", _personal_dir, "advanced_industry_presets_", id);
+                std::ifstream serialised;
+                serialised.open(filename_buf);
+                if (serialised.is_open()) {
+                        removeAllSlots();
+                        std::string token;
+                        std::getline(serialised, token, '\n');
+                        int len = std::stoi(token);
+                        for (int i = 0; i < len; i++) {
+                                addSlot();
+                                //slotname
+                                std::getline(serialised, token, '\n');
+                                const char* cstr = token.c_str();
+                                for (int j = 0; j < token.length(); j++) {
+                                        slotlist[i]->slotname[j] = token.at(j);
+                                }
+                                slotlist[i]->slotname[token.length()] = '\0';
+                                //stationsize
+                                std::getline(serialised, token, '\n');
+                                slotlist[i]->station_size = std::stoi(token);
+                                //slot
+                                std::getline(serialised, token, '\n');
+                                slotlist[i]->slot = std::stoi(token);
+                                //limit
+                                std::getline(serialised, token, '\n');
+                                slotlist[i]->limit = std::stoi(token);
+                                //temp cargo_count
+                                std::getline(serialised, token, '\n');
+                                int tmp_cargo_count = std::stoi(token);
+                                for (int j = 0; j < tmp_cargo_count; j++) {
+                                        std::getline(serialised, token, '\n');
+                                        addCargoToSlot(i, std::stoi(token));
+                                        std::getline(serialised, token, '\n');
+                                        slotlist[i]->cargo_id_weights[j] = std::stof(token);
+
+                                }
+                                std::getline(serialised, token, '\n');
+                                slotlist[i]->additive_weights = std::stoi(token);
+                                slotlist[i]->autorefresh = false;
+                                slotlist[i]->invalid = true;
+                        }
+                        active_slot_list = id;
+                        invalidateSlotInfos();
+                }
+                else {
+                        printf("file not found\n");
+                }
+        }
+        void initSlotListNames() {
+                if (slotlist_names.size() > 0) return;
+                char filename_buf[260];
+                seprintf(filename_buf, lastof(filename_buf), "%s%s", _personal_dir, "advanced_industry_presets");
+                if (FileExists(filename_buf)) {
+                        std::ifstream file;
+                        file.open(filename_buf);
+                        if (file.is_open()) {
+                                std::string token;
+                                while (std::getline(file, token, '\n')) {
+                                        if (token.length() > 0) {
+                                                std::string name = token;
+                                                slotlist_names.push_back(name);
+                                        }
+                                }
+                                if (active_slot_list == NULL && slotlist_names.size() > 0) {
+                                        loadSlotList(0);
+                                        changeActiveSlot(0);
+                                }
+                        }
+                }
+        }
+
+        std::string getFreeSlotListName() {
+                std::string slotlist_name = "slot list";
+                bool found = true;
+                int ct = 1;
+                while (found) {
+                        found = false;
+                        for (int i = 0; i < slotlist_names.size(); i++) {
+                                if (slotlist_names[i] == slotlist_name) {
+                                        found = true;
+                                        break;
+                                }
+                        }
+                        if (found) {
+                                std::stringstream ss;
+                                ss << ct++;
+                                slotlist_name += " " + ss.str();
+                        }
+                }
+                return slotlist_name;
+        }
+
+        void saveSlotListNames() {
+                char filename_buf[260];
+                seprintf(filename_buf, lastof(filename_buf), "%s%s", _personal_dir, "advanced_industry_presets");
+                std::ofstream file;
+                file.open(filename_buf);
+                if (file.is_open()) {
+                        for (int i = 0; i < slotlist_names.size(); i++) {
+                                file << slotlist_names[i] << '\n';
+                        }
+                        file.flush();
+                        file.close();
+                }
+        }
+
+        void saveSlotList() {
+                std::stringstream serialised;
+
+                serialised << slotlist.size() << '\n';
+                for (int i = 0; i < slotlist.size(); i++) {
+                        serialised << slotlist[i]->slotname << '\n' << slotlist[i]->station_size << '\n' << slotlist[i]->slot << '\n' << slotlist[i]->limit << '\n' << slotlist[i]->cargo_count << '\n';
+                        for (int j = 0; j < slotlist[i]->cargo_count; j++) {
+                                serialised << slotlist[i]->cargo_ids[j] << '\n' << slotlist[i]->cargo_id_weights[j] << '\n';
+                        }
+                        serialised << slotlist[i]->additive_weights << '\n';
+                }
+                char filename_buf[260];
+                seprintf(filename_buf, lastof(filename_buf), "%s%s%i", _personal_dir, "advanced_industry_presets_", active_slot_list);
+                std::ofstream file;
+                file.open(filename_buf);
+                if (file.is_open()) {
+                        file << serialised.rdbuf();
+                        file.flush();
+                        file.close();
+                        saveSlotListNames();
+                }
+                else {
+                        printf("%s\n", filename_buf);
+                        printf("file not opened\n");
+
+                }
+
+        }
+
+        void deleteSlotList() {
+                 int cur_idx = active_slot_list;
+                 slotlist_names.erase(slotlist_names.begin() + cur_idx);
+
+                 char filename_buf[260];
+                 seprintf(filename_buf, lastof(filename_buf), "%s%s%i", _personal_dir, "advanced_industry_presets_", active_slot_list);
+                 if (FileExists(filename_buf)) {
+                         remove(filename_buf);
+                         if (cur_idx <= slotlist_names.size()) {
+                                 for (int i = cur_idx; i <= slotlist_names.size(); i++) {
+                                         char filename_buf_1[260];
+                                         seprintf(filename_buf_1, lastof(filename_buf_1), "%s%s%i", _personal_dir, "advanced_industry_presets_", i + 1);
+                                         char filename_buf_2[260];
+                                         seprintf(filename_buf_2, lastof(filename_buf_2), "%s%s%i", _personal_dir, "advanced_industry_presets_", i);
+                                         rename(filename_buf_1, filename_buf_2);
+
+                                 }
+
+                         }
+                         saveSlotListNames();
+
+                 }
+                 removeAllSlots();
+                 if (slotlist_names.size() > 0) {
+                         active_slot_list = 0;
+                         loadSlotList(0);
+                         changeActiveSlot(0);
+                         SetWidgetDirty(WID_AD_SLOTLIST_NAME);
+
+                 }
+                 else {
+                         BuildSlotInfo();
+
+                 }
+
+         }
+
+         bool isSlotListSaved() {
+                 char filename_buf[260];
+                 seprintf(filename_buf, lastof(filename_buf), "%s%s%i", _personal_dir, "advanced_industry_presets_", active_slot_list);
+                 if (FileExists(filename_buf)) {
+                         return true;
+
+                 }
+                 return false;
+
+         }
+
+         void createNewSlotList() {
+                 if (isSlotListSaved()) {
+                         slotlist_names.push_back(getFreeSlotListName());
+                         active_slot_list = slotlist_names.size() - 1;
+
+                 }
+                 else {
+                         slotlist_names[active_slot_list] = getFreeSlotListName();
+
+                 }
+                 removeAllSlots();
+                 addSlot();
+                 changeActiveSlot(0);
+                 SetWidgetDirty(WID_AD_SLOTLIST_NAME);
+
+         }
+
+         void initAvailableCargoList() {
+                 int count = 0;
+                 for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+                         this->available_cargos[count] = cs->Index();
+                         this->available_cargos_text[count] = cs->name;
+                         count++;
+                 }
+                 this->available_cargos_text[count] = INVALID_STRING_ID;
+         }
+
+         void addSlot() {
+                  SlotInfo* slot_info = MallocT<SlotInfo>(1);
+                  int slotlist_len = slotlist.size();
+                  bool* old_used_cuda_slots = used_cuda_slots;
+                  used_cuda_slots = ReallocT<bool>(old_used_cuda_slots, slotlist_len + 1);
+                  if (used_cuda_slots == NULL) {
+                          error("not enough memory");
+
+                  }
+                  used_cuda_slots[slotlist_len] = false;
+                  int text_index = 0;
+                  slot_info->slotname[text_index++] = 's';
+                  slot_info->slotname[text_index++] = 'l';
+                  slot_info->slotname[text_index++] = 'o';
+                  slot_info->slotname[text_index++] = 't';
+                  slot_info->slotname[text_index++] = ' ';
+                  if (slotlist_len < 10) {
+                          slot_info->slotname[text_index++] = (char)('0' + slotlist_len);
+
+                  }
+                  else {
+                          slot_info->slotname[text_index++] = (char)('0' + (slotlist_len / 10));
+                          slot_info->slotname[text_index++] = (char)('0' + (slotlist_len % 10));
+
+                  }
+                  slot_info->slotname[text_index++] = '\0';
+                  for (int i = 0; i < slotlist_len + 1; i++) {
+                          if (!used_cuda_slots[i]) {
+                                  slot_info->slot = i;
+                                  used_cuda_slots[i] = true;
+                                  break;
+
+                          }
+
+                  }
+                  slot_info->cargo_count = 0;
+                  slot_info->cargo_ids = NULL;
+                  slot_info->cargo_id_weights = NULL;
+                  slot_info->station_size = 7;
+                  slot_info->limit = 20;
+                  slot_info->autorefresh = false;
+                  slot_info->invalid = true;
+                  slot_info->additive_weights = 0;
+                  slotlist.push_back(slot_info);
+                  //*slotlist.Append() = slot_info;
+                  SetWidgetDirty(WID_AD_SLOT_LIST);
+          }
+
+         void removeAllSlots() {
+                 while (slotlist.size() > 0) {
+                         removeSlot(0);
+
+                 }
+
+         }
+
+         void removeSlot(uint pos) {
+                 removeAllCargoFromSlot(pos);
+                 int slot = slotlist[pos]->slot;
+                 int len = slotlist.size();
+                 slotlist.erase(slotlist.begin() + pos);
+                 //slotlist.ErasePreservingOrder(pos);
+                                 //TODO: clear cuda slot and maybe fix used_cuda_slots memory leak
+                 used_cuda_slots[slot] = false;
+
+         }
+
+         void addCargoToSlot(uint pos, int id) {
+                 SlotInfo* slot_info = slotlist[pos];
+                 bool found = false;
+                 for (int i = 0; i < slot_info->cargo_count; i++) {
+                         if (slot_info->cargo_ids[i] == id) {
+                                 found = true;
+                                 break;
+
+                         }
+
+                 }
+                 if (!found) {
+                         int* old_cargo_ids = slot_info->cargo_ids;
+                         slot_info->cargo_ids = ReallocT<int>(old_cargo_ids, slot_info->cargo_count + 1);
+                         if (slot_info->cargo_ids == NULL) {
+                                 error("not enough memory");
+
+                         }
+                         float* old_cargo_id_weights = slot_info->cargo_id_weights;
+                         slot_info->cargo_id_weights = ReallocT<float>(old_cargo_id_weights, slot_info->cargo_count + 1);
+                         if (slot_info->cargo_id_weights == NULL) {
+                                 error("not enough memory");
+
+                         }
+                         slot_info->cargo_ids[slot_info->cargo_count] = id;
+                         slot_info->cargo_id_weights[slot_info->cargo_count] = 1.0;
+                         slot_info->cargo_count++;
+                         this->vscroll_cargo->SetCount(slot_info->cargo_count);
+
+                 }
+
+         }
+
+         void removeCargoFromSlot(uint pos, int id) {
+                 SlotInfo* slot_info = slotlist[pos];
+                 if (slot_info->cargo_count == 1 || id == -1) {
+                         slot_info->cargo_count = 0;
+                         if (slot_info->cargo_ids != NULL) {
+                                 free(slot_info->cargo_ids);
+
+                         }
+                         slot_info->cargo_ids = NULL;
+                         if (slot_info->cargo_id_weights != NULL) {
+                                 free(slot_info->cargo_id_weights);
+
+                         }
+                         slot_info->cargo_id_weights = NULL;
+
+                 }
+                 else {
+                         int j = 0;
+                         for (int i = 0; i < slot_info->cargo_count; i++) {
+                                 if (i == id) continue;
+                                 slot_info->cargo_ids[j] = slot_info->cargo_ids[i];
+                                 slot_info->cargo_id_weights[j] = slot_info->cargo_id_weights[i];
+                                 j++;
+
+                         }
+                         slot_info->cargo_count--;
+                         slot_info->cargo_ids = ReallocT<int>(slot_info->cargo_ids, slot_info->cargo_count);
+                         slot_info->cargo_id_weights = ReallocT<float>(slot_info->cargo_id_weights, slot_info->cargo_count);
+
+                 }
+                 this->vscroll_cargo->SetCount(slot_info->cargo_count);
+
+         }
+
+         void removeAllCargoFromSlot(uint pos) {
+                 removeCargoFromSlot(pos, -1);
+
+         }
+
+         void setCargoWeight(uint pos, int id, float weight) {
+                 SlotInfo* slot_info = slotlist[pos];
+                 for (int i = 0; i < slot_info->cargo_count; i++) {
+                         if (slot_info->cargo_ids[i] == id) {
+                                 slot_info->cargo_id_weights[i] = weight;
+                                 break;
+
+                         }
+
+                 }
+
+         }
+
+         void setStationSize(uint pos, int station_size) {
+                 SlotInfo* slot_info = slotlist[pos];
+                 slot_info->station_size = station_size;
+
+         }
+
+         void setLimit(uint pos, int limit) {
+                 SlotInfo* slot_info = slotlist[pos];
+                 slot_info->limit = limit;
+
+         }
+
+         void BuildSlotInfo() {
+                 if (slotlist.size() == 0) {
+                         slotlist_names.push_back(getFreeSlotListName());
+                         active_slot_list = 0;
+
+                         addSlot();
+                         changeActiveSlot(0);
+                         SetWidgetDirty(WID_AD_SLOTLIST_NAME);
+
+                 }
+
+         }
+
+         /** (Re)Build industries list */
+         void BuildAdvancedIndustriesList()
+         {
+                 production_sources_slots = OpenTTDCuda::OpenTTDCuda::getProductionSourcesSlots();
+                 production_sources_meta = (ProductionSourceMeta*)OpenTTDCuda::OpenTTDCuda::getProductionSourcesMeta();
+
+                 if (production_sources_meta != NULL && production_sources_slots > 0) {
+                         this->vscroll->SetCount(production_sources_meta[active_slot].len);
+
+                 }
+                 this->SetWidgetDirty(WID_AD_INDUSTRY_LIST); // Set the modified widget dirty
+                 this->SetWidgetLoweredState(WID_AD_SEARCH, false);
+                 this->SetWidgetDirty(WID_AD_SEARCH);
+         }
+
+         void changeActiveSlot(uint pos) {
+                 active_slot = pos;
+                 SetWidgetDirty(WID_AD_SLOT_LIST);
+                 SetWidgetDirty(WID_AD_SLOTNAME);
+                 SetWidgetDirty(WID_AD_STATIONSIZE);
+                 SetWidgetDirty(WID_AD_LIMIT);
+                 SetWidgetLoweredState(WID_AD_AUTOREFRESH, slotlist[active_slot]->autorefresh);
+                 SetWidgetDirty(WID_AD_AUTOREFRESH);
+                 SetWidgetLoweredState(WID_AD_ADDITIVEWEIGHT, slotlist[active_slot]->additive_weights == 1);
+                 SetWidgetDirty(WID_AD_ADDITIVEWEIGHT);
+                 SetWidgetDirty(WID_AD_CARGOLIST);
+                 SetWidgetDirty(WID_AD_CARGOSCROLLBAR);
+                 SetWidgetDirty(WID_AD_INDUSTRY_LIST);
+                 SetWidgetDirty(WID_AD_SCROLLBAR);
+                 startAutoRefresh();
+         }
+
+         /**
+          +       * Get the StringID to draw and set the appropriate DParams.
+          +       * @param i the industry to get the StringID of.
+          +       * @return the StringID.
+          +       */
+          StringID GetIndustryString(const ProductionSource* ps) const
+          {
+                  int p = 0;
+                  /* Last month production */
+                  SetDParam(p++, ps->last_month_production);
+                  SetDParam(p++, ps->industry_count);
+
+                  std::vector<int> current_cargo_types;
+
+                  int* cargo_types_current_count = &slotlist[active_slot]->cargo_count;
+                  int* cargo_types_current = slotlist[active_slot]->cargo_ids;
+
+                  int weight_factor = 0;
+                  int is_used = 0;
+                  for (int i = 0; i < ps->industry_count; i++) {
+                          if (Industry::IsValidID(ps->industry_indices[i])) {
+                                  Industry* ind = Industry::Get(ps->industry_indices[i]);
+                                  for (int pc = 0; pc < 2; pc++) {
+                                          for (int ctc = 0; ctc < *cargo_types_current_count; ctc++) {
+                                                  if (ind->produced_cargo[pc] == cargo_types_current[ctc]) {
+                                                          if (ind->last_month_transported[pc] > 0) {
+                                                                  is_used = 1;
+                                                          }
+                                                          if (std::find(current_cargo_types.begin(), current_cargo_types.end(), cargo_types_current[ctc]) == current_cargo_types.end()) {
+                                                                  current_cargo_types.push_back(cargo_types_current[ctc]);
+                                                                  if (slotlist[active_slot]->additive_weights == 1) {
+                                                                          weight_factor += (int)round((slotlist[active_slot]->cargo_id_weights[ctc] * 100));
+                                                                  }
+                                                          }
+                                                  }
+                                          }
+                                  }
+                          }
+                  }
+                  if (slotlist[active_slot]->additive_weights == 0) {
+                          weight_factor = 100;
+                  }
+                  SetDParam(p++, current_cargo_types.size());
+                  SetDParam(p++, weight_factor);
+
+                  /* Drawing the right string */
+                  switch (p) {
+                  case 4:
+                          if (is_used == 0) return STR_AD_IL_ITEM;
+                          if (is_used == 1) return STR_AD_IL_ITEM_USED;
+
+                  default: return STR_INDUSTRY_DIRECTORY_NONE;
+                  }
+          }
+
+public:
+        AdvancedIndustryDirectoryWindow(WindowDesc* desc, WindowNumber number) : Window(desc)
+        {
+                //active_slot_list = 0;
+                this->CreateNestedTree();
+                this->vscroll = this->GetScrollbar(WID_AD_SCROLLBAR);
+                this->vscroll_cargo = this->GetScrollbar(WID_AD_CARGOSCROLLBAR);
+                this->vscroll_cargo->SetCapacity(4);
+                this->initAvailableCargoList();
+                this->initSlotListNames();
+                this->BuildSlotInfo();
+                this->BuildAdvancedIndustriesList();
+
+                this->FinishInitNested(0);
+        }
+
+        ~AdvancedIndustryDirectoryWindow()
+        {
+
+        }
+
+        virtual void DrawWidget(const Rect& r, int widget) const
+        {
+                switch (widget) {
+                case WID_AD_SLOT_LIST: {
+                        if (slot_list_load) {
+                                int y = r.top + WD_FRAMERECT_TOP;
+                                for (uint i = 0; i < slotlist_names.size(); i++) {
+                                        SetDParamStr(0, slotlist_names[i].c_str());
+                                        DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_JUST_RAW_STRING, TC_BLACK, SA_CENTER);
+                                        y += this->resize.step_height + 2;
+
+                                }
+
+                        }
+                        else {
+                                int n = 0;
+                                int y = r.top + WD_FRAMERECT_TOP;
+                                for (uint i = 0; i < slotlist.size(); i++) {
+                                        if (i == active_slot) {
+                                                GfxFillRect(r.left + WD_FRAMERECT_LEFT, y - 1, r.right - WD_FRAMERECT_RIGHT, y + 10, COLOUR_GREY);
+
+                                        }
+                                        SetDParamStr(0, slotlist[i]->slotname);
+                                        DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_JUST_RAW_STRING, TC_BLACK, SA_CENTER);
+                                        y += this->resize.step_height + 2;
+
+                                }
+                                SetDParamStr(0, "+");
+                                DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_JUST_RAW_STRING, TC_BLACK, SA_CENTER);
+
+                        }
+                        break;
+                }
+                case WID_AD_SLOTLIST_NAME: {
+                        SetDParamStr(0, slotlist_names[active_slot_list].c_str());
+                        DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_JUST_RAW_STRING, TC_BLACK, SA_CENTER);
+                        break;
+                }
+                case WID_AD_SLOTNAME: {
+                        DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, slotlist[active_slot]->slotname, TC_BLACK, SA_CENTER);
+                        break;
+                }
+                case WID_AD_STATIONSIZE: {
+                        SetDParam(0, slotlist[active_slot]->station_size);
+                        DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_JUST_INT, TC_BLACK, SA_CENTER);
+                        break;
+                }
+                case WID_AD_LIMIT: {
+                        SetDParam(0, slotlist[active_slot]->limit);
+                        DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_JUST_INT, TC_BLACK, SA_CENTER);
+                        break;
+                }
+                case WID_AD_ADDCARGO: {
+                        SetDParamStr(0, "+");
+                        DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_JUST_RAW_STRING, TC_BLACK, SA_CENTER);
+                        break;
+                }
+                case WID_AD_CARGOLIST: {
+                         int y = r.top + WD_FRAMERECT_TOP;
+                         for (uint i = this->vscroll_cargo->GetPosition(); i < slotlist[active_slot]->cargo_count; i++) {
+                                 StringID strID = STR_JUST_RAW_STRING;
+                                 int found_id = -1;
+                                 if (slotlist[active_slot]->cargo_ids[i] < NUM_CARGO) {
+                                         for (int j = 0; j < NUM_CARGO; j++) {
+                                                 if (available_cargos[j] == slotlist[active_slot]->cargo_ids[i]) {
+                                                         found_id = j;
+                                                         break;
+
+                                                 }
+
+                                         }
+
+                                 }
+                                 if (found_id > -1) {
+                                         strID = available_cargos_text[found_id];
+
+                                 }
+                                 else {
+                                         SetDParamStr(0, "undefined");
+
+                                 }
+                                 DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, strID, TC_BLACK);
+                                 SetDParam(0, ToPercent8((int)(slotlist[active_slot]->cargo_id_weights[i] * 255)));
+                                 DrawString(r.right - WD_FRAMERECT_RIGHT - 100, r.right - WD_FRAMERECT_RIGHT - 60, y, STR_PERFORMANCE_DETAIL_PERCENT, TC_BLACK);
+                                 DrawString(r.right - WD_FRAMERECT_RIGHT - 20, r.right - WD_FRAMERECT_RIGHT, y, "x", TC_BLACK);
+                                 y += this->resize.step_height;
+
+                         }
+                         this->vscroll_cargo->SetCount(slotlist[active_slot]->cargo_count);
+                         break;
+                 }
+                 case WID_AD_INDUSTRY_LIST: {
+                         int n = 0;
+                         int y = r.top + WD_FRAMERECT_TOP;
+                         if (this->production_sources_meta == NULL || this->production_sources_slots == 0 || this->production_sources_meta[slotlist[active_slot]->slot].len == 0) {
+                                 DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_INDUSTRY_DIRECTORY_NONE);
+                                 break;
+
+                         }
+                         for (uint i = this->vscroll->GetPosition(); i < this->production_sources_meta[slotlist[active_slot]->slot].len; i++) {
+                                 DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, this->GetIndustryString(&(production_sources_meta[slotlist[active_slot]->slot].production_source[i])));
+
+                                 y += this->resize.step_height;
+                                 if (++n == this->vscroll->GetCapacity()) break; // max number of industries in 1 window
+
+                         }
+                         break;
+                 }
+
+                 }
+         }
+
+        virtual void UpdateWidgetSize(int widget, Dimension* size, const Dimension& padding, Dimension* fill, Dimension* resize)
+         {
+                 switch (widget) {
+                 case WID_AD_INDUSTRY_LIST: {
+                         Dimension d = GetStringBoundingBox(STR_INDUSTRY_DIRECTORY_NONE);
+                         if (this->production_sources_meta != NULL && this->production_sources_slots > 0) {
+                                 for (uint i = 0; i < this->production_sources_meta[slotlist[active_slot]->slot].len; i++) {
+                                         d = maxdim(d, GetStringBoundingBox(this->GetIndustryString(&(production_sources_meta[slotlist[active_slot]->slot].production_source[i]))));
+
+                                 }
+
+                         }
+                         resize->height = d.height;
+                         d.height *= 5;
+                         d.width += padding.width + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+                         d.height += padding.height + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+                         *size = maxdim(*size, d);
+                         break;
+                 }
+
+                 }
+         }
+        virtual void OnClick(Point pt, int widget, int click_count)
+         {
+                 switch (widget) {
+                 case WID_AD_SLOT_LIST: {
+                         int pnt = (pt.y - this->resize.step_height - 2) / (this->resize.step_height + 2);
+                         if (pnt < 0) {
+                                 pnt = 0;
+
+                         }
+                         uint p = pnt;
+                         if (slot_list_load) {
+                                 if (p < slotlist_names.size()) {
+                                         loadSlotList(p);
+                                         slot_list_load = false;
+                                         SetWidgetLoweredState(WID_AD_LOADSLOTLIST, false);
+                                         SetWidgetDirty(WID_AD_LOADSLOTLIST);
+                                         SetWidgetDirty(WID_AD_SLOTLIST_NAME);
+                                         changeActiveSlot(0);
+
+                                 }
+
+                         }
+                         else {
+                                 if (p < slotlist.size()) {
+                                         changeActiveSlot(p);
+
+                                 }
+                                 if (p == slotlist.size()) {
+                                         addSlot();
+                                         changeActiveSlot(p);
+
+                                 }
+
+                         }
+                         break;
+                 }
+                 case WID_AD_SLOTLIST_NAME: {
+                         _querywindow_current = QUERYWINDOW_SLOTLISTNAME;
+                         SetDParamStr(0, slotlist_names[active_slot_list].c_str());
+                         ShowQueryString(STR_JUST_RAW_STRING, STR_NULL, 20, this, CS_ALPHANUMERAL, QSF_ACCEPT_UNCHANGED);
+                         break;
+                 }
+                 case WID_AD_NEWSLOTLIST: {
+                         createNewSlotList();
+                         break;
+                 }
+                 case WID_AD_DELETESLOTLIST: {
+                         deleteSlotList();
+                         break;
+                 }
+                 case WID_AD_LOADSLOTLIST: {
+                         if (slot_list_load) {
+                                 slot_list_load = false;
+                                 SetWidgetLoweredState(WID_AD_LOADSLOTLIST, false);
+
+                         }
+                         else {
+                                 slot_list_load = true;
+                                 SetWidgetLoweredState(WID_AD_LOADSLOTLIST, true);
+
+                         }
+                         SetWidgetDirty(WID_AD_SLOT_LIST);
+                         SetWidgetDirty(WID_AD_LOADSLOTLIST);
+                         break;
+                 }
+                 case WID_AD_SAVESLOTLIST: {
+                         saveSlotList();
+                         break;
+                 }
+                 case WID_AD_SLOTNAME: {
+                          _querywindow_current = QUERYWINDOW_SLOTNAME;
+                          SetDParamStr(0, slotlist[active_slot]->slotname);
+                          ShowQueryString(STR_JUST_RAW_STRING, STR_AD_QW_SLOTNAME, 20, this, CS_ALPHANUMERAL, QSF_ACCEPT_UNCHANGED);
+                          break;
+                  }
+                  case WID_AD_STATIONSIZE: {
+                          invalidateSlotInfos();
+                          _querywindow_current = QUERYWINDOW_STATIONSIZE;
+                          SetDParam(0, slotlist[active_slot]->station_size);
+                          ShowQueryString(STR_JUST_INT, STR_AD_QW_STATIONSIZE, 20, this, CS_NUMERAL, QSF_ACCEPT_UNCHANGED);
+                          break;
+                  }
+                  case WID_AD_LIMIT: {
+                          invalidateSlotInfos();
+                          _querywindow_current = QUERYWINDOW_LIMIT;
+                          SetDParam(0, slotlist[active_slot]->limit);
+                          ShowQueryString(STR_JUST_INT, STR_AD_QW_LIMIT, 20, this, CS_NUMERAL, QSF_ACCEPT_UNCHANGED);
+                          break;
+                  }
+                  case WID_AD_ADDCARGO: {
+                          invalidateSlotInfos();
+                          ShowDropDownMenu(this, available_cargos_text, 0, WID_AD_ADDCARGO, 0, 0);
+                          break;
+                  }
+                  case WID_AD_AUTOREFRESH: {
+                          slotlist[active_slot]->autorefresh = !slotlist[active_slot]->autorefresh;
+                          SetWidgetLoweredState(WID_AD_AUTOREFRESH, slotlist[active_slot]->autorefresh);
+                          SetWidgetDirty(WID_AD_AUTOREFRESH);
+                          if (slotlist[active_slot]->autorefresh) {
+                                  startAutoRefresh();
+                          }
+                          break;
+                  }
+                  case WID_AD_ADDITIVEWEIGHT: {
+                          if (slotlist[active_slot]->additive_weights == 1) {
+                                  slotlist[active_slot]->additive_weights = 0;
+                          }
+                          else if (slotlist[active_slot]->additive_weights == 0) {
+                                  slotlist[active_slot]->additive_weights = 1;
+                          }
+                          invalidateSlotInfos();
+                          SetWidgetLoweredState(WID_AD_ADDITIVEWEIGHT, slotlist[active_slot]->additive_weights == 1);
+                          SetWidgetDirty(WID_AD_ADDITIVEWEIGHT);
+                          break;
+                  }
+                  case WID_AD_CARGOLIST: {
+                           if (slotlist[active_slot]->cargo_count > 0) {
+                                   int p = (this->vscroll_cargo->GetPosition() * 10 + pt.y - 50) / 10;
+                                   if (p < 0) p = 0;
+                                   if (p < slotlist[active_slot]->cargo_count) {
+                                           if (pt.x > this->width - 40 && pt.x < this->width - 30) {
+                                                   removeCargoFromSlot(active_slot, p);
+                                                   SetWidgetDirty(WID_AD_CARGOLIST);
+
+                                           }
+                                           else if (pt.x > this->width - 120 && pt.x < this->width - 80) {
+                                                   _querywindow_current = QUERYWINDOW_CARGOLIST_BASE + p;
+                                                   SetDParam(0, (int)(slotlist[active_slot]->cargo_id_weights[p] * 100.0));
+                                                   ShowQueryString(STR_JUST_INT, STR_AD_QW_CARGOWEIGHT, 4, this, CS_NUMERAL, QSF_ACCEPT_UNCHANGED);
+
+                                           }
+
+                                   }
+
+                           }
+                           break;
+                   }
+                   case WID_AD_SEARCH: {
+                           SlotInfo* slot_info = slotlist[active_slot];
+                           if (slot_info->cargo_count > 0 && slot_info->station_size >= 0 && slot_info->station_size <= 50 && slot_info->limit > 0) {
+                                   SetWidgetLoweredState(WID_AD_SEARCH, true);
+                                   SetWidgetDirty(WID_AD_SEARCH);
+   #ifdef _WIN32
+                                   if (slot_info->invalid) {
+                                           slot_info->invalid = false;
+                                           CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)startSearchThreadStarter, (LPVOID*)slot_info, 0, 0);
+                                   }
+   #elif __linux__
+                                   pthread_t thread_start_search;
+                                   pthread_create(&thread_start_search, NULL, startSearchThreadStarter, (void*)slot_info);
+   #endif
+
+                           }
+                           break;
+                   }
+                   case WID_AD_INDUSTRY_LIST: {
+                           uint p = this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_AD_INDUSTRY_LIST, WD_FRAMERECT_TOP);
+                           if (this->production_sources_meta != NULL && this->production_sources_slots > 0 && p < this->production_sources_meta[slotlist[active_slot]->slot].len) {
+                                   if (_ctrl_pressed) {
+                                           //ShowExtraViewPortWindow(this->production_sources_meta[slotlist[active_slot]->slot].production_source[p].center);
+                                           for (int ic = 0; ic < this->production_sources_meta[slotlist[active_slot]->slot].production_source[p].industry_count; ic++) {
+                                                   //ShowExtraViewPortWindow(Industry::Get(this->production_sources_meta[slotlist[active_slot]->slot].production_source[p].industry_indices[ic])->location.tile);
+                                                   ShowIndustryViewWindow(this->production_sources_meta[slotlist[active_slot]->slot].production_source[p].industry_indices[ic]);
+                                           }
+                                   }
+                                   else {
+                                           ScrollMainWindowToTile(this->production_sources_meta[slotlist[active_slot]->slot].production_source[p].center);
+                                   }
+
+                           }
+                           break;
+                   }
+
+                   }
+         }
+
+          virtual void OnQueryTextFinished(char* str)
+          {
+                  switch (_querywindow_current) {
+                  case QUERYWINDOW_SLOTLISTNAME: {
+                          if (str != NULL) {
+                                  std::string name = str;
+                                  bool found = false;
+                                  for (int i = 0; i < slotlist_names.size(); i++) {
+                                          if (slotlist_names[i] == name) {
+                                                  found = true;
+                                                  break;
+
+                                          }
+
+                                  }
+                                  if (!found) {
+                                          slotlist_names[active_slot_list] = name;
+                                          SetWidgetDirty(WID_AD_SLOTLIST_NAME);
+
+                                  }
+
+                          }
+                          break;
+                  }
+                  case QUERYWINDOW_SLOTNAME: {
+                          if (str != NULL) {
+                                  SlotInfo* slot_info = slotlist[active_slot];
+                                  for (int i = 0; i < 20; i++) {
+                                          slot_info->slotname[i] = str[i];
+
+                                  }
+
+                          }
+                          this->SetWidgetDirty(WID_AD_SLOTNAME);
+                          this->SetWidgetDirty(WID_AD_SLOT_LIST);
+                          break;
+                  }
+                  case QUERYWINDOW_STATIONSIZE: {
+                          if (str != NULL) {
+                                  SlotInfo* slot_info = slotlist[active_slot];
+                                  int station_size = std::stoi(str);
+                                  if (station_size <= 50 && station_size >= 0) {
+                                          slot_info->station_size = station_size;
+
+                                  }
+
+                          }
+                          this->SetWidgetDirty(WID_AD_STATIONSIZE);
+                          break;
+                  }
+                  case QUERYWINDOW_LIMIT: {
+                          if (str != NULL) {
+                                  SlotInfo* slot_info = slotlist[active_slot];
+                                  int limit = std::stoi(str);
+                                  if (limit >= 0) {
+                                          slot_info->limit = limit;
+
+                                  }
+
+                          }
+                          this->SetWidgetDirty(WID_AD_LIMIT);
+                          break;
+                  }
+                  default: {
+                          if (_querywindow_current >= QUERYWINDOW_CARGOLIST_BASE && _querywindow_current < QUERYWINDOW_CARGOLIST_BASE + slotlist[active_slot]->cargo_count) {
+                                  int value = std::stoi(str);
+                                  if (value <= 100) {
+                                          slotlist[active_slot]->cargo_id_weights[_querywindow_current - QUERYWINDOW_CARGOLIST_BASE] = ((float)(value) / 100.0);
+                                          this->SetWidgetDirty(WID_AD_CARGOLIST);
+
+                                  }
+
+                          }
+                          break;
+                  }
+                  }
+                }
+
+                virtual void OnDropdownSelect(int widget, int index)
+                {
+                        switch (widget) {
+                        case WID_AD_ADDCARGO: {
+                                if (index < NUM_CARGO) {
+                                        addCargoToSlot(active_slot, available_cargos[index]);
+
+                                }
+                                break;
+                        }
+
+                        }
+                        this->SetDirty();
+                }
+
+                virtual void OnResize()
+                {
+                        this->vscroll->SetCapacityFromWidget(this, WID_AD_INDUSTRY_LIST);
+                }
+
+                virtual void OnPaint()
+                {
+                        this->DrawWidgets();
+                }
+
+                virtual void OnHundredthTick()
+                {
+                        this->BuildAdvancedIndustriesList();
+                }
+
+                /**
+                +       * Some data on this window has become invalid.
+                +       * @param data Information about the changed data.
+                +       * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+                +       */
+                virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+                {
+                        if (data == 0) {
+                                /* This needs to be done in command-scope to enforce rebuilding before resorting invalid data */
+                                        //this->industries.ForceRebuild();
+
+                        }
+                        else {
+                                //this->industries.ForceResort();
+
+                        }
+                }
+
+        };
+
+/** Window definition of the advanced industry directory gui */
+static WindowDesc _advanced_industry_directory_desc(
+        WDP_AUTO, "advanced_list_industries", 428, 190,
+        WC_ADVANCED_INDUSTRY_DIRECTORY, WC_NONE,
+        0,
+        _nested_advanced_industry_directory_widgets, lengthof(_nested_advanced_industry_directory_widgets)
+);
+
+void ShowAdvancedIndustryDirectory()
+{
+        AllocateWindowDescFront<AdvancedIndustryDirectoryWindow>(&_advanced_industry_directory_desc, 0);
+}
+
 void ShowIndustryDirectory()
 {
+	AllocateWindowDescFront<AdvancedIndustryDirectoryWindow>(&_advanced_industry_directory_desc, 0);
 	AllocateWindowDescFront<IndustryDirectoryWindow>(&_industry_directory_desc, 0);
 }
 
+
 /** Widgets of the industry cargoes window. */
 static const NWidgetPart _nested_industry_cargoes_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
diff --git a/src/intro_gui.cpp b/src/intro_gui.cpp
index fe19ec063..d20b82f20 100644
--- a/src/intro_gui.cpp
+++ b/src/intro_gui.cpp
@@ -15,6 +15,7 @@
 #include "textbuf_gui.h"
 #include "network/network.h"
 #include "genworld.h"
+#include "network/network_func.h"
 #include "network/network_gui.h"
 #include "network/network_content.h"
 #include "landscape_type.h"
@@ -27,6 +28,7 @@
 #include "language.h"
 #include "rev.h"
 #include "highscore.h"
+#include "3rdparty/md5/md5.h"
 #include "signs_base.h"
 #include "viewport_func.h"
 #include "vehicle_base.h"
@@ -37,8 +39,17 @@
 #include "table/strings.h"
 #include "table/sprites.h"
 
+#include "window_func.h" //ClosewindowbyID
+#include "console_func.h" //IConsolePrint
+#include "settings_func.h" //saveconfig
+#include "base64.h"
+
 #include "safeguards.h"
 
+std::string _server_list_text_names;
+
+void ShowSelectGameWindow();
+extern void OSOpenBrowser(const char *url);
 
 /**
  * A viewport command for the main menu background (intro game).
@@ -173,6 +184,8 @@ struct SelectGameWindow : public Window {
 		}
 	}
 
+  SelectGameQuery query_widget;
+
 	SelectGameWindow(WindowDesc *desc) : Window(desc)
 	{
 		this->CreateNestedTree();
@@ -185,6 +198,8 @@ struct SelectGameWindow : public Window {
 		this->cur_viewport_command_time = 0;
 		this->mouse_idle_time = 0;
 		this->mouse_idle_pos = _cursor.pos;
+
+		GetCommunityServerListText();
 	}
 
 	void OnRealtimeTick(uint delta_ms) override
@@ -256,6 +271,60 @@ struct SelectGameWindow : public Window {
 		if (intro_viewport_commands.size() == 1 && vc.vehicle == INVALID_VEHICLE) intro_viewport_commands.clear();
 	}
 
+
+  void OnQueryTextFinished(char *str) {
+		if (str == NULL) return;
+
+    int comm = _settings_client.gui.community; //chosen community
+		switch (query_widget) {
+			case SGQ_CC_USER:
+				if (Utf8StringLength(str) >= NETWORK_NAME_LENGTH) break;
+				if(comm > 0 && comm <= 2){
+					_settings_client.network.community_user[comm-1] = str;
+				}
+				//strecpy(_settings_client.network.client_name, str, lastof(_settings_client.network.client_name));
+				SaveToConfig();
+				this->SetDirty();
+				break;
+
+			case SGQ_CC_PASSWORD:{
+				if (Utf8StringLength(str) >= NETWORK_PASSWORD_LENGTH) break;
+				const char *np;
+                if (comm == 1) {
+                    Md5 password,salted_password;
+                    password.Append(str, strlen(str));
+                    uint8 digest[16];
+                    char hex_output[16*2 + 1];
+                    password.Finish(digest);
+                    for (int di = 0; di < 16; ++di)
+                    {
+                        seprintf( hex_output + di * 2, lastof(hex_output), "%02x", digest[di]);
+                    }
+                    char tobe_salted[4+16*2+6+1] = {0};
+                    strecat(tobe_salted, "nice", lastof(tobe_salted));
+                    strecat(tobe_salted+4, hex_output, lastof(tobe_salted));
+                    strecat(tobe_salted+4+16*2, "client", lastof(tobe_salted));
+                    assert(strlen(tobe_salted) == (sizeof(tobe_salted)-1));
+                    salted_password.Append(tobe_salted, strlen(tobe_salted));
+                    salted_password.Finish(digest);
+                    for (int di = 0; di < 16; ++di)
+                    {
+                        seprintf( hex_output + di * 2, lastof(hex_output), "%02x", digest[di]);
+                    }
+					_settings_client.network.community_password[comm-1] = hex_output;
+                } else {
+					std::string s = str;
+					std::string encoded = base64_encode(reinterpret_cast<const unsigned char*>(s.c_str()), s.length());
+                    np = encoded.c_str();
+
+					_settings_client.network.community_password[comm-1] = np;
+                }
+				SaveToConfig();
+				break;
+			}
+			default: NOT_REACHED();
+		}
+	}
 	/**
 	 * Some data on this window has become invalid.
 	 * @param data Information about the changed data.
@@ -277,10 +346,29 @@ struct SelectGameWindow : public Window {
 
 		bool missing_lang = _current_language->missing >= _settings_client.gui.missing_strings_threshold && !IsReleasedVersion();
 		this->GetWidget<NWidgetStacked>(WID_SGI_TRANSLATION_SELECTION)->SetDisplayedPlane(missing_lang ? 0 : SZSP_NONE);
+		if(_settings_client.gui.community == 1){
+			this->GetWidget<NWidgetCore>(WID_SGI_CC_SELECT_NICE)->colour = COLOUR_YELLOW;
+			this->DisableWidget(WID_SGI_SERVER_VIP); //disable VIP-button for n-ice
+		}
+		else if(_settings_client.gui.community == 2) this->GetWidget<NWidgetCore>(WID_SGI_CC_SELECT_BTPRO)->colour = COLOUR_YELLOW;
+		else{
+			this->DisableWidget(WID_SGI_CC_PASSWORD);
+			this->DisableWidget(WID_SGI_CC_USER_ENTER);
+			this->DisableWidget(WID_SGI_WEBSITE);
+			this->DisableWidget(WID_SGI_SERVERS_FORUM);
+			this->DisableWidget(WID_SGI_IRC_CHAT);
+			this->DisableWidget(WID_SGI_IRC_SERVERS_CHAT);
+			this->DisableWidget(WID_SGI_SERVER_RULES);
+			this->DisableWidget(WID_SGI_SERVER_WIKI);
+			this->DisableWidget(WID_SGI_SERVER_VIP);
+		}
 	}
 
 	void DrawWidget(const Rect &r, int widget) const override
 	{
+    char* _cc_name; //server name - for the button
+    char name[16];
+    char sn[64];
 		switch (widget) {
 			case WID_SGI_BASESET:
 				SetDParam(0, _missing_extra_graphics);
@@ -291,6 +379,28 @@ struct SelectGameWindow : public Window {
 				SetDParam(0, _current_language->missing);
 				DrawStringMultiLine(r.left, r.right, r.top,  r.bottom, STR_INTRO_TRANSLATION, TC_FROMSTRING, SA_CENTER);
 				break;
+
+			case WID_SGI_SERVERS:
+				//DrawString(r.left, r.right, r.top + 40, STR_CC_SERVER_FREELANCER, TC_FROMSTRING, SA_CENTER);
+				DrawStringMultiLine(r.left, r.right, r.top,  r.bottom, STR_CC_SERVER_FREELANCER, TC_FROMSTRING, SA_CENTER);
+				break;
+			default:
+				if(widget >= WID_SGI_CC1){
+					if(widget - WID_SGI_CC1 + 1 < 10){
+						seprintf(name, lastof(name), "NAME0%i", widget - WID_SGI_CC1 + 1);
+					}
+					else {
+						seprintf(name, lastof(name), "NAME%i", widget - WID_SGI_CC1 + 1);
+					}
+					size_t posname = _server_list_text_names.find(name);
+					std::string sname = _server_list_text_names.substr(posname + 8, _server_list_text_names.find(";", posname + 8) - posname - 8);
+					strecpy(sn, sname.c_str(), lastof(sn));
+					_cc_name = sn;
+
+					SetDParamStr(0, _cc_name);
+					DrawString(r.left, r.right, r.top + 3, STR_NETWORK_DIRECT_JOIN_GAME, TC_FROMSTRING, SA_CENTER);
+				}
+				break;
 		}
 	}
 
@@ -323,6 +433,23 @@ struct SelectGameWindow : public Window {
 		}
 	}
 
+	void SetStringParameters(int widget) const override
+	{
+		switch(widget){
+			case WID_SGI_CC_USER:
+        if (_settings_client.gui.community != 0) {
+          SetDParamStr(0, _settings_client.network.community_user[_settings_client.gui.community-1]);
+        } else {
+          SetDParamStr(0, " ");
+        }
+				break;
+
+			case WID_SGI_CC_HEADER:
+				SetDParam(0, STR_NETWORK_SERVER_LIST_CC_DEFAULT + (uint16)_settings_client.gui.community);
+				break;
+		}
+	}
+
 	void OnClick(Point pt, int widget, int click_count) override
 	{
 		/* Do not create a network server when you (just) have closed one of the game
@@ -369,10 +496,138 @@ struct SelectGameWindow : public Window {
 				break;
 			case WID_SGI_AI_SETTINGS:     ShowAIConfigWindow(); break;
 			case WID_SGI_EXIT:            HandleExitGameRequest(); break;
+
+			//community stuff
+			case WID_SGI_CC_SELECT_NICE:
+				_settings_client.gui.community = _settings_client.gui.community != 1 ? 1 : 0;
+				IConsolePrint(CC_DEFAULT, "icomm: '{}'", _settings_client.gui.community);
+				GetCommunityServerListText();
+				CloseWindowByClass(WC_SELECT_GAME);
+				ShowSelectGameWindow();
+				break;
+			case WID_SGI_CC_SELECT_BTPRO:
+				_settings_client.gui.community = _settings_client.gui.community != 2 ? 2 : 0;
+				IConsolePrint(CC_DEFAULT, "icomm: '{}'", _settings_client.gui.community);
+				GetCommunityServerListText();
+				CloseWindowByClass(WC_SELECT_GAME);
+				ShowSelectGameWindow();
+				break;
+			case WID_SGI_WEBSITE:
+				if(_settings_client.gui.community == 1) OSOpenBrowser("http://www.n-ice.org");
+				else if(_settings_client.gui.community == 2) OSOpenBrowser("https://openttd.btpro.nl");
+				break;
+			case WID_SGI_SERVERS_FORUM:
+				if(_settings_client.gui.community == 1) OSOpenBrowser("http://www.n-ice.org/openttd/forum/index.php");
+				else if(_settings_client.gui.community == 2) OSOpenBrowser("https://openttd.btpro.nl/index.php/forum/recent");
+				break;
+			case WID_SGI_IRC_CHAT:
+				if(_settings_client.gui.community == 1) OSOpenBrowser("https://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2FOpenTTD.Chat");
+				else if(_settings_client.gui.community == 2) OSOpenBrowser("https://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2Fbtpro-chat");
+				break;
+			case WID_SGI_IRC_SERVERS_CHAT:
+				if(_settings_client.gui.community == 1) OSOpenBrowser("https://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2FOpenTTD");
+				else if(_settings_client.gui.community == 2) OSOpenBrowser("https://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2Fbtpro-openttd");
+				break;
+			case WID_SGI_SERVER_RULES:
+				if(_settings_client.gui.community == 1) OSOpenBrowser("http://n-ice.org/openttd/rules.php");
+				else if(_settings_client.gui.community == 2) OSOpenBrowser("https://openttd.btpro.nl/index.php/forum/11-server-rules/10-server-rules");
+				break;
+			case WID_SGI_SERVER_WIKI:
+				if(_settings_client.gui.community == 1) OSOpenBrowser("https://wiki.x-base.info/OpenTTD/Rules");
+				else if(_settings_client.gui.community == 2) OSOpenBrowser("https://openttd.btpro.nl/wiki/index.php/Main_Page");
+				break;
+			case WID_SGI_SERVER_VIP:
+				if(_settings_client.gui.community == 2) OSOpenBrowser("https://openttd.btpro.nl/contact-us/vip-membership");
+				else this->DisableWidget(widget);
+				break;
+			case WID_SGI_CC_USER_ENTER: // Enter User name
+				this->query_widget = SGQ_CC_USER;
+				SetDParamStr(0, _settings_client.network.community_user[_settings_client.gui.community-1]);
+				ShowQueryString(STR_CC_USER_WHITE, STR_CC_USER_ENTER, 40, this, CS_ALPHANUMERAL, QSF_NONE);
+				break;
+			case WID_SGI_CC_PASSWORD: // Enter user Password
+				this->query_widget = SGQ_CC_PASSWORD;
+				ShowQueryString(STR_EMPTY, STR_CC_PASSWORD_ENTER, 40, this, CS_ALPHANUMERAL, QSF_NONE);
+				break;
+			// directly to server #number
+			default:
+				if(widget >= WID_SGI_CC1){
+					if (GetCommunityServer(widget - WID_SGI_CC1 + 1)) {
+						if (_ctrl_pressed) {
+							NetworkClientConnectGame(fmt::format("{}:{}", _cc_address, _cc_porti), COMPANY_NEW_COMPANY);
+						} else {
+							NetworkClientConnectGame(fmt::format("{}:{}", _cc_address, _cc_porti), COMPANY_SPECTATOR);
+						}
+                        delete _cc_address;
+					}
+				} else {
+					ShowErrorMessage(STR_CC_SERVER_DISABLED, INVALID_STRING_ID, WL_ERROR);
+				}
+				break;
 		}
 	}
 };
 
+NWidgetBase *MakeServerButtons(int *biggest_index)
+{
+	NWidgetVertical *ver = new NWidgetVertical;
+    _server_list_text_names = _server_list_text;
+	if(_settings_client.gui.community == 0 || _server_list_text.empty()){
+		NWidgetBackground *leaf = new NWidgetBackground(WWT_PANEL, COLOUR_BROWN, WID_SGI_SERVERS, NULL);
+		ver->Add(leaf);
+		return ver;
+	}
+
+	/* check for disabled server from serverlist file */
+	int active = 0, aactive[50], s_max = 0;
+	if (_settings_client.gui.community == 1) s_max = 50; //for n-ice
+	if (_settings_client.gui.community == 2) s_max = 30; //for btpro
+	for (int i = 0; i < s_max; i++) {
+        aactive[i] = GetCommunityServer(i + 1, true) ? (i + 1) : 0; //server disabled?
+        active++;
+    }
+
+	NWidgetHorizontal *hor = new NWidgetHorizontal;
+	int i1 = 0, i2 = 0;
+	for (int i = 0; i < s_max; i++) {
+		if ((aactive[i] == 0) && (_settings_client.gui.community == 1)) continue; //hide button if disabled - for n-ice only
+		i2++;
+		if ((i1 == 5) || (i1 == 10) || (i1 == 15) || (i1 == 20) || (i1 == 25) || (i1 == 30) || (i1 == 35) || (i1 == 40) || (i1 == 45) || (i1 == 50)) {
+			i2=0;
+			NWidgetSpacer *spce = new NWidgetSpacer(8, 0);
+			spce->SetFill(1, 0);
+			hor->Add(spce);
+			ver->Add(hor);
+			NWidgetSpacer *spc = new NWidgetSpacer(0, 4);
+			spc->SetFill(1, 0);
+			ver->Add(spc);
+			hor = new NWidgetHorizontal();
+		}
+		NWidgetSpacer *spce = new NWidgetSpacer(3, 0);
+		spce->SetFill(1, 0);
+		hor->Add(spce);
+		NWidgetBackground *leaf = new NWidgetBackground(WWT_PANEL, COLOUR_ORANGE, WID_SGI_CC1 + i, NULL);
+		if(aactive[i] == 0) leaf->SetDisabled(true);
+		leaf->SetDataTip(STR_NETWORK_DIRECT_JOIN_GAME, STR_NETWORK_DIRECT_JOIN_GAME_TOOLTIP);
+		leaf->SetMinimalSize(90, 15);
+		hor->Add(leaf);
+		i1++;
+	}
+
+	/* arrange buttons @ last line */
+	if (i2==0) i2=380;
+	if (i2==1) i2=287;
+	if (i2==2) i2=194;
+	if (i2==3) i2=101;
+	if (i2==4) i2=8;
+	NWidgetSpacer *spce = new NWidgetSpacer(i2, 0);
+	spce->SetFill(1, 0);
+	hor->Add(spce);
+	ver->Add(hor);
+	*biggest_index = WID_SGI_CC1 - 1 + active;
+	return ver;
+}
+
 static const NWidgetPart _nested_select_game_widgets[] = {
 	NWidget(WWT_CAPTION, COLOUR_BROWN), SetDataTip(STR_INTRO_CAPTION, STR_NULL),
 	NWidget(WWT_PANEL, COLOUR_BROWN),
@@ -478,6 +733,67 @@ static const NWidgetPart _nested_select_game_widgets[] = {
 	NWidget(NWID_SPACER), SetMinimalSize(0, 8),
 
 	EndContainer(),
+
+	// community servers
+	NWidget(WWT_CAPTION, COLOUR_BROWN, WID_SGI_CC_HEADER), SetDataTip(STR_NETWORK_SERVER_LIST_CC_HEADER, STR_CC_SERVERS_TOOLTIP),
+	NWidget(WWT_PANEL, COLOUR_BROWN),
+	NWidget(NWID_SPACER), SetMinimalSize(0, 3),
+	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(20, 12), SetDataTip(STR_CC_USER_TEXT, STR_NULL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_SGI_CC_USER_ENTER), SetMinimalSize(15, 12), SetDataTip(STR_CC_USER_CHANGE, STR_CC_USER_CHANGE_TOOLTIP),
+		NWidget(NWID_SPACER), SetMinimalSize(3, 0),
+		NWidget(WWT_TEXT, COLOUR_ORANGE, WID_SGI_CC_USER), SetMinimalSize(160, 12), SetDataTip(STR_CC_USER_WHITE, STR_NULL),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(20, 12), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(20, 12), SetDataTip(STR_CC_PASSWORD, STR_NULL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_SGI_CC_PASSWORD), SetMinimalSize(15, 12), SetDataTip(STR_CC_PASSWORD_CHANGE, STR_CC_PASSWORD_CHANGE_TOOLTIP),
+		NWidget(NWID_SPACER), SetMinimalSize(175, 0),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(20, 12), SetDataTip(STR_CC_BUILD, STR_NULL),
+		NWidget(NWID_SPACER), SetMinimalSize(3, 0),
+	EndContainer(),
+	NWidget(NWID_SPACER), SetMinimalSize(0, 6),
+	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_WEBSITE), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE, STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE_TOOLTIP),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SGI_CC_SELECT_NICE), SetMinimalSize(235, 15), SetDataTip(STR_NETWORK_CC_SELECT_NICE, STR_NETWORK_CC_SELECT_NICE_TOOLTIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SGI_CC_SELECT_BTPRO), SetMinimalSize(235, 15), SetDataTip(STR_NETWORK_CC_SELECT_BTPRO, STR_NETWORK_CC_SELECT_BTPRO_TOOLTIP),
+			NWidget(NWID_SPACER), SetMinimalSize(5, 0),
+	EndContainer(),
+	NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+		NWidget(NWID_VERTICAL, NC_EQUALSIZE), SetFill(1, 0),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_SERVERS_FORUM), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS, STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_IRC_CHAT), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_CHAT, STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_CHAT_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_IRC_SERVERS_CHAT), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_SERVERS_CHAT, STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_SERVERS_CHAT_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_SERVER_RULES), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_RULES, STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_RULES_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_SERVER_WIKI), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_WIKI, STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_WIKI_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_SERVER_VIP), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_VIP, STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_VIP_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+		EndContainer(),
+		NWidgetFunction(MakeServerButtons),
+	EndContainer(),
+	NWidget(NWID_SPACER), SetMinimalSize(0, 6),
 };
 
 static WindowDesc _select_game_desc(
diff --git a/src/lang/english.txt b/src/lang/english.txt
index 49497a00c..f1183401a 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -277,6 +277,7 @@ STR_MEASURE_LENGTH                                              :{BLACK}Length:
 STR_MEASURE_AREA                                                :{BLACK}Area: {NUM} x {NUM}
 STR_MEASURE_LENGTH_HEIGHTDIFF                                   :{BLACK}Length: {NUM}{}Height difference: {HEIGHT}
 STR_MEASURE_AREA_HEIGHTDIFF                                     :{BLACK}Area: {NUM} x {NUM}{}Height difference: {HEIGHT}
+STR_MEASURE_DIST_HEIGHTDIFF                                     :{BLACK}Manhattan Distance: {NUM}{}Bird Fly Distance: {NUM}{}Distance from the nearest edge: {NUM}{}Height from sea level: {HEIGHT}{}Height difference: {HEIGHT}
 
 
 # These are used in buttons
@@ -340,6 +341,7 @@ STR_TOOLBAR_TOOLTIP_DISPLAY_TOWN_DIRECTORY                      :{BLACK}Display
 STR_TOOLBAR_TOOLTIP_DISPLAY_SUBSIDIES                           :{BLACK}Display subsidies
 STR_TOOLBAR_TOOLTIP_DISPLAY_LIST_OF_COMPANY_STATIONS            :{BLACK}Display list of company's stations
 STR_TOOLBAR_TOOLTIP_DISPLAY_COMPANY_FINANCES                    :{BLACK}Display company finances information
+STR_TOOLBAR_TOOLTIP_DISPLAY_COMPANY_CARGOS                      :{BLACK}Display company cargos information
 STR_TOOLBAR_TOOLTIP_DISPLAY_COMPANY_GENERAL                     :{BLACK}Display general company information
 STR_TOOLBAR_TOOLTIP_DISPLAY_STORY_BOOK                          :{BLACK}Display story book
 STR_TOOLBAR_TOOLTIP_DISPLAY_GOALS_LIST                          :{BLACK}Display goal list
@@ -397,6 +399,7 @@ STR_SETTINGS_MENU_CONFIG_SETTINGS_TREE                          :Settings
 STR_SETTINGS_MENU_SCRIPT_SETTINGS                               :AI/Game script settings
 STR_SETTINGS_MENU_NEWGRF_SETTINGS                               :NewGRF settings
 STR_SETTINGS_MENU_TRANSPARENCY_OPTIONS                          :Transparency options
+STR_SETTINGS_MENU_ZONING                                        :Zoning
 STR_SETTINGS_MENU_TOWN_NAMES_DISPLAYED                          :Town names displayed
 STR_SETTINGS_MENU_STATION_NAMES_DISPLAYED                       :Station names displayed
 STR_SETTINGS_MENU_WAYPOINTS_DISPLAYED                           :Waypoint names displayed
@@ -421,6 +424,7 @@ STR_MAP_MENU_MAP_OF_WORLD                                       :Map of world
 STR_MAP_MENU_EXTRA_VIEWPORT                                     :Extra viewport
 STR_MAP_MENU_LINGRAPH_LEGEND                                    :Cargo Flow Legend
 STR_MAP_MENU_SIGN_LIST                                          :Sign list
+STR_MAP_MENU_WATCH_COMPANY                                      :Watch Company
 
 # Town menu
 ###length 2
@@ -2030,6 +2034,26 @@ STR_CONFIG_SETTING_PATHFINDER_YAPF_RECOMMENDED                  :YAPF {BLUE}(Rec
 
 STR_CONFIG_SETTING_QUERY_CAPTION                                :{WHITE}Change setting value
 
+STR_CONFIG_SETTING_VEHICLES_CTRL                                :{ORANGE}Controls & Orders
+STR_CONFIG_SETTING_ORDER_SHORTCUTS                              :{ORANGE}Order's Shortcuts
+STR_CONFIG_SETTING_CTRL_ENABLE_CTRLCLICK_STARTSTOP              :Allow ctrl+left-click vehicles to start or stop them: {STRING2}
+STR_CONFIG_SETTING_AUTOSET_NOLOAD_ON_TRANSFER                   :"Transfer" orders are "No Loading" by default: {STRING2}
+STR_CONFIG_SETTING_AUTOSET_NOLOAD_ON_UNLOAD                     :"Unload all" orders are "No Loading" by default: {STRING2}
+
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLLCLICK                 :ctrl+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLSHIFTLCLICK            :ctrl+shift+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_SHIFTLCLICK                :shift+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_ALTLCLICK                  :alt+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_ALTSHIFTCLICK              :alt+shift+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLALTLCLICK              :ctrl+alt+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE                      :do nothing
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_FULL_LOAD_ANY             :Full load any cargo
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_TRANSFER_CARGO            :Transfer cargo
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_UNLOAD_ALL                :Force unload of all cargo
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_FEEDERLOAD                :Feeder Load (replace first order)
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_FEEDERDROP                :Feeder Unload (replace last order)
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NO_LOAD                   :Do not load any cargo
+
 # Config errors
 STR_CONFIG_ERROR                                                :{WHITE}Error with the configuration file...
 STR_CONFIG_ERROR_ARRAY                                          :{WHITE}... error in array '{RAW_STRING}'
@@ -2360,6 +2384,7 @@ STR_NETWORK_CLIENT_LIST_NEW_COMPANY_TOOLTIP                     :{BLACK}Create a
 STR_NETWORK_CLIENT_LIST_PLAYER_ICON_SELF_TOOLTIP                :{BLACK}This is you
 STR_NETWORK_CLIENT_LIST_PLAYER_ICON_HOST_TOOLTIP                :{BLACK}This is the host of the game
 STR_NETWORK_CLIENT_LIST_CLIENT_COMPANY_COUNT                    :{BLACK}{NUM} client{P "" s} / {NUM} compan{P y ies}
+STR_NETWORK_CLIENT_LIST_GET_TOKEN                               :{LTBLUE}Token Login
 
 # Matches ConnectionType
 ###length 5
@@ -2592,6 +2617,7 @@ STR_TRANSPARENT_BRIDGES_TOOLTIP                                 :{BLACK}Toggle t
 STR_TRANSPARENT_STRUCTURES_TOOLTIP                              :{BLACK}Toggle transparency for structures like lighthouses and antennas. Ctrl+Click to lock
 STR_TRANSPARENT_CATENARY_TOOLTIP                                :{BLACK}Toggle transparency for catenary. Ctrl+Click to lock
 STR_TRANSPARENT_LOADING_TOOLTIP                                 :{BLACK}Toggle transparency for loading indicators. Ctrl+Click to lock
+STR_TRANSPARENT_TUNNELS_TOOLTIP                                 :{BLACK}Toggle transparency for vehicles in tunnels. Ctrl+Click to lock.
 STR_TRANSPARENT_INVISIBLE_TOOLTIP                               :{BLACK}Set objects invisible instead of transparent
 
 # Linkgraph legend window
@@ -2633,6 +2659,7 @@ STR_RAIL_TOOLBAR_MAGLEV_CONSTRUCTION_CAPTION                    :Maglev Construc
 
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_RAILROAD_TRACK                   :{BLACK}Build railway track. Ctrl toggles build/remove for railway construction. Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_AUTORAIL                         :{BLACK}Build railway track using the Autorail mode. Ctrl toggles build/remove for railway construction. Shift toggles building/showing cost estimate
+STR_RAIL_TOOLBAR_TOOLTIP_BUILD_POLYRAIL                         :{BLACK}Build railway track using the Polyline mode. Ctrl toggles build/remove for railway construction. Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_TRAIN_DEPOT_FOR_BUILDING         :{BLACK}Build train depot (for buying and servicing trains). Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_CONVERT_RAIL_TO_WAYPOINT               :{BLACK}Convert rail to waypoint. Ctrl enables joining waypoints. Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_RAILROAD_STATION                 :{BLACK}Build railway station. Ctrl enables joining stations. Shift toggles building/showing cost estimate
@@ -2650,6 +2677,7 @@ STR_RAIL_NAME_MAGLEV                                            :Maglev
 # Rail depot construction window
 STR_BUILD_DEPOT_TRAIN_ORIENTATION_CAPTION                       :{WHITE}Train Depot Orientation
 STR_BUILD_DEPOT_TRAIN_ORIENTATION_TOOLTIP                       :{BLACK}Select railway depot orientation
+STR_BUILD_DEPOT_TRAIN_ORIENTATION_AUTO_TOOLTIP                  :{BLACK}Automatically select railway depot orientation based on environment
 
 # Rail waypoint construction window
 STR_WAYPOINT_CAPTION                                            :{WHITE}Waypoint
@@ -2658,6 +2686,8 @@ STR_WAYPOINT_GRAPHICS_TOOLTIP                                   :{BLACK}Select w
 # Rail station construction window
 STR_STATION_BUILD_RAIL_CAPTION                                  :{WHITE}Rail Station Selection
 STR_STATION_BUILD_ORIENTATION                                   :{BLACK}Orientation
+STR_STATION_BUILD_ORIENTATION_AUTO                              :{BLACK}Auto
+STR_STATION_BUILD_ORIENTATION_AUTO_TOOLTIP                      :{BLACK}Automatically select station orientation based on environment
 STR_STATION_BUILD_RAILROAD_ORIENTATION_TOOLTIP                  :{BLACK}Select railway station orientation
 STR_STATION_BUILD_NUMBER_OF_TRACKS                              :{BLACK}Number of tracks
 STR_STATION_BUILD_NUMBER_OF_TRACKS_TOOLTIP                      :{BLACK}Select number of platforms for railway station
@@ -2739,6 +2769,7 @@ STR_BUILD_DEPOT_ROAD_ORIENTATION_CAPTION                        :{WHITE}Road Dep
 STR_BUILD_DEPOT_ROAD_ORIENTATION_SELECT_TOOLTIP                 :{BLACK}Select road vehicle depot orientation
 STR_BUILD_DEPOT_TRAM_ORIENTATION_CAPTION                        :{WHITE}Tram Depot Orientation
 STR_BUILD_DEPOT_TRAM_ORIENTATION_SELECT_TOOLTIP                 :{BLACK}Select tram vehicle depot orientation
+STR_BUILD_DEPOT_ROAD_ORIENTATION_AUTO_TOOLTIP                   :{BLACK}Automatically select road depot orientation based on environment
 
 # Road vehicle station construction window
 STR_STATION_BUILD_BUS_ORIENTATION                               :{WHITE}Bus Station Orientation
@@ -2802,6 +2833,7 @@ STR_LANDSCAPING_TOOLTIP_LOWER_A_CORNER_OF_LAND                  :{BLACK}Lower a
 STR_LANDSCAPING_TOOLTIP_RAISE_A_CORNER_OF_LAND                  :{BLACK}Raise a corner of land. Dragging raises the first selected corner and levels the selected area to the new corner height. Ctrl selects the area diagonally. Shift toggles building/showing cost estimate
 STR_LANDSCAPING_LEVEL_LAND_TOOLTIP                              :{BLACK}Level an area of land to the height of the first selected corner. Ctrl selects the area diagonally. Shift toggles building/showing cost estimate
 STR_LANDSCAPING_TOOLTIP_PURCHASE_LAND                           :{BLACK}Purchase land for future use. Shift toggles building/showing cost estimate
+STR_LANDSCAPING_TOOLTIP_RULER_TOOL                              :{BLACK}Use a virtual ruler to measure distance and height
 
 # Object construction window
 STR_OBJECT_BUILD_CAPTION                                        :{WHITE}Object Selection
@@ -4545,6 +4577,32 @@ STR_AI_LIST_AUTHOR                                              :{LTBLUE}Author:
 STR_AI_LIST_VERSION                                             :{LTBLUE}Version: {ORANGE}{NUM}
 STR_AI_LIST_URL                                                 :{LTBLUE}URL: {ORANGE}{RAW_STRING}
 
+######## Trip History
+STR_TRIP_HISTORY                                                :{BLACK}History
+STR_TRIP_HISTORY_TOOLTIP                                        :{BLACK}Shows the history of the last 10 trips
+STR_TRIP_HISTORY_RECEIVED_LABEL                                 :{BLACK}Received
+STR_TRIP_HISTORY_RECEIVED_LABEL_TIP                             :{BLACK}The date when the cargo was received
+STR_TRIP_HISTORY_PROFIT_LABEL                                   :{BLACK}Profit
+STR_TRIP_HISTORY_PROFIT_LABEL_TIP                               :{BLACK}The profit received from each trip
+STR_TRIP_HISTORY_PERCHANGE_LABEL                                :{BLACK}% Change
+STR_TRIP_HISTORY_PERCHANGE_LABEL_TIP                            :{BLACK}Percentage change between the current and last trips profit
+STR_TRIP_HISTORY_TBT_LABEL                                      :{BLACK}TBT
+STR_TRIP_HISTORY_TBT_LABEL_TIP                                  :{BLACK}Time taken between the current and last trip
+STR_TRIP_HISTORY_DAYCHANGE_LABEL                                :{BLACK}Change
+STR_TRIP_HISTORY_DAYCHANGE_LABEL_TIP                            :{BLACK}Change (in days) between the current and last trips length
+STR_TRIP_HISTORY_TOTALINCOME                                    :{BLACK}Total income for the last {NUM} trip{P "" s}:{LTBLUE} {CURRENCY_SHORT} {BLACK}({LTBLUE}{CURRENCY_SHORT} {BLACK} per day)
+STR_TRIP_HISTORY_DAYAVERAGE                                     :{BLACK}Average trip length:{LTBLUE} {NUM} day{P "" s}
+STR_TRIP_HISTORY_DAYAVERAGE_IMPROVEMENT                         :{BLACK}Improvement over last {NUM} trip{P "" s}:{LTBLUE} {NUM}%
+STR_TRIP_HISTORY_CAPTION                                        :{WHITE}{VEHICLE} Trip History
+STR_TRIP_HISTORY_DATE                                           :{BLACK}{DATE_LONG}
+STR_TRIP_HISTORY_PROFIT                                         :{BLACK}{CURRENCY_SHORT}
+STR_TRIP_HISTORY_VIRTUAL_PROFIT                                 :{YELLOW}{CURRENCY_SHORT}
+STR_TRIP_HISTORY_PROFITCHANGEPOS                                :{GREEN}+{NUM}%
+STR_TRIP_HISTORY_PROFITCHANGENEG                                :{RED}{NUM}%
+STR_TRIP_HISTORY_TBT                                            :{BLACK}{NUM} day{P "" s}
+STR_TRIP_HISTORY_TBTCHANGEPOS                                   :{RED}+{NUM}
+STR_TRIP_HISTORY_TBTCHANGENEG                                   :{GREEN}{NUM}
+
 STR_AI_LIST_ACCEPT                                              :{BLACK}Accept
 STR_AI_LIST_ACCEPT_TOOLTIP                                      :{BLACK}Select highlighted script
 STR_AI_LIST_CANCEL                                              :{BLACK}Cancel
@@ -5464,10 +5522,18 @@ STR_SAVEGAME_NAME_DEFAULT                                       :{COMPANY}, {STR
 STR_SAVEGAME_NAME_SPECTATOR                                     :Spectator, {1:STRING1}
 
 # Viewport strings
+STR_VIEWPORT_TOWN_POP_VERY_POOR_RATING                          :{WHITE}{TOWN} {RED}({COMMA})
+STR_VIEWPORT_TOWN_POP_MEDIOCRE_RATING                           :{WHITE}{TOWN} {ORANGE}({COMMA})
+STR_VIEWPORT_TOWN_POP_GOOD_RATING                               :{WHITE}{TOWN} {YELLOW}({COMMA})
 STR_VIEWPORT_TOWN_POP                                           :{WHITE}{TOWN} ({COMMA})
+STR_VIEWPORT_TOWN_POP_EXCELLENT_RATING                          :{WHITE}{TOWN} {GREEN}({COMMA})
 STR_VIEWPORT_TOWN                                               :{WHITE}{TOWN}
 STR_VIEWPORT_TOWN_TINY_BLACK                                    :{TINY_FONT}{BLACK}{TOWN}
+STR_VIEWPORT_TOWN_TINY_VERY_POOR_RATING                         :{TINY_FONT}{RED}{TOWN}
+STR_VIEWPORT_TOWN_TINY_MEDIOCRE_RATING                          :{TINY_FONT}{ORANGE}{TOWN}
+STR_VIEWPORT_TOWN_TINY_GOOD_RATING                              :{TINY_FONT}{YELLOW}{TOWN}
 STR_VIEWPORT_TOWN_TINY_WHITE                                    :{TINY_FONT}{WHITE}{TOWN}
+STR_VIEWPORT_TOWN_TINY_EXCELLENT_RATING                         :{TINY_FONT}{GREEN}{TOWN}
 
 STR_VIEWPORT_SIGN_SMALL_BLACK                                   :{TINY_FONT}{BLACK}{SIGN}
 STR_VIEWPORT_SIGN_SMALL_WHITE                                   :{TINY_FONT}{WHITE}{SIGN}
@@ -5553,3 +5619,280 @@ STR_PLANE                                                       :{BLACK}{PLANE}
 STR_SHIP                                                        :{BLACK}{SHIP}
 
 STR_TOOLBAR_RAILTYPE_VELOCITY                                   :{STRING} ({VELOCITY})
+STR_TOWN_VIEW_GROWTH                                            :{BLACK}GR: {ORANGE}{COMMA}{BLACK}  next: {ORANGE}{COMMA} {BLACK} RH: {ORANGE}{COMMA} {BLACK}flag {ORANGE}{COMMA}  {BLACK}Fund: {ORANGE}{COMMA}{SILVER}m
+STR_TOWN_VIEW_GROWTH_TILES                                      :{BLACK}HS: {ORANGE}{COMMA}(+{COMMA})  {BLACK}CS: {ORANGE}{COMMA}(+{COMMA})  {BLACK}HR: {ORANGE}{COMMA}(+{COMMA})
+STR_TOWN_VIEW_HOUSE_STATE                                       :{BLACK}Houses: Building: {ORANGE}{COMMA}{BLACK} :: {BLACK}RTM: {ORANGE}{COMMA}  {BLACK}DTM: {ORANGE}{COMMA}
+STR_LOCAL_AUTHORITY_COMPANY_RATING_NUM                          :{YELLOW}{COMPANY} {COMPANY_NUM}: {ORANGE}{STRING} {BLACK}({COMMA})
+
+######## community ########
+STR_NETWORK_CC_SELECT_NICE                                      :{BLACK}N-ICE
+STR_NETWORK_CC_SELECT_NICE_TOOLTIP                              :{BLACK}Select N-ICE servers
+STR_NETWORK_CC_SELECT_BTPRO                                     :{BLACK}BTPRO
+STR_NETWORK_CC_SELECT_BTPRO_TOOLTIP                             :{BLACK}Select BTPro servers
+STR_NETWORK_CC_SELECT_REDDIT                                    :{BLACK}REDDIT
+STR_NETWORK_CC_SELECT_REDDIT_TOOLTIP                            :{BLACK}Select Reddit servers
+STR_NETWORK_CC_SELECT_CITYMANIA                                 :{BLACK}CITYMANIA
+STR_NETWORK_CC_SELECT_CITYMANIA_TOOLTIP                         :{BLACK}Select CityMania servers
+
+STR_CC_SPACES                                                   :{BLACK}{NBSP}{NBSP}
+STR_CC_SEPARATOR1                                               :{CREAM} ||{NBSP}
+STR_CC_SEPARATOR                                                :{SILVER}{STRING}
+STR_CC_SEPARATOR_DEFAULT                                        :
+STR_CC_SEPARATOR_NICE                                           :## Visit n-ice.org ##
+STR_CC_SEPARATOR_BTPRO                                          :## Visit openttd.btpro.nl ##
+
+STR_CC_USER_TEXT                                                :{BLACK}User:{NBSP}
+STR_CC_USER_WHITE                                               :{WHITE}{RAW_STRING}
+STR_CC_USER_CHANGE                                              :{BLACK}...
+STR_CC_USER_ENTER                                               :{BLACK}Enter your account User name
+STR_CC_USER_CHANGE_TOOLTIP                                      :{BLACK}Enter acccount User name
+STR_CC_PASSWORD                                                 :{BLACK}PW:{NBSP}
+STR_CC_PASSWORD_ENTER                                           :{BLACK}Enter your account Password
+STR_CC_PASSWORD_CHANGE                                          :{BLACK}...
+STR_CC_PASSWORD_CHANGE_TOOLTIP                                  :{BLACK}Enter account Password
+
+
+STR_CC_GLOBAL_COMMANDS_TITLE                                    :{WHITE}Token Login tool
+STR_CC_TOKEN_WELCOME                                            :{BLACK}Welcome back {WHITE}{RAW_STRING}{BLACK} :)
+STR_CC_TOKEN_CLICKME                                            :{BLACK}Click the big button to Login automatically
+STR_CC_TOKEN_ENJOY                                              :{BLACK}  Respect the rules and enjoy the game. :)
+STR_CC_TOKEN_LOGIN                                              :{LTBLUE}Get Token --> Login
+STR_CC_TOKEN_LOGIN_TOOLTIP                                      :{BLACK}Get Token from website and executes !login XXXX
+STR_CC_TOKEN_LOGIN_ERROR                                        :{WHITE}Wrong Username or Password!
+
+STR_NETWORK_SERVER_LIST_CC_HEADER                               :{BLACK}{STRING}
+STR_NETWORK_SERVER_LIST_CC_DEFAULT                              :Select community
+STR_NETWORK_SERVER_LIST_CC_NICE                                 :n-ice | #n-ice.org#
+STR_NETWORK_SERVER_LIST_CC_BTPRO                                :BTPro | #openttd.btpro.nl#
+STR_CC_SERVERS_TOOLTIP                                          :Active Community
+
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE                    :{BLACK}Website
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE_TOOLTIP            :{BLACK}Open website in browser
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_S                  :{WHITE}Server:
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS                    :{BLACK}Forum
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_TOOLTIP            :{BLACK}Open Forum in browser of active community
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_DONATE             :{BLACK}Donate
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_DONATE_TOOLTIP     :{BLACK}Help us keeping good quality servers and community
+STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_CHAT                      :{BLACK}IRC Chat
+STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_CHAT_TOOLTIP              :{BLACK}Open mibbit IRC webclient to connect to IRC channel
+STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_SERVERS_CHAT              :{BLACK}Servers
+STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_SERVERS_CHAT_TOOLTIP      :{BLACK}Open mibbit IRC webclient to connect to Servers IRC channel
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_RULES                  :{BLACK}Rules
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_RULES_TOOLTIP          :{BLACK}Open Rules page in browser (of selected community)
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_WIKI                   :{BLACK}Wiki
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_WIKI_TOOLTIP           :{BLACK}Open Wiki page in browser (of selected community)
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_VIP                    :{BLACK}VIP's
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_VIP_TOOLTIP            :{BLACK}Open VIP page in browser (of selected community)
+
+STR_CC_SERVER_FREELANCER                                        :{WHITE}No community selected
+STR_NETWORK_DIRECT_JOIN_GAME                                    :{BLACK}{RAW_STRING}
+STR_NETWORK_DIRECT_JOIN_GAME_TOOLTIP                            :{BLACK}Join server directly
+STR_CC_BUILD                                                    :{BLACK}(Build 122A)
+STR_CC_ADMIN_LOGIN_WRONG_SERVER                                 :{BLACK}Not a correct community server
+STR_CC_IRC_LINK_CHAT                                            :{BLACK}IRC Chat
+STR_CC_IRC_LINK_CHAT_TOOLTIP                                    :{BLACK}Open mibbit in browser to connect to #btpro-chat IRC channel
+STR_CC_IRC_LINK_SERVERS                                         :{BLACK}IRC Servers
+STR_CC_IRC_LINK_SERVERS_SPACER                                  :{BLACK}{NBSP}{NBSP}
+STR_CC_IRC_LINK_SERVERS_TOOLTIP                                 :{BLACK}Open mibbit in browser to connect to #btpro-openttd IRC channel
+STR_CC_WIKI_RULES_PAGE                                          :{YELLOW}Detailed Rules
+STR_CC_WIKI_RULES_PAGE_STATUS                                   :{BLACK}Rules Wiki
+STR_CC_WIKI_RULES_PAGE_STATUS_TOOLTIP                           :{BLACK}Open Rules Wiki page in browser
+STR_CC_WIKI_RULES_PAGE_TOOLTIP                                  :{BLACK}Open browser in Rules Wiki page
+STR_CC_VIP                                                      :{GREEN}VIP's
+
+STR_CC_SERVER_LIST_UNREACHABLE                                  :{WHITE}Couldn't get server details
+STR_CC_SERVER_DISABLED                                          :{WHITE}Server is Disabled / Offline
+STR_CC_SERVER_LIST_ERROR_FILE                                   :{WHITE}Error on getting servers file
+
+STR_TOWN_VIEW_REALPOP_RATE                                      :{BLACK}Real Population: {YELLOW}{COMMA}  {BLACK}Rating: {YELLOW}{COMMA}
+STR_CB_DISTANCE_CHECK                                           :CB town acceptance: {STRING2}
+STR_ORDER_DIST                                                  :{NUM}, {NUM}
+
+#towns
+STR_TOWN_DIRECTORY_TOWN_COLOUR                                  :{ORANGE}{TOWN}{BLACK} ({COMMA}) - {YELLOW}{COMMA} {P "house" "houses"}
+STR_TOWN_DIRECTORY_CITY_COLOUR                                  :{YELLOW}{TOWN}{BLACK} ({COMMA}) - {YELLOW}{COMMA} {P "house" "houses"}
+STR_TOWN_DIRECTORY_CAPTION_EXTRA                                :{WHITE}Towns ({YELLOW}{COMMA}{WHITE} / {ORANGE}{COMMA}{WHITE})
+STR_SMALLMAP_TOWN_LARGE                                         :{TINY_FONT}{YELLOW}{TOWN}
+STR_TOWN_VIEW_TOWN_CAPTION_EXTRA                                :{WHITE}{TOWN} {COMMA} [{COMMA}]
+STR_TOWN_VIEW_CITY_CAPTION_EXTRA                                :{WHITE}{TOWN} (City) {COMMA} [{COMMA}]
+STR_SORT_BY_HOUSES                                              :Houses
+
+#cargo table
+STR_TOOLBAR_CARGOS_HEADER_CARGO                                 :{BLACK}Total/Month
+STR_TOOLBAR_CARGOS_HEADER_AMOUNT                                :{BLACK}Amount
+STR_TOOLBAR_CARGOS_HEADER_INCOME                                :{BLACK}Income
+STR_TOOLBAR_CARGOS_HEADER_TOTAL                                 :{BLACK}Total
+STR_TOOLBAR_CARGOS_HEADER_TOTAL_MONTH                           :{BLACK}Total this Month
+
+STR_TOOLBAR_CARGOS_UNITS                                        :{BLACK}{COMMA}
+STR_TOOLBAR_CARGOS_UNITS_TOTAL                                  :{BLACK}{COMMA}
+STR_TOOLBAR_CARGOS_CAPTION                                      :{WHITE}{COMPANY} Cargo Transported {BLACK}{COMPANY_NUM}
+STR_TOOLBAR_CARGOS_NAME                                         :{BLACK}{STRING}
+
+#community choice - settings
+STR_CONFIG_SETTING_COMMUNITY                                    :Choose your community: {STRING2}
+STR_CONFIG_SETTING_CLIENT_COMMUNITY                             :Freelancer
+STR_CONFIG_SETTING_CLIENT_COMMUNITY_NICE                        :n-ice / http://n-ice.org
+STR_CONFIG_SETTING_CLIENT_COMMUNITY_BTPRO                       :BTPro / https://openttd.btpro.nl
+
+STR_BT_NEW_CLIENT_AVAILABLE                                     :{WHITE}## ATTENTION ## There's a new BTPro client available. Visit openttd.btpro.nl (Website button below :)
+STR_CC_WIKI_USER_PAGE                                           :{BLACK}{RAW_STRING}
+STR_CC_WIKI_USER_PAGE_TOOLTIP                                   :{BLACK}Open browser in Community Website
+
+# Industry tooltip
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP                           :{BLACK}{STRING}
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_1                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_2                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_3                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_4                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_5                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_6                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+
+# Station tooltip
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP                            :{BLACK}{STATION}
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_1                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_2                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_3                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_4                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_5                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_6                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_7                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{SILVER}(...)
+
+# Town tooltip
+STR_TOWN_NAME_TOOLTIP                                           :{BLACK}{TOWN}
+
+######## Watch Window
+STR_WATCH_WINDOW_TITLE                                          :{WHITE}{RAW_STRING} in {RAW_STRING}({NUM}).
+STR_WATCH_WINDOW_TITLE2								                    			:{WHITE}Watching {RAW_STRING} {BLACK}({NUM}).
+STR_WATCH_CLICK_TO_WATCH_COMPANY_NUMBER                         :{BLACK}{NUM}
+STR_WATCH_CLICK_TO_WATCH_COMPANY                                :{BLACK}Click here to watch this company building
+STR_WATCH_CLICK_TO_OPEN_COMPANY                                 :{BLACK}Click here to open this company window
+STR_WATCH_CLICK_NEW_WINDOW                                      :{BLACK}Click here to open new watching window
+
+STR_CC_OTHER_TOKEN_WSA_ERROR                                    :{WHITE}WSAStartup() failed
+STR_CC_OTHER_TOKEN_SOCKET_ERROR                                 :{WHITE}socket() failed
+STR_CC_OTHER_TOKEN_CONNECT_ERROR                                :{WHITE}connect() failed
+STR_CC_OTHER_TOKEN_SENT_ERROR                                   :{WHITE}send() sent a different number of bytes than expected
+STR_CC_OTHER_TOKEN_LOGIN_ERROR                                  :{WHITE}Wrong Username or Password!
+
+STR_CONFIG_SETTING_ENABLE_EXTRA_TOOLTIPS                        :Enable extra tooltips{STRING2}
+STR_TTE_HOUSE_NAME                                              :{LTBLUE}{STRING}
+STR_TTE_HOUSE                                                   :{BLACK}Population: {NUM}
+STR_TTE_INDUSTRY_NAME                                           :{LTBLUE}{INDUSTRY}
+STR_TTE_INDUSTRY                                                :{WHITE}{STRING}  {BLACK}{CARGO_SHORT} {YELLOW}{NUM} %
+STR_TTE_STATION_NAME                                            :{LTBLUE}{STATION}
+STR_TTE_STATION                                                 :{WHITE}{STRING}  {BLACK}{CARGO_SHORT} {YELLOW}{NUM} %
+STR_LAND_AREA_INFORMATION_POP                                   :{BLACK}Population: {LTBLUE}{NUM}
+
+STR_CONFIG_SETTING_POWERFUND_MONEY                              :Powerfund minimum needed money for fund: {STRING2}
+STR_CONFIG_SETTING_POWERFUND_HOUSES                             :Maximum amount of houses to powerfund up to
+
+######## Zoning toolbar
+
+STR_ZONING_TOOLBAR                                              :{WHITE}Zoning toolbar
+STR_ZONING_OUTER                                                :{BLACK}Outer tile borders:
+STR_ZONING_INNER                                                :{BLACK}Inner tile borders:
+STR_ZONING_OUTER_INFO                                           :{BLACK}Select which type of zoning you want on the outer border of a tile.
+STR_ZONING_INNER_INFO                                           :{BLACK}Select which type of zoning you want on the inner border of a tile.
+
+STR_ZONING_NO_ZONING                                            :{BLACK}Nothing
+STR_ZONING_AUTHORITY                                            :{BLACK}Authority
+STR_ZONING_CAN_BUILD                                            :{BLACK}Where I can't build
+STR_ZONING_STA_CATCH                                            :{BLACK}Station catchment
+STR_ZONING_IND_CATCH                                            :{BLACK}Industry catchment
+STR_ZONING_BUL_CATCH                                            :{BLACK}City catchment
+STR_ZONING_BUL_UNSER                                            :{BLACK}Unserved buildings
+STR_ZONING_IND_UNSER                                            :{BLACK}Unserved industries
+STR_ZONING_TOWN_ZONES                                           :{BLACK}Town zones
+STR_ZONING_CB_TOWN_BORDERS                                      :{BLACK}CB town borders
+STR_ZONING_CB_BORDERS                                           :{BLACK}CB borders
+STR_ZONING_ADVERTISEMENT_ZONES                                  :{BLACK}Advertisement
+STR_ZONING_TOWN_GROWTH_TILES                                    :{BLACK}Town growth tiles
+
+### Town CB gui
+STR_BUTTON_CB                                                   :{STRING}
+STR_BUTTON_CB_YES                                               :{BLACK}CB
+STR_TOWN_VIEW_CB_CAPTION                                        :{WHITE}{TOWN}
+
+STR_CB_LARGE_ADVERTISING_CAMPAIGN                               :{BLACK}Large Advertising
+STR_CB_NEW_BUILDINGS                                            :{BLACK}Fund Buildings
+STR_CB_FUND_REGULAR                                             :{BLACK}Fund Regularly
+STR_CB_FUND_REGULAR_TT                                          :{BLACK}Every time fund buildings is zero and company has enough money, buildings will be funded automatically
+STR_CB_FUNDED_REGULARLY                                         :{GREEN}Town is funded regularly
+STR_CB_ADVERT_REGULAR                                           :{BLACK}Adv. Regularly
+STR_CB_ADVERT_REGULAR_TT                                        :{BLACK}Automatically advertise town whenever stations rating drops below a certain point
+STR_CB_POWERFUND                                                :{BLACK}Powerfund
+STR_CB_ADVERT_REGULAR_RATING_TO_KEEP                            :{BLACK}Keep station rating at
+STR_CB_POWERFUND_TT                                             :{BLACK}Continiously funds town with maximum speed possible
+STR_ERROR_CB_NO_STATION_FOR_REGULAR_ADV                         :{WHITE}No suitable station found in {TOWN}{}Regular Advertisement was deactivated
+
+STR_TOWN_CB_FUNDING                                             :{ORANGE}Funded for {YELLOW}{COMMA}{ORANGE} month{P "" s}
+STR_TOWN_CB_GROWING                                             :{GREEN}Town is growing!
+STR_TOWN_CB_NOT_GROWING                                         :{WHITE}Town is not growing
+STR_TOWN_CB_GROWING_DETAIL                                      :{ORANGE}1 house in {YELLOW}{COMMA} {ORANGE}days ({YELLOW}{COMMA}%{ORANGE}). Next House in {YELLOW}{COMMA} {ORANGE}days
+
+STR_TOWN_GROWTH_HEADER_CARGO                                    :{BLACK}Cargo
+STR_TOWN_GROWTH_HEADER_AMOUNT                                   :{BLACK}Delivered
+STR_TOWN_GROWTH_HEADER_REQ                                      :{BLACK}Required
+STR_TOWN_GROWTH_HEADER_LAST                                     :{BLACK}Last Month
+STR_TOWN_GROWTH_HEADER_STORE                                    :{BLACK}Stored
+STR_TOWN_GROWTH_HEADER_STORE_PCT                                :{BLACK}Use%
+STR_TOWN_GROWTH_HEADER_FROM                                     :{BLACK}From
+
+STR_TOWN_CB_CARGO_NAME                                          :{BLACK}{STRING}:
+
+STR_TOWN_CB_CARGO_AMOUNT_GOOD                                   :{GREEN}{COMMA}
+STR_TOWN_CB_CARGO_AMOUNT_BAD                                    :{YELLOW}{COMMA}
+STR_TOWN_CB_CARGO_AMOUNT_NOT                                    :{SILVER}{COMMA}
+
+STR_TOWN_CB_CARGO_REQ_YES                                       :{ORANGE}{COMMA}
+STR_TOWN_CB_CARGO_REQ_NOT                                       :{SILVER}{COMMA}
+
+STR_TOWN_CB_CARGO_STORE_YES                                     :{LTBLUE}{COMMA}
+STR_TOWN_CB_CARGO_STORE_NOT                                     :{SILVER}{COMMA}
+STR_TOWN_CB_CARGO_STORE_DECAY                                   :{BLACK}-
+
+STR_TOWN_CB_CARGO_STORE_PCT_YES                                 :{LTBLUE}{COMMA}%
+STR_TOWN_CB_CARGO_STORE_PCT_NOT                                 :{SILVER}{COMMA}%
+
+STR_TOWN_CB_CARGO_PREVIOUS_YES                                  :{GREEN}{COMMA}
+STR_TOWN_CB_CARGO_PREVIOUS_EDGE                                 :{YELLOW}{COMMA}
+STR_TOWN_CB_CARGO_PREVIOUS_BAD                                  :{RED}{COMMA}
+STR_TOWN_CB_CARGO_PREVIOUS_NOT                                  :{SILVER}{COMMA}
+
+STR_TOWN_CB_CARGO_FROM_YES                                      :{YELLOW}{COMMA}
+STR_TOWN_CB_CARGO_FROM_NOT                                      :{SILVER}{COMMA}
+
+STR_CB_GUI_TOWN_VIEW_BUTTON                                     :{BLACK}Town view
+STR_CB_GUI_TOWN_VIEW_TOOLTIP                                    :{BLACK}Show information on town
+
+### Advanced Industry gui
+STR_AD_SLOTNAME                                                 :{BLACK}Name
+STR_AD_SLOTNAME_TIP                                             :{BLACK}Name of this slot. Click on it to change.
+STR_AD_SLOTLIST_NAME_TIP                                        :{BLACK}Name of this slot list preset. Click on it to change.
+STR_AD_NEWSLOTLIST                                              :{BLACK}New
+STR_AD_NEWSLOTLIST_TIP                                          :{BLACK}Create new slot list preset. Unsaved slot list will be lost.
+STR_AD_LOADSLOTLIST                                             :{BLACK}Load
+STR_AD_LOADSLOTLIST_TIP                                         :{BLACK}Load a previously saved slot list.
+STR_AD_DELETESLOTLIST                                           :{BLACK}Delete
+STR_AD_DELETESLOTLIST_TIP                                       :{BLACK}Delete current active slot.
+STR_AD_SAVESLOTLIST                                             :{BLACK}Save
+STR_AD_SAVESLOTLIST_TIP                                         :{BLACK}Save current slot list.
+STR_AD_STATIONSIZE                                              :{BLACK}Size
+STR_AD_STATIONSIZE_TIP                                          :{BLACK}Size of searched area (<= 50), for example station size. Lower values are faster. Click on it to change.
+STR_AD_LIMIT                                                    :{BLACK}Limit
+STR_AD_LIMIT_TIP                                                :{BLACK}Limit of search results. Lower values are faster. Click on it to change.
+STR_AD_AUTOREFRESH                                              :{BLACK}Automatic refresh
+STR_AD_AUTOREFRESH_TIP                                          :{BLACK}Refresh automatically each month. Don't activate this on too many slots with large searches.
+STR_AD_CARGOLIST                                                :{BLACK}Cargolist
+STR_AD_CARGOLIST_TIP                                            :{BLACK}List of cargoes to include in search. Add cargoes to list by clicking on the + button and selecting them in the drop down menu.
+STR_AD_ADDITIVEWEIGHT                                           :{BLACK}Additive cargo weight
+STR_AD_ADDITIVEWEIGHT_TIP                                       :{BLACK}FIRS calculation, if multiple cargoes are neccessary for full production.
+STR_AD_SEARCH                                                   :{BLACK}Search
+STR_AD_SEARCH_TIP                                               :{BLACK}Start the search
+STR_AD_QW_SLOTNAME                                              :{BLACK}Set name of this slot
+STR_AD_QW_STATIONSIZE                                           :{BLACK}Set size of searched area
+STR_AD_QW_LIMIT                                                 :{BLACK}Set limit of search results
+STR_AD_QW_CARGOWEIGHT                                           :{BLACK}Set weight of this cargo
+STR_AD_IL_ITEM                                                  :{BLACK}{NUM} (IC:{ORANGE}{NUM}{BLACK}, CTC:{ORANGE}{NUM}{BLACK}, WF:{ORANGE}{NUM}{BLACK})
+STR_AD_IL_ITEM_USED                                             :{LTBLUE}{NUM} (IC:{ORANGE}{NUM}{LTBLUE}, CTC:{ORANGE}{NUM}{LTBLUE}, WF:{ORANGE}{NUM}{LTBLUE})
diff --git a/src/lang/macedonian.txt b/src/lang/macedonian.txt
index 0a7b958f8..7e9415552 100644
--- a/src/lang/macedonian.txt
+++ b/src/lang/macedonian.txt
@@ -817,6 +817,7 @@ STR_GAME_OPTIONS_AUTOSAVE_DROPDOWN_EVERY_1_MONTH                :Секој ме
 
 
 
+
 # Custom currency window
 
 
diff --git a/src/lang/serbian.txt b/src/lang/serbian.txt
index f3728f7dc..a880f5c76 100644
--- a/src/lang/serbian.txt
+++ b/src/lang/serbian.txt
@@ -3641,7 +3641,6 @@ STR_LOCAL_AUTHORITY_ACTION_NEW_BUILDINGS                        :Finansiranje no
 STR_LOCAL_AUTHORITY_ACTION_EXCLUSIVE_TRANSPORT                  :Kupovina ekskluzivnih prava prevoza
 STR_LOCAL_AUTHORITY_ACTION_BRIBE                                :Podmićivanje lokalne vlasti
 
-###length 8
 STR_LOCAL_AUTHORITY_ACTION_TOOLTIP_SMALL_ADVERTISING            :{YELLOW}Ulaganje u malu reklamnu kampanju će doneti preduzeću više putnika i robe iz ovog naselja.{}Privremeno povećava rejting stanica u malom prečniku oko centra grada tokom trajanja kampanje.{}Trošak: {CURRENCY_LONG}
 STR_LOCAL_AUTHORITY_ACTION_TOOLTIP_MEDIUM_ADVERTISING           :{YELLOW}Ulaganje u reklamnu kampanju srednje veličine će doneti preduzeću više putnika i robe iz ovog naselja.{}Privremeno povećava rejting stanica u prečniku srednje veličine oko centra grada tokom trajanja kampanje.{}Trošak: {CURRENCY_LONG}
 STR_LOCAL_AUTHORITY_ACTION_TOOLTIP_LARGE_ADVERTISING            :{YELLOW}Ulaganje u veliku reklamnu kampanju će doneti preduzeću više putnika i robe iz ovog naselja.{}Privremeno povećava rejting stanica u velikom prečniku oko centra grada tokom trajanja kampanje.{}Trošak: {CURRENCY_LONG}
diff --git a/src/main_gui.cpp b/src/main_gui.cpp
index 6131050cf..09dd2ff9d 100644
--- a/src/main_gui.cpp
+++ b/src/main_gui.cpp
@@ -33,6 +33,13 @@
 #include "guitimer_func.h"
 #include "error.h"
 #include "news_gui.h"
+#include "watch_gui_1.h"
+#include "industry.h"
+#include "town_map.h"
+
+#include "station_gui.h"
+#include "station_base.h"
+#include "cargotype.h"
 
 #include "saveload/saveload.h"
 
@@ -65,7 +72,7 @@ bool HandlePlacePushButton(Window *w, int widget, CursorID cursor, HighLightStyl
 	if (_settings_client.sound.click_beep) SndPlayFx(SND_15_BEEP);
 	w->SetDirty();
 
-	if (w->IsWidgetLowered(widget)) {
+	if (w->IsWidgetLowered(widget) && mode == _thd.place_mode) {
 		ResetObjectToPlace();
 		return false;
 	}
@@ -180,6 +187,7 @@ static const struct NWidgetPart _nested_main_window_widgets[] = {
 
 enum {
 	GHK_QUIT,
+	GHK_WATCH_WINDOW,
 	GHK_ABANDON,
 	GHK_CONSOLE,
 	GHK_BOUNDING_BOXES,
@@ -368,6 +376,8 @@ struct MainWindow : Window
 				ResetRestoreAllTransparency();
 				break;
 
+            case GHK_WATCH_WINDOW:	ShowWatchWindow1( INVALID_COMPANY );	break;
+
 			case GHK_CHAT: // smart chat; send to team if any, otherwise to all
 				if (_networking) {
 					const NetworkClientInfo *cio = NetworkClientInfo::GetByClientID(_network_own_client_id);
@@ -446,6 +456,96 @@ struct MainWindow : Window
 		InvalidateWindowData(WC_MAIN_TOOLBAR, 0, data, true);
 	}
 
+  virtual void OnMouseOver(Point pt, int widget)
+	{
+		if (_game_mode != GM_MENU && _settings_client.gui.enable_extra_tooltips && pt.x != -1) {
+			GuiPrepareTooltipsExtra(this);
+		/* Show tooltip with last month production or town name */
+		} else if (pt.x != -1 && _game_mode != GM_MENU) {
+			TileIndex tile;
+			const bool viewport_is_in_map_mode = (this->viewport->zoom > ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_DRAW_MAP);
+			if (viewport_is_in_map_mode) {
+        // Disable, for now :)
+				/*const int a = ((ScaleByZoom(pt.x, this->viewport->zoom) + this->viewport->virtual_left) >> 2) / ZOOM_LVL_BASE;
+				const int b = ((ScaleByZoom(pt.y, this->viewport->zoom) + this->viewport->virtual_top) >> 1) / ZOOM_LVL_BASE;
+				tile = TileVirtXY(b - a, b + a);*/
+			} else {
+				const Point p = GetTileBelowCursor();
+				tile = TileVirtXY(p.x, p.y);
+			}
+			if (tile >= MapSize()) return;
+
+			switch (GetTileType(tile)) {
+				case MP_ROAD:
+					if (IsRoadDepot(tile)) return;
+					/* FALL THROUGH */
+				case MP_HOUSE: {
+					if (HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return; // No need for a town name tooltip when it is already displayed
+					if (!viewport_is_in_map_mode) return;
+					const TownID tid = GetTownIndex(tile);
+					if (!tid) return;
+					SetDParam(0, tid);
+					GuiShowTooltips(this, STR_TOWN_NAME_TOOLTIP, 0, NULL, TCC_HOVER);
+					break;
+				}
+				case MP_INDUSTRY: {
+					const Industry *ind = Industry::GetByTile(tile);
+					const IndustrySpec *indsp = GetIndustrySpec(ind->type);
+
+					StringID str = STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP;
+					uint prm_count = 0;
+					SetDParam(prm_count++, indsp->name);
+					for (byte i = 0; i < lengthof(ind->produced_cargo); i++) {
+						if (ind->produced_cargo[i] != CT_INVALID) {
+							SetDParam(prm_count++, ind->produced_cargo[i]);
+							SetDParam(prm_count++, ind->last_month_production[i]);
+							SetDParam(prm_count++, ToPercent8(ind->last_month_pct_transported[i]));
+							str++;
+						}
+					}
+					if (prm_count <= 19) {
+            GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+          }
+					break;
+				}
+				case MP_STATION: {
+          if (!IsRailWaypoint(tile)) {
+            if (!HasTileWaterGround(tile)) {
+              const Station *st = Station::GetByTile(tile);
+              StringID str = STR_STATION_VIEW_TRANSPORTED_TOOLTIP;
+              uint prm_count = 0;
+              SetDParam(prm_count++, st->index);
+			  for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+                //const CargoSpec *cs = CargoSpec::Get(i);
+                if(cs == NULL) continue;
+                int cargoid = cs->Index();
+                //if (HasBit(st->goods[i].status,GoodsEntry::GES_RATING)) {
+                if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+                  SetDParam(prm_count++, cs->Index());
+                  SetDParam(prm_count++, st->goods[cargoid].cargo.TotalCount());
+                  SetDParam(prm_count++, ToPercent8(st->goods[cargoid].rating));
+                  str++;
+                  if (prm_count == 19) {
+                    str++;
+					break;
+                  }
+                }
+              }
+              if (prm_count <= 19) {
+                GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+              }
+            }
+          }
+					break;
+				}
+				default:
+					return;
+			}
+		}
+	}
+
 	static HotkeyList hotkeys;
 };
 
@@ -499,6 +599,7 @@ static Hotkey global_hotkeys[] = {
 	Hotkey(_ghk_chat_server_keys, "chat_server", GHK_CHAT_SERVER),
 	Hotkey(WKC_SPACE, "close_news", GHK_CLOSE_NEWS),
 	Hotkey(WKC_SPACE, "close_error", GHK_CLOSE_ERROR),
+  	Hotkey('O', "show_watch_window", GHK_WATCH_WINDOW),
 	HOTKEY_LIST_END
 };
 HotkeyList MainWindow::hotkeys("global", global_hotkeys);
diff --git a/src/map.cpp b/src/map.cpp
index 308e28e49..41b20bf61 100644
--- a/src/map.cpp
+++ b/src/map.cpp
@@ -13,7 +13,9 @@
 #include "water_map.h"
 #include "string_func.h"
 
-#include "safeguards.h"
+//#include "safeguards.h"
+
+#include "../openttd_cuda/openttd_cuda_dll.h"
 
 #if defined(_MSC_VER)
 /* Why the hell is that not in all MSVC headers?? */
@@ -60,6 +62,7 @@ void AllocateMap(uint size_x, uint size_y)
 	free(_me);
 
 	_m = CallocT<Tile>(_map_size);
+	OpenTTDCuda::OpenTTDCuda::setMap(_m, _map_size_x, _map_size_y);
 	_me = CallocT<TileExtended>(_map_size);
 }
 
diff --git a/src/misc.cpp b/src/misc.cpp
index c46a1c11d..be141e768 100644
--- a/src/misc.cpp
+++ b/src/misc.cpp
@@ -120,6 +120,7 @@ void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settin
 	InitializeEconomy();
 
 	ResetObjectToPlace();
+	ResetRailPlacementEndpoints();
 
 	GamelogReset();
 	GamelogStartAction(GLAT_START);
diff --git a/src/misc_gui.cpp b/src/misc_gui.cpp
index 4418fa825..6f3cbe91a 100644
--- a/src/misc_gui.cpp
+++ b/src/misc_gui.cpp
@@ -32,11 +32,18 @@
 
 #include "table/strings.h"
 
+#include "house.h"
+#include "town_map.h"
+#include "station_base.h"
+#include "viewport_func.h"
+#include "industry.h"
 #include <sstream>
 #include <iomanip>
 
 #include "safeguards.h"
 
+void GuiShowTooltipsExtra(Window *parent, uint param, TooltipCloseCondition close_tooltip);
+
 /** Method to open the OSK. */
 enum OskActivation {
 	OSKA_DISABLED,           ///< The OSK shall not be activated at all.
@@ -45,8 +52,8 @@ enum OskActivation {
 	OSKA_IMMEDIATELY,        ///< Focusing click already opens OSK.
 };
 
-
-static const NWidgetPart _nested_land_info_widgets[] = {
+// Vanilla Openttd LandInfo
+static const NWidgetPart _nested_land_info_widgets_old[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
 		NWidget(WWT_CAPTION, COLOUR_GREY), SetDataTip(STR_LAND_AREA_INFORMATION_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
@@ -56,10 +63,24 @@ static const NWidgetPart _nested_land_info_widgets[] = {
 	NWidget(WWT_PANEL, COLOUR_GREY, WID_LI_BACKGROUND), EndContainer(),
 };
 
-static WindowDesc _land_info_desc(
+// Augmented Openttd Landinfo
+static const NWidgetPart _nested_land_info_widgets[] = {
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_LI_BACKGROUND), SetMinimalSize(64, 32),     EndContainer(),
+};
+
+//old
+static WindowDesc _land_info_desc_old(
 	WDP_AUTO, "land_info", 0, 0,
 	WC_LAND_INFO, WC_NONE,
 	0,
+    _nested_land_info_widgets_old, lengthof(_nested_land_info_widgets_old)
+);
+
+// Vanilla Openttd LandInfo
+static WindowDesc _land_info_desc(
+        WDP_MANUAL, "land_info", 0, 0,
+	WC_LAND_INFO, WC_NONE,
+	0,
 	_nested_land_info_widgets, lengthof(_nested_land_info_widgets)
 );
 
@@ -69,6 +90,20 @@ class LandInfoWindow : public Window {
 
 public:
 	TileIndex tile;
+	TileIndex end_tile;  ///< For use in ruler(dragdrop) mode
+	TooltipCloseCondition close_cond; ///< Condition for closing the window.
+
+	Point OnInitialPosition(int16 sm_width, int16 sm_height, int window_number) override
+	{
+               int scr_top = GetMainViewTop() + 2;
+               int scr_bot = GetMainViewBottom() - 2;
+               Point pt;
+               pt.y = Clamp(_cursor.pos.y + _cursor.total_size.y + _cursor.total_offs.y + 5, scr_top, scr_bot);
+               if (pt.y + sm_height > scr_bot) pt.y = std::min(_cursor.pos.y + _cursor.total_offs.y - 5, scr_bot) - sm_height;
+               pt.x = sm_width >= _screen.width ? 0 : Clamp(_cursor.pos.x - (sm_width >> 1), 0, _screen.width - sm_width);
+               return pt;
+	}
+
 
 	void DrawWidget(const Rect &r, int widget) const override
 	{
@@ -108,9 +143,19 @@ public:
 		}
 	}
 
-	LandInfoWindow(TileIndex tile) : Window(&_land_info_desc), tile(tile)
+	// Vanilla Openttd Landinfo
+	LandInfoWindow(TileIndex tile, TileIndex end_tile, bool oldinfo): Window(&_land_info_desc_old), tile(tile)
+	{
+		this->InitNested();
+	}
+
+	// Augmented Openttd Landinfo
+	LandInfoWindow(TileIndex tile, TileIndex end_tile=INVALID_TILE, TooltipCloseCondition close_tooltip=TCC_HOVER) :
+		Window(&_land_info_desc), tile(tile), end_tile(end_tile)
 	{
+		this->close_cond = close_tooltip;
 		this->InitNested();
+		CLRBITS(this->flags, WF_WHITE_BORDER);
 
 #if defined(_DEBUG)
 #	define LANDINFOD_LEVEL 0
@@ -164,6 +209,7 @@ public:
 		td.road_speed = 0;
 		td.tramtype = STR_NULL;
 		td.tram_speed = 0;
+		td.population = 0;
 
 		td.grf = nullptr;
 
@@ -302,6 +348,13 @@ public:
 			this->landinfo_data.push_back(GetString(STR_LAND_AREA_INFORMATION_NEWGRF_NAME));
 		}
 
+		/* House pop */
+		if (td.population != 0) {
+			SetDParam(0, td.population);
+			this->landinfo_data.push_back(GetString(STR_LAND_AREA_INFORMATION_POP));
+		}
+
+
 		/* Cargo acceptance is displayed in a extra multiline */
 		std::stringstream line;
 		line << GetString(STR_LAND_AREA_INFORMATION_CARGO_ACCEPTED);
@@ -368,16 +421,49 @@ public:
 				break;
 		}
 	}
+
+
+	void OnMouseLoop() override
+	{
+		if (!_settings_client.gui.enable_extra_tooltips) {
+			return;
+		}
+		/* Always close tooltips when the cursor is not in our window. */
+		if (!_cursor.in_window) {
+			this->Close();
+			return;
+		}
+
+		/* We can show tooltips while dragging tools. These are shown as long as
+		 * we are dragging the tool. Normal tooltips work with hover or rmb. */
+		switch (this->close_cond) {
+			case TCC_RIGHT_CLICK: if (!_right_button_down) this->Close(); break;
+			case TCC_HOVER: if (!_mouse_hovering) this->Close(); break;
+			case TCC_NONE: break;
+			case TCC_EXIT_VIEWPORT: {
+				const Point p = GetTileBelowCursor();
+				if (p.x == -1) break;
+				if (tile != TileVirtXY(p.x, p.y)) this->Close();
+				break;
+			}
+			default: break;
+		}
+	}
+
 };
 
 /**
  * Show land information window.
  * @param tile The tile to show information about.
  */
-void ShowLandInfo(TileIndex tile)
+void ShowLandInfo(TileIndex tile, TooltipCloseCondition close_cond, TileIndex end_tile)
 {
 	CloseWindowById(WC_LAND_INFO, 0);
-	new LandInfoWindow(tile);
+	if (_settings_client.gui.enable_extra_tooltips) {
+		new LandInfoWindow(tile, end_tile, close_cond);
+	} else {
+		new LandInfoWindow(tile, end_tile, true);
+	}
 }
 
 static const NWidgetPart _nested_about_widgets[] = {
@@ -672,11 +758,13 @@ struct TooltipsWindow : public Window
 	byte paramcount;                  ///< Number of string parameters in #string_id.
 	uint64 params[5];                 ///< The string parameters.
 	TooltipCloseCondition close_cond; ///< Condition for closing the window.
+	char buffer[DRAW_STRING_BUFFER];  ///< Text to draw
 
 	TooltipsWindow(Window *parent, StringID str, uint paramcount, const uint64 params[], TooltipCloseCondition close_tooltip) : Window(&_tool_tips_desc)
 	{
 		this->parent = parent;
 		this->string_id = str;
+		if (paramcount == 0) GetString(this->buffer, str, lastof(this->buffer)); // Get the text while params are still around
 		static_assert(sizeof(this->params[0]) == sizeof(params[0]));
 		assert(paramcount <= lengthof(this->params));
 		if (paramcount > 0) memcpy(this->params, params, sizeof(this->params[0]) * paramcount);
@@ -727,10 +815,14 @@ struct TooltipsWindow : public Window
 		GfxFillRect(r.left, r.top, r.right, r.bottom, PC_BLACK);
 		GfxFillRect(r.left + 1, r.top + 1, r.right - 1, r.bottom - 1, PC_LIGHT_YELLOW);
 
-		for (uint arg = 0; arg < this->paramcount; arg++) {
-			SetDParam(arg, this->params[arg]);
+		if (this->paramcount == 0) {
+			DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, this->buffer, TC_FROMSTRING, SA_CENTER);
+		} else {
+			for (uint arg = 0; arg < this->paramcount; arg++) {
+				SetDParam(arg, this->params[arg]);
+			}
+			DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, this->string_id, TC_FROMSTRING, SA_CENTER);
 		}
-		DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, this->string_id, TC_FROMSTRING, SA_CENTER);
 	}
 
 	void OnMouseLoop() override
@@ -1281,3 +1373,270 @@ void ShowQuery(StringID caption, StringID message, Window *parent, QueryCallback
 
 	new QueryWindow(&_query_desc, caption, message, parent, callback);
 }
+
+
+/** Window for displaying a tooltip. */
+void GuiPrepareTooltipsExtra(Window *parent){
+	const Point p = GetTileBelowCursor();
+	if (p.x == -1) return;
+
+	const TileIndex tile = TileVirtXY(p.x, p.y);
+
+	if (_cursor.sprite_seq[0].sprite == SPR_CURSOR_QUERY &&
+			FindWindowByClass(WC_LAND_INFO) == nullptr) {
+		if (_settings_client.gui.hover_delay_ms == 0 && !_right_button_down)
+			return;
+
+		ShowLandInfo(tile,
+				_settings_client.gui.hover_delay_ms > 0 ? TCC_EXIT_VIEWPORT : TCC_RIGHT_CLICK);
+
+		return;
+	}
+
+	if (!_settings_client.gui.enable_extra_tooltips) return;
+
+	if (tile >= MapSize()) return;
+
+	uint param = 0;
+	switch (GetTileType(tile)) {
+		case MP_HOUSE: {
+			const HouseID house = GetHouseType(tile);
+			param = ((house & 0xFFFF) << 16) | MP_HOUSE;
+			break;
+		}
+		case MP_INDUSTRY: {
+			const Industry *ind = Industry::GetByTile(tile);
+			if(ind->produced_cargo[0] == CT_INVALID && ind->produced_cargo[1] == CT_INVALID) return;
+			param = ((ind->index & 0xFFFF) << 16) | MP_INDUSTRY;
+			break;
+		}
+		case MP_STATION: {
+			if (IsRailWaypoint(tile) || HasTileWaterGround(tile)) break;
+			const Station *st = Station::GetByTile(tile);
+			param |= ((st->index & 0xFFFF) << 16) | MP_STATION;
+			break;
+		}
+		default:
+			return;
+	}
+	if(param != 0) {
+		GuiShowTooltipsExtra(parent, param,
+				_settings_client.gui.hover_delay_ms > 0 ? TCC_HOVER : TCC_RIGHT_CLICK);
+	}
+}
+
+static const NWidgetPart _nested_tooltips_extra_widgets[] = {
+       NWidget(WWT_PANEL, COLOUR_GREY, WID_TT_BACKGROUND), SetMinimalSize(64, 32),     EndContainer(),
+};
+
+static WindowDesc _tool_tips_extra_desc(
+       WDP_MANUAL, NULL, 0, 0,
+       WC_TOOLTIPS_EXTRA, WC_NONE,
+       0,
+       _nested_tooltips_extra_widgets, lengthof(_nested_tooltips_extra_widgets)
+);
+
+struct TooltipsExtraWindow : public Window
+{
+       TileType tiletype;
+       uint16 objIndex;
+       TooltipCloseCondition close_cond;
+
+       TooltipsExtraWindow(Window *parent, uint param, TooltipCloseCondition close_tooltip) : Window(&_tool_tips_extra_desc)
+       {
+               this->parent = parent;
+               this->tiletype = (TileType)(param & 0xFFFF);
+               this->objIndex = (uint16)((param >> 16) & 0xFFFF);
+               this->close_cond = close_tooltip;
+               this->InitNested();
+               CLRBITS(this->flags, WF_WHITE_BORDER);
+       }
+
+       Point OnInitialPosition(int16 sm_width, int16 sm_height, int window_number) override
+       {
+               int scr_top = GetMainViewTop() + 2;
+               int scr_bot = GetMainViewBottom() - 2;
+               Point pt;
+               pt.y = Clamp(_cursor.pos.y + _cursor.total_size.y + _cursor.total_offs.y + 5, scr_top, scr_bot);
+               if (pt.y + sm_height > scr_bot) pt.y = std::min(_cursor.pos.y + _cursor.total_offs.y - 5, scr_bot) - sm_height;
+               pt.x = sm_width >= _screen.width ? 0 : Clamp(_cursor.pos.x - (sm_width >> 1), 0, _screen.width - sm_width);
+               return pt;
+       }
+
+       void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize) override
+       {
+               uint icon_size = ScaleGUITrad(10);
+               uint line_height = std::max<uint>(FONT_HEIGHT_NORMAL, icon_size) + 2;
+               uint icons_width = icon_size * 3 + 20;
+               size->width = 200;
+               size->height = FONT_HEIGHT_NORMAL + 6;
+               switch(this->tiletype) {
+                       case MP_HOUSE: {
+                              const HouseID house = (HouseID)this->objIndex;
+                              const HouseSpec *hs = HouseSpec::Get(house);
+
+                              size->height += line_height;
+                               SetDParam(0, 1000);
+                               size->width = GetStringBoundingBox(STR_TTE_HOUSE).width;
+                               if(hs == NULL) break;
+                              SetDParam(0, hs->building_name);
+                              size->width = std::max(GetStringBoundingBox(STR_TTE_HOUSE_NAME).width + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT + 18, size->width);
+                               break;
+                       }
+                       case MP_INDUSTRY: {
+                               const Industry *ind = Industry::GetIfValid((IndustryID)this->objIndex);
+                               if(ind == NULL) break;
+
+                               for (CargoID i = 0; i < lengthof(ind->produced_cargo); i++) {
+                                       if (ind->produced_cargo[i] == CT_INVALID) continue;
+                                       const CargoSpec *cs = CargoSpec::Get(ind->produced_cargo[i]);
+                                       if(cs == NULL) continue;
+                                       size->height += line_height;
+                                       SetDParam(0, cs->name);
+                                       SetDParam(1, cs->Index());
+                                       SetDParam(2, ind->last_month_production[i]);
+                                       SetDParam(3, ToPercent8(ind->last_month_pct_transported[i]));
+                                       size->width = std::max(GetStringBoundingBox(STR_TTE_INDUSTRY).width + icons_width, size->width);
+                               }
+                               break;
+                       }
+                       case MP_STATION: {
+                               const Station *st = Station::GetIfValid((StationID)this->objIndex);
+                               if(st == NULL) break;
+
+								for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+                                       if(cs == NULL) continue;
+                                       int cargoid = cs->Index();
+                                       if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+                                               size->height += line_height;
+                                               SetDParam(0, cs->name);
+                                               SetDParam(1, cargoid);
+                                               SetDParam(2, st->goods[cargoid].cargo.TotalCount());
+                                               SetDParam(3, ToPercent8(st->goods[cargoid].rating));
+                                               size->width = std::max(GetStringBoundingBox(STR_TTE_STATION).width + icons_width, size->width);
+                                       }
+                               }
+                               break;
+                       }
+                       default:
+                               break;
+               }
+               size->width  += 2 + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+               size->height += 2 + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+       }
+
+       void DrawWidget(const Rect &r, int widget) const override
+       {
+               uint icon_size = ScaleGUITrad(10);
+               uint line_height = std::max<uint>(FONT_HEIGHT_NORMAL, icon_size) + 2;
+               uint icons_width = icon_size * 3 + 10;
+               uint text_ofs = (line_height - FONT_HEIGHT_NORMAL) >> 1;
+               uint icon_ofs = (line_height - icon_size) >> 1;
+
+               GfxDrawLine(r.left,  r.top,    r.right, r.top,    PC_BLACK);
+               GfxDrawLine(r.left,  r.bottom, r.right, r.bottom, PC_BLACK);
+               GfxDrawLine(r.left,  r.top,    r.left,  r.bottom, PC_BLACK);
+               GfxDrawLine(r.right, r.top,    r.right, r.bottom, PC_BLACK);
+
+               int y = r.top + WD_FRAMERECT_TOP + 4;
+               int left = r.left + WD_FRAMERECT_LEFT + 4;
+
+               switch(this->tiletype) {
+                       case MP_HOUSE: {
+                               const HouseID house = (HouseID)this->objIndex;
+                               const HouseSpec *hs = HouseSpec::Get(house);
+
+
+                               if(hs == NULL) break;
+
+                               SetDParam(0, hs->building_name);
+                               DrawString(left, r.right - WD_FRAMERECT_RIGHT, y, STR_TTE_HOUSE_NAME, TC_BLACK, SA_CENTER);
+                               y += FONT_HEIGHT_NORMAL + 2;
+                               SetDParam(0, hs->population);
+                               DrawString(left, r.right - WD_FRAMERECT_RIGHT, y, STR_TTE_HOUSE, TC_BLACK, SA_CENTER);
+                               break;
+                       }
+                       case MP_INDUSTRY: {
+                               const Industry *ind = Industry::GetIfValid((IndustryID)this->objIndex);
+                               if(ind == NULL) break;
+
+                               SetDParam(0, ind->index);
+                               DrawString(left, r.right - WD_FRAMERECT_RIGHT, y, STR_TTE_INDUSTRY_NAME, TC_BLACK, SA_CENTER);
+                               y += FONT_HEIGHT_NORMAL + 2;
+
+                               for (CargoID i = 0; i < lengthof(ind->produced_cargo); i++) {
+                                       if (ind->produced_cargo[i] == CT_INVALID) continue;
+                                       const CargoSpec *cs = CargoSpec::Get(ind->produced_cargo[i]);
+                                       if(cs == NULL) continue;
+                                       SetDParam(0, cs->name);
+                                       SetDParam(1, cs->Index());
+                                       SetDParam(2, ind->last_month_production[i]);
+                                       SetDParam(3, ToPercent8(ind->last_month_pct_transported[i]));
+
+                                       this->DrawSpriteIcons(cs->GetCargoIcon(), left, y + icon_ofs);
+                                       DrawString(left + icons_width, r.right - WD_FRAMERECT_RIGHT, y + text_ofs, STR_TTE_INDUSTRY);
+                                       y += line_height;
+                               }
+                               break;
+                       }
+                       case MP_STATION: {
+                               const Station *st = Station::GetIfValid((StationID)this->objIndex);
+                               if(st == NULL) break;
+
+                               SetDParam(0, st->index);
+                               DrawString(left, r.right - WD_FRAMERECT_RIGHT, y, STR_TTE_STATION_NAME, TC_BLACK, SA_CENTER);
+                               y += FONT_HEIGHT_NORMAL + 2;
+
+								for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+                                       if(cs == NULL) continue;
+                                       int cargoid = cs->Index();
+                                       if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+                                               SetDParam(0, cs->name);
+                                               SetDParam(1, cargoid);
+                                               SetDParam(2, st->goods[cargoid].cargo.TotalCount());
+                                               SetDParam(3, ToPercent8(st->goods[cargoid].rating));
+                                               this->DrawSpriteIcons(cs->GetCargoIcon(), left, y + icon_ofs);
+                                               DrawString(left + icons_width, r.right - WD_FRAMERECT_RIGHT, y + text_ofs, STR_TTE_STATION);
+                                               y += line_height;
+                                       }
+                               }
+                               break;
+                       }
+                       default:
+                               break;
+               }
+       }
+
+       void OnMouseLoop() override
+       {
+               if (!_cursor.in_window) {
+                       this->Close();
+                       return;
+               }
+
+               switch (this->close_cond) {
+                       case TCC_RIGHT_CLICK: if (!_right_button_down) this->Close(); break;
+                       case TCC_HOVER: if (!_mouse_hovering) this->Close(); break;
+					   case TCC_NONE: break;
+					   default: break;
+               }
+       }
+
+       void DrawSpriteIcons(SpriteID sprite, int left, int top) const
+       {
+               uint step = ScaleGUITrad(10);
+               for(int i = 0; i < 3; i++) {
+                       DrawSprite(sprite, PAL_NONE, left + i * step, top);
+               }
+       }
+};
+
+void GuiShowTooltipsExtra(Window *parent, uint param, TooltipCloseCondition close_tooltip)
+{
+	if ((!_mouse_hovering && _settings_client.gui.hover_delay_ms > 0) ||
+			(!_right_button_down && _settings_client.gui.hover_delay_ms == 0))
+		return;
+
+	CloseWindowById(WC_TOOLTIPS_EXTRA, 0);
+	new TooltipsExtraWindow(parent, param, close_tooltip);
+}
diff --git a/src/network/network.cpp b/src/network/network.cpp
index dd0a91594..882b93432 100644
--- a/src/network/network.cpp
+++ b/src/network/network.cpp
@@ -38,6 +38,10 @@
 #include <charconv>
 #include <sstream>
 #include <iomanip>
+#include "../settings_func.h"
+#include <iostream> //std
+#include "../strings_func.h"
+#include "../base64.h"
 
 #include "../safeguards.h"
 
@@ -79,6 +83,11 @@ uint32 _sync_frame;                   ///< The frame to perform the sync check.
 bool _network_first_time;             ///< Whether we have finished joining or not.
 CompanyMask _network_company_passworded; ///< Bitmask of the password status of all companies.
 
+std::string _server_list_text;
+char* _cc_address; //current adddress
+int _cc_porti; //current port
+uint8 _fromlast = 0;
+
 static_assert((int)NETWORK_COMPANY_NAME_LENGTH == MAX_LENGTH_COMPANY_NAME_CHARS * MAX_CHAR_LENGTH);
 
 /** The amount of clients connected */
@@ -720,6 +729,214 @@ void NetworkRebuildHostList()
 	}
 }
 
+/** To handle Community connections */
+class CommunityLoginManager: public HTTPCallback {
+public:
+	//CommunityLoginManager(const char *u, const char *p): username(u), password(p) {}
+	CommunityLoginManager() {}
+
+	void initiateLoginSequence() {
+    CloseWindowByClass(WC_CC_TOKENLOGIN);
+    char uri[512];
+    const char *np;
+    std::string decoded;
+    std::string login_user;
+    const char *login_userch;
+    //IConsolePrint(CC_INFO, "INITIATING LOGIN SEQUENCE");
+    if(_settings_client.gui.community == 1){
+      decoded = urlencode(_settings_client.network.community_password[0]);
+      np = decoded.c_str();
+      login_user = _settings_client.network.community_user[0];
+      login_user = urlencode(login_user);
+      login_userch = login_user.c_str();
+      seprintf(uri, lastof(uri), "http://n-ice.org/openttd/gettoken_md5salt.php?user=%s&password=%s", login_userch, np);
+    } else if(_settings_client.gui.community == 2){
+      //decoded = base64_decode(_settings_client.network.community_password[1]);
+      decoded = _settings_client.network.community_password[1];
+      decoded = urlencode(decoded);
+      np = decoded.c_str();
+      login_user = _settings_client.network.community_user[1];
+      login_user = base64_encode(reinterpret_cast<const unsigned char*>(login_user.c_str()), login_user.length());
+      login_user = urlencode(login_user);
+      login_userch = login_user.c_str();
+      seprintf(uri, lastof(uri), "https://openttd.btpro.nl/gettoken-enc.php?user=%s&password=%s", login_userch, np);
+      //NetworkClientSendChat(NETWORK_ACTION_CHAT_CLIENT, DESTTYPE_CLIENT, CLIENT_ID_SERVER , uri);  // only to see result on testings
+    }
+    std::cout << "sending to http server: " << uri << std::endl;
+    this->cursor = this->buf;
+    NetworkHTTPSocketHandler::Connect(uri, this);
+	}
+
+	void sendLoginString() {
+    char b[16];
+    seprintf(b, lastof(b), "!login %s", this->buf);
+    NetworkClientSendChat(NETWORK_ACTION_CHAT_CLIENT, DESTTYPE_CLIENT, CLIENT_ID_SERVER , b);
+	}
+
+	void inspectLoginData() {
+    //IConsolePrint(CC_INFO, "INSPECTING DATA");
+    if (this->cursor - this->buf == 4) {
+      this->sendLoginString();
+      //IConsolePrint( CC_INFO, "*** Community Authentification successful ***");
+    } else {
+      //IConsolePrint(CC_ERROR, b);
+      ShowErrorMessage(STR_CC_OTHER_TOKEN_LOGIN_ERROR, INVALID_STRING_ID, WL_ERROR);
+    }
+	}
+
+	virtual void OnFailure() {
+    //std::cout << "*** UNABLE TO RETRIEVE LOGIN TOKEN FROM HTTP SERVER ***" << std::endl;
+    ShowErrorMessage(STR_CC_OTHER_TOKEN_CONNECT_ERROR, INVALID_STRING_ID, WL_ERROR);
+	}
+
+	virtual void OnReceiveData( const char *data, size_t length) {
+    size_t i = length;
+
+    if (data == 0) {
+      std::cout << "*** RECEIVED ALL HTTP DATA ***" << std::endl;
+      this->inspectLoginData();
+      this->cursor = 0;
+    } else {
+      std::cout << "*** RECEIVING HTTP DATA ***" << std::endl;
+      while ( this->cursor - this->buf < 512 && i) {
+        *this->cursor = *data;
+        data++;
+        this->cursor++;
+        i--;
+      }
+      if (this->cursor - this->buf >= 512)
+        this->buf[511] = 0;
+      else
+        *this->cursor = 0;
+    }
+	}
+
+  std::string urlencode(const std::string &s)
+  {
+    //RFC 3986 section 2.3 Unreserved Characters (January 2005)
+    const std::string unreserved = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.~";
+
+    std::string escaped="";
+    for(size_t i=0; i<s.length(); i++)
+    {
+        if (unreserved.find_first_of(s[i]) != std::string::npos)
+        {
+            escaped.push_back(s[i]);
+        }
+        else
+        {
+            escaped.append("%");
+            char buf[3];
+            seprintf(buf, lastof(buf), "%.2X", s[i]);
+            escaped.append(buf);
+        }
+    }
+    return escaped;
+  }
+
+private:
+	NetworkHTTPContentConnecter *conn;
+	char buf[512];
+	char	 *cursor;
+};
+
+static CommunityLoginManager loginmgr;
+
+void CommunityLoginManagerSend()
+{
+  loginmgr.initiateLoginSequence();
+}
+
+/** To handle Community Server list */
+class CommunityServerManager: public HTTPCallback {
+public:
+	CommunityServerManager() {}
+
+	void initiateServerSequence() {
+    char uri[512];
+    //IConsolePrint(CC_INFO, "INITIATING LOGIN SEQUENCE");
+    if(_settings_client.gui.community == 1){
+      seprintf(uri, lastof(uri), "http://n-ice.org/openttd/serverlist.txt");
+    } else if(_settings_client.gui.community == 2){
+      seprintf(uri, lastof(uri), "https://openttd.btpro.nl/btproservers.txt");
+    }
+    std::cout << "sending to http server: " << uri << std::endl;
+    this->cursor = this->buf;
+    NetworkHTTPSocketHandler::Connect(uri, this);
+	}
+
+	void SaveServerString() {
+    int tmpversion;
+    _server_list_text += this->buf;
+
+      if(_settings_client.gui.community == 2){
+        size_t posver = _server_list_text.find("bt.version.check:");
+        std::string saver = _server_list_text.substr(posver + 18, _server_list_text.find(";", posver + 18) - posver - 18);
+        tmpversion = atoi(saver.c_str());
+        _settings_client.gui.btpro_version = tmpversion;
+        SaveToConfig();
+      }
+	}
+
+  void inspectServerData() {
+    //IConsolePrint(CC_INFO, "INSPECTING DATA");
+    if (this->cursor - this->buf >= 4) {
+      this->SaveServerString();
+
+    } else {
+      ShowErrorMessage(STR_CC_OTHER_TOKEN_CONNECT_ERROR, INVALID_STRING_ID, WL_ERROR);
+    }
+	}
+
+	virtual void OnFailure() {
+    //std::cout << "*** UNABLE TO RETRIEVE LOGIN TOKEN FROM HTTP SERVER ***" << std::endl;
+    ShowErrorMessage(STR_CC_OTHER_TOKEN_CONNECT_ERROR, INVALID_STRING_ID, WL_ERROR);
+	}
+
+	virtual void OnReceiveData(const char *data, size_t length)
+	{
+		extern void ShowSelectGameWindow();
+		size_t i = length;
+
+		if (data == 0)
+		{
+			std::cout << "*** RECEIVED ALL HTTP DATA ***" << std::endl;
+
+			this->inspectServerData();
+
+			CloseWindowByClass(WC_SELECT_GAME);
+			/* If we are still in the menu reopen it */
+			if (_game_mode == GM_MENU) ShowSelectGameWindow();
+			this->cursor = 0;
+		} else {
+			std::cout << "*** RECEIVING HTTP DATA ***" << std::endl;
+			while (this->cursor - this->buf < 4096 && i)
+			{
+				*this->cursor = *data;
+				data++;
+				this->cursor++;
+				i--;
+			}
+			if (this->cursor - this->buf >= 4096)
+				this->buf[4095] = 0;
+			else
+				*this->cursor = 0;
+		}
+	}
+
+private:
+	NetworkHTTPContentConnecter *conn;
+	char buf[4096];
+	char	 *cursor;
+};
+
+static CommunityServerManager servermgr;
+
+void CommunityServerManagerSend()
+{
+  servermgr.initiateServerSequence();
+}
+
 /** Non blocking connection create to actually connect to servers */
 class TCPClientConnecter : TCPServerConnecter {
 private:
@@ -1277,6 +1494,66 @@ void NetworkShutDown()
 	NetworkCoreShutdown();
 }
 
+void GetCommunityServerListText(uint8 from){
+	if(_fromlast == _settings_client.gui.community || _settings_client.gui.community == 0) return;
+	_fromlast = _settings_client.gui.community;
+
+  _server_list_text.clear();
+
+  CommunityServerManagerSend();
+
+}
+
+bool GetCommunityServer(int number, bool findonly) {
+  //IConsolePrintF(CC_INFO, "Buf: %s", _server_list_text.c_str());
+	if(_server_list_text.empty()) return false;
+	_cc_address = NULL;
+
+	char server[32];
+	char port[16];
+
+	if(number < 10){
+		seprintf(server, lastof(server), "SERVER0%i", number);
+		seprintf(port, lastof(port), "PORT0%i", number);
+	}
+	else{
+		seprintf(server, lastof(server), "SERVER%i", number);
+		seprintf(port, lastof(port), "PORT%i", number);
+	}
+
+	size_t posaddress = _server_list_text.find(server);
+	size_t posport = _server_list_text.find(port);
+
+	if(posaddress != std::string::npos && posport != std::string::npos){
+		std::string saddress = _server_list_text.substr(posaddress + 10, _server_list_text.find(";", posaddress + 10) - posaddress - 10);
+		std::string sport = _server_list_text.substr(posport + 8, posport + 12);
+
+		//IConsolePrintF(CC_DEFAULT, "server: '%s'", saddress.c_str());
+		if(saddress.compare("DISABLED") == 0) return false;
+		else if(findonly) return true;
+
+		_cc_address = stredup(saddress.c_str(), nullptr);
+		_cc_porti = std::stoi(sport);
+		return true;
+	}
+	else if(findonly) return false;
+	ShowErrorMessage(STR_CC_SERVER_LIST_ERROR_FILE, INVALID_STRING_ID, WL_ERROR);
+	return false;
+}
+
+void SetClipboardInfo(char *output) {
+  #ifdef WIN32
+    const size_t len = strlen(output) + 1;
+    HGLOBAL hMem =  GlobalAlloc(GMEM_MOVEABLE, len);
+    memcpy(GlobalLock(hMem), output, len);
+    GlobalUnlock(hMem);
+    OpenClipboard(0);
+    EmptyClipboard();
+    SetClipboardData(CF_TEXT, hMem);
+    CloseClipboard();
+  #endif
+}
+
 #ifdef __EMSCRIPTEN__
 extern "C" {
 
diff --git a/src/network/network.h b/src/network/network.h
index 1de0da3a8..cb628b994 100644
--- a/src/network/network.h
+++ b/src/network/network.h
@@ -6,7 +6,7 @@
  */
 
 /** @file network.h Basic functions/variables used all over the place. */
-
+#include <iomanip>  //string
 #ifndef NETWORK_H
 #define NETWORK_H
 
@@ -15,10 +15,21 @@ void NetworkShutDown();
 void NetworkDrawChatMessage();
 bool HasClients();
 
+//void initiateLoginSequence();
+void CommunityLoginManagerSend();
+void CommunityServerManagerSend();
+
 extern bool _networking;         ///< are we in networking mode?
 extern bool _network_server;     ///< network-server is active
 extern bool _network_available;  ///< is network mode available?
 extern bool _network_dedicated;  ///< are we a dedicated server?
 extern bool _is_network_server;  ///< Does this client wants to be a network-server?
 
+extern std::string _server_list_text;  //string with servers status
+extern char* _cc_address; //current adddress
+extern int _cc_porti; //current port
+extern uint8 _fromlast;
+void GetCommunityServerListText(uint8 from = 0);
+bool GetCommunityServer(int number, bool findonly = false);
+
 #endif /* NETWORK_H */
diff --git a/src/network/network_client.cpp b/src/network/network_client.cpp
index f03601b39..3d5598bd8 100644
--- a/src/network/network_client.cpp
+++ b/src/network/network_client.cpp
@@ -23,12 +23,14 @@
 #include "../gfx_func.h"
 #include "../error.h"
 #include "../rev.h"
+#include "core/game_info.h"
 #include "network.h"
 #include "network_base.h"
 #include "network_client.h"
 #include "network_gamelist.h"
 #include "../core/backup_type.hpp"
 #include "../thread.h"
+#include "../commands_token_gui.h"
 
 #include "table/strings.h"
 
@@ -581,6 +583,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_CLIENT_INFO(Pac
 		ci->client_name = name;
 
 		InvalidateWindowData(WC_CLIENT_LIST, 0);
+		InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+		SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 		return NETWORK_RECV_STATUS_OKAY;
 	}
@@ -600,6 +604,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_CLIENT_INFO(Pac
 	ci->client_name = name;
 
 	InvalidateWindowData(WC_CLIENT_LIST, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+	SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 	return NETWORK_RECV_STATUS_OKAY;
 }
@@ -996,6 +1002,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_ERROR_QUIT(Pack
 	}
 
 	InvalidateWindowData(WC_CLIENT_LIST, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+	SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 	return NETWORK_RECV_STATUS_OKAY;
 }
@@ -1015,6 +1023,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_QUIT(Packet *p)
 	}
 
 	InvalidateWindowData(WC_CLIENT_LIST, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+	SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 	/* If we come here it means we could not locate the client.. strange :s */
 	return NETWORK_RECV_STATUS_OKAY;
@@ -1032,6 +1042,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_JOIN(Packet *p)
 	}
 
 	InvalidateWindowData(WC_CLIENT_LIST, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+	SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 	return NETWORK_RECV_STATUS_OKAY;
 }
@@ -1115,6 +1127,27 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_CONFIG_UPDATE(P
 	_network_server_max_companies = p->Recv_uint8();
 	_network_server_name = p->Recv_string(NETWORK_NAME_LENGTH);
 
+	Debug(net, 1, "Got server name {}. Updating community", _network_server_name);
+
+	if (_network_server_name.find("n-ice.org") != std::string::npos) {
+		if(_settings_client.gui.community != 1) {
+			_settings_client.gui.community = 1;
+			GetCommunityServerListText();
+		}
+		Debug(net, 2, "joined n-ice \"{}\"", _settings_client.gui.community);
+	} else if (_network_server_name.find("BTPro.nl") != std::string::npos) {
+		if (_settings_client.gui.community != 2) {
+			_settings_client.gui.community = 2;
+			GetCommunityServerListText();
+		}
+		Debug(net, 2, "joined BTpro \"{}\"", _settings_client.gui.community);
+	}
+	else { // Unknown Server
+		_settings_client.gui.community = 0;
+	}
+
+	if(_settings_client.gui.community != 0) ShowTokenLogin();
+
 	return NETWORK_RECV_STATUS_OKAY;
 }
 
diff --git a/src/network/network_gui.cpp b/src/network/network_gui.cpp
index 9b3ff09a6..44c217f23 100644
--- a/src/network/network_gui.cpp
+++ b/src/network/network_gui.cpp
@@ -48,6 +48,8 @@
 #	include <emscripten.h>
 #endif
 
+#include "../commands_token_gui.h"
+
 #include <map>
 
 #include "../safeguards.h"
@@ -486,6 +488,9 @@ public:
 
 		this->querystrings[WID_NG_FILTER] = &this->filter_editbox;
 		this->filter_editbox.cancel_button = QueryString::ACTION_CLEAR;
+		//if community is chosen, filter by default
+		if(_settings_client.gui.community == 1) this->filter_editbox.text.Assign("n-ice");
+		else if(_settings_client.gui.community == 2) this->filter_editbox.text.Assign("BTPro");
 		this->SetFocusedWidget(WID_NG_FILTER);
 
 		/* As the Game Coordinator doesn't support "websocket" servers yet, we
@@ -803,6 +808,24 @@ public:
 			case WID_NG_NEWGRF_MISSING: // Find missing content online
 				if (this->server != nullptr) ShowMissingContentWindow(this->server->info.grfconfig);
 				break;
+
+			case WID_NG_CC_NICE:
+			case WID_NG_CC_BTPRO:
+			case WID_NG_CC_REDDIT:
+			case WID_NG_CC_CITYMANIA:
+				if(!this->searched_internet){
+					_network_coordinator_client.GetListing();
+					this->searched_internet = true;
+				}
+				if(widget == WID_NG_CC_NICE) this->filter_editbox.text.Assign("n-ice");
+				else if(widget == WID_NG_CC_BTPRO) this->filter_editbox.text.Assign("BTPro");
+				else if(widget == WID_NG_CC_REDDIT) this->filter_editbox.text.Assign("reddit");
+				else if(widget == WID_NG_CC_CITYMANIA) this->filter_editbox.text.Assign("CityMania");
+				this->servers.ForceRebuild();
+				this->BuildGUINetworkGameList();
+				this->ScrollToSelectedServer();
+				this->SetDirty();
+				break;
 		}
 	}
 
@@ -922,6 +945,13 @@ static const NWidgetPart _nested_network_game_widgets[] = {
 			NWidget(NWID_HORIZONTAL), SetPIP(10, 7, 10),
 				/* LEFT SIDE */
 				NWidget(NWID_VERTICAL), SetPIP(0, 7, 0),
+					NWidget(NWID_HORIZONTAL), SetPIP(0, 7, 0),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_WHITE, WID_NG_CC_REDDIT), SetFill(1, 0), SetDataTip(STR_NETWORK_CC_SELECT_REDDIT, STR_NETWORK_CC_SELECT_REDDIT_TOOLTIP),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_WHITE, WID_NG_CC_CITYMANIA), SetFill(1, 0), SetDataTip(STR_NETWORK_CC_SELECT_CITYMANIA, STR_NETWORK_CC_SELECT_CITYMANIA_TOOLTIP),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_WHITE, WID_NG_CC_NICE), SetFill(1, 0), SetDataTip(STR_NETWORK_CC_SELECT_NICE, STR_NETWORK_CC_SELECT_NICE_TOOLTIP),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_WHITE, WID_NG_CC_BTPRO), SetFill(1, 0), SetDataTip(STR_NETWORK_CC_SELECT_BTPRO, STR_NETWORK_CC_SELECT_BTPRO_TOOLTIP),
+						NWidget(NWID_SPACER), SetFill(1, 0), SetResize(1, 0),
+					EndContainer(),
 					NWidget(NWID_HORIZONTAL), SetPIP(0, 7, 0),
 						NWidget(WWT_TEXT, COLOUR_LIGHT_BLUE, WID_NG_FILTER_LABEL), SetDataTip(STR_LIST_FILTER_TITLE, STR_NULL),
 						NWidget(WWT_EDITBOX, COLOUR_LIGHT_BLUE, WID_NG_FILTER), SetMinimalSize(251, 12), SetFill(1, 0), SetResize(1, 0),
@@ -1334,6 +1364,9 @@ static const NWidgetPart _nested_client_list_widgets[] = {
 				NWidget(WWT_TEXT, COLOUR_GREY, WID_CL_CLIENT_NAME), SetFill(1, 0), SetMinimalTextLines(1, 0), SetResize(1, 0), SetDataTip(STR_BLACK_RAW_STRING, STR_NETWORK_CLIENT_LIST_PLAYER_NAME_TOOLTIP), SetAlignment(SA_VERT_CENTER | SA_RIGHT),
 				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_CL_CLIENT_NAME_EDIT), SetMinimalSize(12, 14), SetDataTip(SPR_RENAME, STR_NETWORK_CLIENT_LIST_PLAYER_NAME_EDIT_TOOLTIP),
 			EndContainer(),
+			NWidget(NWID_HORIZONTAL), SetPIP(0, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_DARK_BLUE, WID_CL_CLIENT_TOKEN_LOGIN), SetMinimalSize(12, 16), SetFill(1, 0), SetDataTip(STR_NETWORK_CLIENT_LIST_GET_TOKEN, STR_NULL),
+			EndContainer(),
 		EndContainer(),
 		NWidget(NWID_HORIZONTAL),
 			NWidget(NWID_VERTICAL),
@@ -1805,6 +1838,13 @@ public:
 				ShowDropDownList(this, BuildVisibilityDropDownList(), _settings_client.network.server_game_type, WID_CL_SERVER_VISIBILITY);
 				break;
 
+			case WID_CL_CLIENT_TOKEN_LOGIN: {
+				if (_settings_client.gui.community != 0)
+					Debug(net, 2, "Request Token form client list");
+					CommunityLoginManagerSend();
+				break;
+			}
+
 			case WID_CL_MATRIX: {
 				ButtonCommon *button = this->GetButtonAtPoint(pt);
 				if (button == nullptr) break;
diff --git a/src/openttd.cpp b/src/openttd.cpp
index 189010aad..17f534573 100644
--- a/src/openttd.cpp
+++ b/src/openttd.cpp
@@ -72,7 +72,10 @@
 #include <stdarg.h>
 #include <system_error>
 
-#include "safeguards.h"
+//#include "safeguards.h"
+
+#include "../openttd_cuda/openttd_cuda_dll.h"
+
 
 #ifdef __EMSCRIPTEN__
 #	include <emscripten.h>
@@ -522,6 +525,12 @@ static const OptionData _options[] = {
  */
 int openttd_main(int argc, char *argv[])
 {
+	if (OpenTTDCuda::OpenTTDCuda::init()) {
+		printf("cuda enabled\r\n");
+	} else {
+	    printf("cuda disabled\r\n");
+	}
+
 	std::string musicdriver;
 	std::string sounddriver;
 	std::string videodriver;
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index f282ca12b..a20bfd874 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -255,11 +255,13 @@ void InvalidateVehicleOrder(const Vehicle *v, int data)
 		/* Calls SetDirty() too */
 		InvalidateWindowData(WC_VEHICLE_ORDERS,    v->index, data);
 		InvalidateWindowData(WC_VEHICLE_TIMETABLE, v->index, data);
+		InvalidateWindowData(WC_VEHICLE_TRIP_HISTORY, v->index, data);
 		return;
 	}
 
 	SetWindowDirty(WC_VEHICLE_ORDERS,    v->index);
 	SetWindowDirty(WC_VEHICLE_TIMETABLE, v->index);
+	SetWindowDirty(WC_VEHICLE_TRIP_HISTORY, v->index);
 }
 
 /**
diff --git a/src/order_gui.cpp b/src/order_gui.cpp
index 3205be166..c0f045fd0 100644
--- a/src/order_gui.cpp
+++ b/src/order_gui.cpp
@@ -26,11 +26,13 @@
 #include "waypoint_base.h"
 #include "core/geometry_func.hpp"
 #include "hotkeys.h"
+#include "order_type.h"
 #include "aircraft.h"
 #include "engine_func.h"
 #include "vehicle_func.h"
 
 #include "widgets/order_widget.h"
+#include <math.h>
 
 #include "safeguards.h"
 
@@ -172,6 +174,78 @@ static const StringID _order_conditional_condition[] = {
 	INVALID_STRING_ID,
 };
 
+struct OrdersFromSettings
+{
+	enum OrderUnloadFlags unload;
+	enum OrderLoadFlags   load;
+};
+
+typedef enum {
+	GOFS_NONE = 0,
+	GOFS_FULL,
+	GOFS_XFER,
+	GOFS_UNLOAD,
+	GOFS_FEEDLOAD,
+	GOFS_FEEDUNLOAD,
+	GOFS_NOLOAD
+} GetOrderFromSettingsTypes;
+
+static enum {
+	GOFS_FEEDER_NULL,
+	GOFS_FEEDER_LOAD,
+	GOFS_FEEDER_UNLOAD
+} gofsfeeder_ordermod = GOFS_FEEDER_NULL;
+
+#define GOFSFEEDER_ORDERMOD_RESET gofsfeeder_ordermod = GOFS_FEEDER_NULL
+
+
+/* fetch and compute orders set from settings */
+
+static void GetOrdersFromSettings(const Vehicle *v, uint8 setting, struct OrdersFromSettings *rv)
+{
+	rv->load = (enum OrderLoadFlags)-1;
+	rv->unload = (enum OrderUnloadFlags)-1;
+
+	switch(setting) {
+
+	case GOFS_FEEDLOAD:
+		if (v->GetNumOrders()) gofsfeeder_ordermod = GOFS_FEEDER_LOAD;
+		rv->unload = OUFB_NO_UNLOAD;
+		rv->load = OLF_FULL_LOAD_ANY;
+		break;
+	case GOFS_FULL:
+		rv->load = OLF_FULL_LOAD_ANY;
+		break;
+
+	case GOFS_UNLOAD:
+		rv->unload = OUFB_UNLOAD;
+		if (_settings_client.gui.auto_noload_on_unloadall)
+			rv->load = OLFB_NO_LOAD;
+		break;
+
+	case GOFS_FEEDUNLOAD:
+		if (v->GetNumOrders()) gofsfeeder_ordermod = GOFS_FEEDER_UNLOAD;
+		rv->unload = OUFB_TRANSFER;
+		rv->load = OLFB_NO_LOAD;
+		break;
+
+	case GOFS_XFER:
+		rv->unload = OUFB_TRANSFER;
+		if (_settings_client.gui.auto_noload_on_transfer)
+			rv->load = OLFB_NO_LOAD;
+		break;
+
+	case GOFS_NOLOAD:
+		rv->load = OLFB_NO_LOAD;
+		break;
+
+	case GOFS_NONE:
+		break;
+
+	default: NOT_REACHED();
+	}
+}
+
 extern uint ConvertSpeedToDisplaySpeed(uint speed);
 extern uint ConvertDisplaySpeedToSpeed(uint speed);
 
@@ -348,6 +422,19 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 	}
 
 	DrawString(rtl ? left : middle, rtl ? middle : right, y, STR_ORDER_TEXT, colour);
+
+  uint order_dist_sq = 0;
+	uint order_dist_mh = 0;
+	const Order *next2 = order->next != NULL ? order->next : v->GetFirstOrder();
+	TileIndex prev_tile = order->GetLocation(v, true);
+	TileIndex cur_tile = next2->GetLocation(v, true);
+	if (prev_tile != INVALID_TILE && cur_tile != INVALID_TILE){
+		order_dist_sq = IntSqrt(DistanceSquare(prev_tile, cur_tile));
+		order_dist_mh = DistanceManhattan(prev_tile, cur_tile);
+	}
+	SetDParam(0, order_dist_sq);
+	SetDParam(1, order_dist_mh);
+	DrawString(middle, right, y, STR_ORDER_DIST, TC_WHITE, SA_RIGHT);
 }
 
 /**
@@ -411,7 +498,34 @@ static Order GetOrderCmdFromTile(const Vehicle *v, TileIndex tile)
 			}
 			if (st->facilities & facil) {
 				order.MakeGoToStation(st->index);
-				if (_ctrl_pressed) order.SetLoadType(OLF_FULL_LOAD_ANY);
+
+				uint8 os = 0xff;
+				if (_ctrl_pressed) {
+					if (_shift_pressed)
+						os = _settings_client.gui.goto_shortcuts_ctrlshift_lclick;
+					else if (_alt_pressed)
+						os = _settings_client.gui.goto_shortcuts_altctrl_lclick;
+					else
+						os = _settings_client.gui.goto_shortcuts_ctrl_lclick;
+				}
+				else if (_shift_pressed) {
+					if (_alt_pressed)
+						os = _settings_client.gui.goto_shortcuts_altshift_lclick;
+					else
+						os = _settings_client.gui.goto_shortcuts_shift_lclick;
+				}
+				else if (_alt_pressed)
+					os = _settings_client.gui.goto_shortcuts_alt_lclick;
+
+				if (os != 0xff) {
+					struct OrdersFromSettings ofs;
+					GetOrdersFromSettings(v, os, &ofs);
+					if (ofs.load != (enum OrderLoadFlags)-1)
+						order.SetLoadType(ofs.load);
+					if (ofs.unload != (enum OrderUnloadFlags)-1)
+					order.SetUnloadType(ofs.unload);
+				}
+
 				if (_settings_client.gui.new_nonstop && v->IsGroundVehicle()) order.SetNonStopType(ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS);
 				order.SetStopLocation(v->type == VEH_TRAIN ? (OrderStopLocation)(_settings_client.gui.stop_location) : OSL_PLATFORM_FAR_END);
 				return order;
@@ -437,6 +551,7 @@ enum {
 	OHK_TRANSFER,
 	OHK_NO_UNLOAD,
 	OHK_NO_LOAD,
+	OHK_CLOSE,
 };
 
 /**
@@ -643,8 +758,14 @@ private:
 
 		DoCommandP(this->vehicle->tile, this->vehicle->index + (sel_ord << 20), MOF_UNLOAD | (unload_type << 4), CMD_MODIFY_ORDER | CMD_MSG(STR_ERROR_CAN_T_MODIFY_THIS_ORDER));
 
-		/* Transfer and unload orders with leave empty as default */
-		if (unload_type == OUFB_TRANSFER || unload_type == OUFB_UNLOAD) {
+    	bool set_no_load = false;
+		if (unload_type == OUFB_TRANSFER)
+			set_no_load = _settings_client.gui.auto_noload_on_transfer;
+		else if (unload_type == OUFB_UNLOAD)
+			set_no_load = _settings_client.gui.auto_noload_on_unloadall;
+
+		/* Transfer orders with leave empty as default */
+		if (set_no_load) {
 			DoCommandP(this->vehicle->tile, this->vehicle->index + (sel_ord << 20), MOF_LOAD | (OLFB_NO_LOAD << 4), CMD_MODIFY_ORDER);
 			this->SetWidgetDirty(WID_O_FULL_LOAD);
 		}
@@ -1414,6 +1535,11 @@ public:
 	EventState OnHotkey(int hotkey) override
 	{
 		if (this->vehicle->owner != _local_company) return ES_NOT_HANDLED;
+		if(hotkey == OHK_GOTO && this->goto_type != OPOS_NONE){
+			this->RaiseWidget(WID_O_GOTO);
+			ResetObjectToPlace();
+			return ES_NOT_HANDLED;
+		}
 
 		switch (hotkey) {
 			case OHK_SKIP:           this->OrderClick_Skip(); break;
@@ -1427,6 +1553,7 @@ public:
 			case OHK_TRANSFER:       this->OrderClick_Unload(OUFB_TRANSFER, true); break;
 			case OHK_NO_UNLOAD:      this->OrderClick_Unload(OUFB_NO_UNLOAD, true); break;
 			case OHK_NO_LOAD:        this->OrderClick_FullLoad(OLFB_NO_LOAD, true); break;
+			case OHK_CLOSE:          this->Close(); break;
 			default: return ES_NOT_HANDLED;
 		}
 		return ES_HANDLED;
@@ -1438,7 +1565,21 @@ public:
 			const Order cmd = GetOrderCmdFromTile(this->vehicle, tile);
 			if (cmd.IsType(OT_NOTHING)) return;
 
-			if (DoCommandP(this->vehicle->tile, this->vehicle->index + (this->OrderGetSel() << 20), cmd.Pack(), CMD_INSERT_ORDER | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER))) {
+			if (gofsfeeder_ordermod != GOFS_FEEDER_NULL) {
+				if (gofsfeeder_ordermod == GOFS_FEEDER_LOAD) {
+					if (DoCommandP(this->vehicle->tile, this->vehicle->index + ((1) << 20), cmd.Pack(), CMD_INSERT_ORDER | CMD_NO_ESTIMATE | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER))) {
+						DoCommandP(this->vehicle->tile, this->vehicle->index,  0, CMD_DELETE_ORDER |  CMD_NO_ESTIMATE | CMD_MSG(STR_ERROR_CAN_T_DELETE_THIS_ORDER));
+					}
+
+				}
+				else if (gofsfeeder_ordermod == GOFS_FEEDER_UNLOAD) { // still flushes the whole order table
+					if (DoCommandP(this->vehicle->tile, this->vehicle->index + ((this->vehicle->GetNumOrders()) << 20), cmd.Pack(), CMD_INSERT_ORDER | CMD_NO_ESTIMATE | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER))) {
+						DoCommandP(this->vehicle->tile, this->vehicle->index, (this->vehicle->GetNumOrders()-2+(int)_networking) , CMD_DELETE_ORDER | CMD_NO_ESTIMATE | CMD_MSG(STR_ERROR_CAN_T_DELETE_THIS_ORDER));
+					}
+				}
+				gofsfeeder_ordermod = GOFS_FEEDER_NULL;
+			}
+			else if (DoCommandP(this->vehicle->tile, this->vehicle->index + (this->OrderGetSel() << 20), cmd.Pack(), CMD_INSERT_ORDER |  CMD_NO_ESTIMATE | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER))) {
 				/* With quick goto the Go To button stays active */
 				if (!_settings_client.gui.quick_goto) ResetObjectToPlace();
 			}
@@ -1516,6 +1657,7 @@ static Hotkey order_hotkeys[] = {
 	Hotkey((uint16)0, "transfer", OHK_TRANSFER),
 	Hotkey((uint16)0, "no_unload", OHK_NO_UNLOAD),
 	Hotkey((uint16)0, "no_load", OHK_NO_LOAD),
+	Hotkey('Q', "close", OHK_CLOSE),
 	HOTKEY_LIST_END
 };
 HotkeyList OrdersWindow::hotkeys("order", order_hotkeys);
diff --git a/src/rail_cmd.cpp b/src/rail_cmd.cpp
index 59c1d27ab..a0150c93f 100644
--- a/src/rail_cmd.cpp
+++ b/src/rail_cmd.cpp
@@ -44,6 +44,7 @@ typedef std::vector<Train *> TrainList;
 RailtypeInfo _railtypes[RAILTYPE_END];
 std::vector<RailType> _sorted_railtypes;
 RailTypes _railtypes_hidden_mask;
+TileIndex _rail_track_endtile; ///< The end of a rail track; as hidden return from the rail build/remove command for GUI purposes.
 
 /** Enum holding the signal offset in the sprite sheet according to the side it is representing. */
 enum SignalOffsets {
@@ -610,6 +611,7 @@ CommandCost CmdBuildSingleRail(TileIndex tile, DoCommandFlag flags, uint32 p1, u
 	}
 
 	cost.AddCost(RailBuildCost(railtype));
+	_rail_track_endtile = tile;
 	return cost;
 }
 
@@ -757,6 +759,7 @@ CommandCost CmdRemoveSingleRail(TileIndex tile, DoCommandFlag flags, uint32 p1,
 		if (v != nullptr) TryPathReserve(v, true);
 	}
 
+	_rail_track_endtile = tile;
 	return cost;
 }
 
@@ -2616,6 +2619,8 @@ static void TileLoop_Track(TileIndex tile)
 	RailGroundType old_ground = GetRailGroundType(tile);
 	RailGroundType new_ground;
 
+	ReduceStuckCounter(tile);
+
 	if (old_ground == RAIL_GROUND_WATER) {
 		TileLoop_Water(tile);
 		return;
diff --git a/src/rail_gui.cpp b/src/rail_gui.cpp
index 7c2ed33e2..addb51ca4 100644
--- a/src/rail_gui.cpp
+++ b/src/rail_gui.cpp
@@ -54,6 +54,8 @@ static bool _convert_signal_button;          ///< convert signal button in the s
 static SignalVariant _cur_signal_variant;    ///< set the signal variant (for signal GUI)
 static SignalType _cur_signal_type;          ///< set the signal type (for signal GUI)
 
+extern TileIndex _rail_track_endtile; // rail_cmd.cpp
+
 struct RailStationGUISettings {
 	Axis orientation;                 ///< Currently selected rail station orientation
 
@@ -90,9 +92,9 @@ void CcPlaySound_CONSTRUCTION_RAIL(const CommandCost &result, TileIndex tile, ui
 	if (result.Succeeded() && _settings_client.sound.confirm) SndPlayTileFx(SND_20_CONSTRUCTION_RAIL, tile);
 }
 
-static void GenericPlaceRail(TileIndex tile, int cmd)
+static bool GenericPlaceRail(TileIndex tile, Track track)
 {
-	DoCommandP(tile, _cur_railtype, cmd | (_settings_client.gui.auto_remove_signals << 3),
+	return DoCommandP(tile, _cur_railtype, track | (_settings_client.gui.auto_remove_signals << 3),
 			_remove_button_clicked ?
 			CMD_REMOVE_SINGLE_RAIL | CMD_MSG(STR_ERROR_CAN_T_REMOVE_RAILROAD_TRACK) :
 			CMD_BUILD_SINGLE_RAIL | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK),
@@ -283,6 +285,7 @@ void CcBuildRailTunnel(const CommandCost &result, TileIndex tile, uint32 p1, uin
 	if (result.Succeeded()) {
 		if (_settings_client.sound.confirm) SndPlayTileFx(SND_20_CONSTRUCTION_RAIL, tile);
 		if (!_settings_client.gui.persistent_buildingtools) ResetObjectToPlace();
+		StoreRailPlacementEndpoints(tile, _build_tunnel_endtile, TileX(tile) == TileX(_build_tunnel_endtile) ? TRACK_Y : TRACK_X, false);
 	} else {
 		SetRedErrorSquare(_build_tunnel_endtile);
 	}
@@ -312,7 +315,7 @@ static bool RailToolbar_CtrlChanged(Window *w)
 
 	/* allow ctrl to switch remove mode only for these widgets */
 	for (uint i = WID_RAT_BUILD_NS; i <= WID_RAT_BUILD_STATION; i++) {
-		if ((i <= WID_RAT_AUTORAIL || i >= WID_RAT_BUILD_WAYPOINT) && w->IsWidgetLowered(i)) {
+		if ((i <= WID_RAT_POLYRAIL || i >= WID_RAT_BUILD_WAYPOINT) && w->IsWidgetLowered(i)) {
 			ToggleRailButton_Remove(w);
 			return true;
 		}
@@ -356,10 +359,10 @@ static void BuildRailClick_Remove(Window *w)
 	}
 }
 
-static void DoRailroadTrack(int mode)
+static bool DoRailroadTrack(TileIndex start_tile, TileIndex end_tile, Track track)
 {
-	uint32 p2 = _cur_railtype | (mode << 6) | (_settings_client.gui.auto_remove_signals << 11);
-	DoCommandP(TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y), p2,
+	uint32 p2 = _cur_railtype | (track << 6) | (_settings_client.gui.auto_remove_signals << 11);
+	return DoCommandP(start_tile, end_tile, p2,
 			_remove_button_clicked ?
 			CMD_REMOVE_RAILROAD_TRACK | CMD_MSG(STR_ERROR_CAN_T_REMOVE_RAILROAD_TRACK) :
 			CMD_BUILD_RAILROAD_TRACK  | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK),
@@ -368,14 +371,14 @@ static void DoRailroadTrack(int mode)
 
 static void HandleAutodirPlacement()
 {
-	int trackstat = _thd.drawstyle & HT_DIR_MASK; // 0..5
+	Track track = (Track)(_thd.drawstyle & HT_DIR_MASK); // 0..5
+	TileIndex start_tile = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
+	TileIndex end_tile = TileVirtXY(_thd.selend.x, _thd.selend.y);
 
-	if (_thd.drawstyle & HT_RAIL) { // one tile case
-		GenericPlaceRail(TileVirtXY(_thd.selend.x, _thd.selend.y), trackstat);
-		return;
+	if ((_thd.drawstyle & HT_RAIL ? GenericPlaceRail(end_tile, track) : DoRailroadTrack(start_tile, end_tile, track))
+			&& !_shift_pressed) {
+		StoreRailPlacementEndpoints(start_tile, _rail_track_endtile, track, true);
 	}
-
-	DoRailroadTrack(trackstat);
 }
 
 /**
@@ -422,6 +425,73 @@ static void HandleAutoSignalPlacement()
 }
 
 
+// FIXME duplicate from road_gui.cpp
+static DiagDirection TileFractCoordsToDiagDir() {
+	bool diag = (_tile_fract_coords.x + _tile_fract_coords.y) < 16;
+	if (_tile_fract_coords.x < _tile_fract_coords.y) {
+		return diag ? DIAGDIR_NE : DIAGDIR_SE;
+	}
+	return diag ? DIAGDIR_NW : DIAGDIR_SW;
+}
+
+// FIXME duplicate from road_gui.cpp
+static DiagDirection RoadBitsToDiagDir(RoadBits bits) {
+	if (bits < ROAD_SE) {
+		return bits == ROAD_NW ? DIAGDIR_NW : DIAGDIR_SW;
+	}
+	return bits == ROAD_SE ? DIAGDIR_SE : DIAGDIR_NE;
+}
+
+RoadBits FindRailsToConnect(TileIndex tile) {
+	RoadBits directed = ROAD_NONE;
+	RoadBits passing = ROAD_NONE;
+	DiagDirection ddir;
+	for (ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+		TileIndex cur_tile = TileAddByDiagDir(tile, ddir);
+		if (HasStationTileRail(cur_tile)) {
+			if (GetRailStationTrackBits(cur_tile) & DiagdirReachesTracks(ddir)) {
+				directed |= DiagDirToRoadBits(ddir);
+			}
+			continue;
+		}
+		if (!IsTileType(cur_tile, MP_RAILWAY)) continue;
+		if (!IsPlainRail(cur_tile)) continue;
+		passing |= DiagDirToRoadBits(ddir);
+		if (GetTrackBits(cur_tile) & DiagdirReachesTracks(ddir)) {
+			directed |= DiagDirToRoadBits(ddir);
+		}
+	}
+	// Prioritize track bits that head in this direction
+	if (directed != ROAD_NONE) {
+		return directed;
+	}
+	return passing;
+}
+
+/*
+ * Selects orientation for rail object (depot)
+ */
+static DiagDirection AutodetectRailObjectDirection(TileIndex tile) {
+	RoadBits bits = FindRailsToConnect(tile);
+	// FIXME after this point repeats road autodetection
+	if (HasExactlyOneBit(bits)) return RoadBitsToDiagDir(bits);
+	if (bits == ROAD_NONE) bits = ROAD_ALL;
+	RoadBits frac_bits = DiagDirToRoadBits(TileFractCoordsToDiagDir());
+	if (HasExactlyOneBit(frac_bits & bits)) {
+		return RoadBitsToDiagDir(frac_bits & bits);
+	}
+	frac_bits |= MirrorRoadBits(frac_bits);
+	if (HasExactlyOneBit(frac_bits & bits)) {
+		return RoadBitsToDiagDir(frac_bits & bits);
+	}
+	for (DiagDirection ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+		if (DiagDirToRoadBits(ddir) & bits) {
+			return ddir;
+		}
+	}
+	NOT_REACHED();
+}
+
 /** Rail toolbar management class. */
 struct BuildRailToolbarWindow : Window {
 	RailType railtype;    ///< Rail type to build.
@@ -459,6 +529,7 @@ struct BuildRailToolbarWindow : Window {
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_EW)->widget_data     = rti->gui_sprites.build_ew_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_Y)->widget_data      = rti->gui_sprites.build_y_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_AUTORAIL)->widget_data     = rti->gui_sprites.auto_rail;
+		this->GetWidget<NWidgetCore>(WID_RAT_POLYRAIL)->widget_data     = rti->gui_sprites.auto_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_DEPOT)->widget_data  = rti->gui_sprites.build_depot;
 		this->GetWidget<NWidgetCore>(WID_RAT_CONVERT_RAIL)->widget_data = rti->gui_sprites.convert_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_TUNNEL)->widget_data = rti->gui_sprites.build_tunnel;
@@ -487,6 +558,7 @@ struct BuildRailToolbarWindow : Window {
 			case WID_RAT_BUILD_EW:
 			case WID_RAT_BUILD_Y:
 			case WID_RAT_AUTORAIL:
+			case WID_RAT_POLYRAIL:
 			case WID_RAT_BUILD_WAYPOINT:
 			case WID_RAT_BUILD_STATION:
 			case WID_RAT_BUILD_SIGNALS:
@@ -518,6 +590,15 @@ struct BuildRailToolbarWindow : Window {
 		}
 	}
 
+	void DrawWidget(const Rect &r, int widget) const override
+	{
+		if (widget == WID_RAT_POLYRAIL) {
+			Dimension d = GetSpriteSize(SPR_BLOT);
+			uint offset = this->IsWidgetLowered(WID_RAT_POLYRAIL) ? 1 : 0;
+			DrawSprite(SPR_BLOT, PALETTE_TO_GREY, (r.left + r.right - d.width) / 2 + offset, (r.top + r.bottom - d.height) / 2 + offset);
+		}
+	}
+
 	void OnClick(Point pt, int widget, int click_count) override
 	{
 		if (widget < WID_RAT_BUILD_NS) return;
@@ -549,6 +630,11 @@ struct BuildRailToolbarWindow : Window {
 				this->last_user_action = widget;
 				break;
 
+			case WID_RAT_POLYRAIL:
+				HandlePlacePushButton(this, WID_RAT_POLYRAIL, GetRailTypeInfo(railtype)->cursor.autorail, HT_RAIL | HT_POLY);
+				this->last_user_action = widget;
+				break;
+
 			case WID_RAT_DEMOLISH:
 				HandlePlacePushButton(this, WID_RAT_DEMOLISH, ANIMCURSOR_DEMOLISH, HT_RECT | HT_DIAGONAL);
 				this->last_user_action = widget;
@@ -618,6 +704,7 @@ struct BuildRailToolbarWindow : Window {
 
 	void OnPlaceObject(Point pt, TileIndex tile) override
 	{
+    		DiagDirection ddir;
 		switch (this->last_user_action) {
 			case WID_RAT_BUILD_NS:
 				VpStartPlaceSizing(tile, VPM_FIX_VERTICAL | VPM_RAILDIRS, DDSP_PLACE_RAIL);
@@ -636,6 +723,7 @@ struct BuildRailToolbarWindow : Window {
 				break;
 
 			case WID_RAT_AUTORAIL:
+			case WID_RAT_POLYRAIL:
 				VpStartPlaceSizing(tile, VPM_RAILDIRS, DDSP_PLACE_RAIL);
 				break;
 
@@ -644,7 +732,11 @@ struct BuildRailToolbarWindow : Window {
 				break;
 
 			case WID_RAT_BUILD_DEPOT:
-				DoCommandP(tile, _cur_railtype, _build_depot_direction,
+				ddir = _build_depot_direction;
+				if (ddir == DIAGDIR_NW + 1) {
+					ddir = AutodetectRailObjectDirection(tile);
+				}
+				DoCommandP(tile, _cur_railtype, ddir,
 						CMD_BUILD_TRAIN_DEPOT | CMD_MSG(STR_ERROR_CAN_T_BUILD_TRAIN_DEPOT),
 						CcRailDepot);
 				break;
@@ -785,6 +877,7 @@ static EventState RailToolbarGlobalHotkeys(int hotkey)
 }
 
 const uint16 _railtoolbar_autorail_keys[] = {'5', 'A' | WKC_GLOBAL_HOTKEY, 0};
+const uint16 _railtoolbar_polyrail_keys[] = {'5' | WKC_CTRL, 'A' | WKC_GLOBAL_HOTKEY | WKC_CTRL, 0};
 
 static Hotkey railtoolbar_hotkeys[] = {
 	Hotkey('1', "build_ns", WID_RAT_BUILD_NS),
@@ -792,6 +885,7 @@ static Hotkey railtoolbar_hotkeys[] = {
 	Hotkey('3', "build_ew", WID_RAT_BUILD_EW),
 	Hotkey('4', "build_y", WID_RAT_BUILD_Y),
 	Hotkey(_railtoolbar_autorail_keys, "autorail", WID_RAT_AUTORAIL),
+	Hotkey(_railtoolbar_polyrail_keys, "polyrail", WID_RAT_POLYRAIL),
 	Hotkey('6', "demolish", WID_RAT_DEMOLISH),
 	Hotkey('7', "depot", WID_RAT_BUILD_DEPOT),
 	Hotkey('8', "waypoint", WID_RAT_BUILD_WAYPOINT),
@@ -822,6 +916,8 @@ static const NWidgetPart _nested_build_rail_widgets[] = {
 						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_RAIL_NW, STR_RAIL_TOOLBAR_TOOLTIP_BUILD_RAILROAD_TRACK),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_RAT_AUTORAIL),
 						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_AUTORAIL, STR_RAIL_TOOLBAR_TOOLTIP_BUILD_AUTORAIL),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_RAT_POLYRAIL),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_AUTORAIL, STR_RAIL_TOOLBAR_TOOLTIP_BUILD_POLYRAIL),
 
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN), SetMinimalSize(4, 22), SetDataTip(0x0, STR_NULL), EndContainer(),
 
@@ -1954,6 +2050,7 @@ struct BuildRailDepotWindow : public PickerWindowBase {
 			case WID_BRAD_DEPOT_SE:
 			case WID_BRAD_DEPOT_SW:
 			case WID_BRAD_DEPOT_NW:
+			case WID_BRAD_DEPOT_AUTO:
 				this->RaiseWidget(_build_depot_direction + WID_BRAD_DEPOT_NE);
 				_build_depot_direction = (DiagDirection)(widget - WID_BRAD_DEPOT_NE);
 				this->LowerWidget(_build_depot_direction + WID_BRAD_DEPOT_NE);
@@ -1991,6 +2088,9 @@ static const NWidgetPart _nested_build_depot_widgets[] = {
 			EndContainer(),
 			NWidget(NWID_SPACER), SetMinimalSize(3, 0), SetFill(1, 0),
 		EndContainer(),
+		NWidget(NWID_HORIZONTAL), SetPIP(2, 2, 2),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BRAD_DEPOT_AUTO), SetMinimalSize(134, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_BUILD_DEPOT_TRAIN_ORIENTATION_AUTO_TOOLTIP),
+		EndContainer(),
 		NWidget(NWID_SPACER), SetMinimalSize(0, 3),
 	EndContainer(),
 };
@@ -2112,7 +2212,7 @@ static void ShowBuildWaypointPicker(Window *parent)
  */
 void InitializeRailGui()
 {
-	_build_depot_direction = DIAGDIR_NW;
+	_build_depot_direction = (DiagDirection)(DIAGDIR_NW + 1);
 	_railstation.station_class = StationClassID::STAT_CLASS_DFLT;
 }
 
diff --git a/src/rail_map.h b/src/rail_map.h
index bd1d3c749..0c4da7638 100644
--- a/src/rail_map.h
+++ b/src/rail_map.h
@@ -478,6 +478,24 @@ static inline bool HasOnewaySignalBlockingTrackdir(TileIndex tile, Trackdir td)
 			!HasSignalOnTrackdir(tile, td) && IsOnewaySignal(tile, TrackdirToTrack(td));
 }
 
+static inline void IncreaseStuckCounter(TileIndex t)
+{
+	if (!IsTileType(t, MP_RAILWAY)) return;
+	if (_me[t].m7 < MAX_UVALUE(byte)) _me[t].m7++;
+}
+
+static inline void ReduceStuckCounter(TileIndex t)
+{
+	if (!IsTileType(t, MP_RAILWAY)) return;
+	_me[t].m7 -= (uint)(_me[t].m7 + 3) / 4;
+}
+
+static inline byte GetStuckCounter(TileIndex t)
+{
+	if (!IsTileType(t, MP_RAILWAY)) return 0;
+	return _me[t].m7;
+}
+
 
 RailType GetTileRailType(TileIndex tile);
 
diff --git a/src/rev.cpp.in b/src/rev.cpp.in
index 3b8e68f95..a5dfb819e 100644
--- a/src/rev.cpp.in
+++ b/src/rev.cpp.in
@@ -35,7 +35,7 @@ bool IsReleasedVersion()
  *
  * <modified> shows a "M", if the binary is made from modified source code.
  */
-const char _openttd_revision[] = "${REV_VERSION}";
+const char _openttd_revision[] = "12.2";
 
 /**
  * The text version of OpenTTD's build date.
@@ -48,12 +48,12 @@ const char _openttd_build_date[] = __DATE__ " " __TIME__;
 /**
  * The git revision hash of this version.
  */
-const char _openttd_revision_hash[] = "${REV_HASH}";
+const char _openttd_revision_hash[] = "50bfa4fff8e4bb0a3aaf5ca7e4d0f3156dce89ef";
 
 /**
  * The year of this version.
  */
-const char _openttd_revision_year[] = "${REV_YEAR}";
+const char _openttd_revision_year[] = "2022";
 
 /**
  * Let us know if current build was modified. This detection
@@ -63,21 +63,21 @@ const char _openttd_revision_year[] = "${REV_YEAR}";
  * (compiling from sources without any version control software)
  * and 2 is for modified revision.
  */
-const byte _openttd_revision_modified = ${REV_MODIFIED};
+const byte _openttd_revision_modified = 0;
 
 /**
  * Indicate whether this is a tagged version.
  * If this is non-0, then _openttd_revision is the name of the tag,
  * and the version is likely a beta, release candidate, or real release.
  */
-const byte _openttd_revision_tagged = ${REV_ISTAG};
+const byte _openttd_revision_tagged = 1;
 
 /**
  * To check compatibility of BaNaNaS content, this version string is used.
  * It should never contain things like "beta", but only the release version
  * we are compatible with.
  */
-const char _openttd_content_version[] = "${REV_MAJOR}.${REV_MINOR}";
+const char _openttd_content_version[] = "12.2";
 
 /**
  * The NewGRF revision of OTTD:
@@ -95,4 +95,4 @@ const char _openttd_content_version[] = "${REV_MAJOR}.${REV_MINOR}";
  * the "patch" part of the version. To make sure "1.11.0" is smaller than "12.0", we
  * have to adjust the major by 16.
  */
-const uint32 _openttd_newgrf_version = (${REV_MAJOR} + 16) << 24 | ${REV_MINOR} << 20 | ${REV_ISSTABLETAG} << 19 | 28004;
+const uint32 _openttd_newgrf_version = (12 + 16) << 24 | 2 << 20 | 1 << 19 | 28004;
diff --git a/src/road_gui.cpp b/src/road_gui.cpp
index f6ddbae41..d213911ab 100644
--- a/src/road_gui.cpp
+++ b/src/road_gui.cpp
@@ -170,6 +170,106 @@ void CcRoadStop(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2,
 	}
 }
 
+static RoadBits FindRoadsToConnect(TileIndex tile) {
+	RoadBits bits = ROAD_NONE;
+	DiagDirection ddir;
+	auto cur_rtt = GetRoadTramType(_cur_roadtype);
+	// Prioritize roadbits that head in this direction
+ 	for (ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+ 		TileIndex cur_tile = TileAddByDiagDir(tile, ddir);
+ 		if (GetAnyRoadBits(cur_tile, cur_rtt, true) &
+ 			DiagDirToRoadBits(ReverseDiagDir(ddir)))
+ 		{
+ 			bits |= DiagDirToRoadBits(ddir);
+ 		}
+ 	}
+ 	if (bits != ROAD_NONE) {
+ 		return bits;
+ 	}
+ 	// Try to connect to any road passing by
+ 	for (ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+ 		TileIndex cur_tile = TileAddByDiagDir(tile, ddir);
+ 		if (GetTileType(cur_tile) == MP_ROAD && HasTileRoadType(cur_tile, cur_rtt) &&
+ 				(GetRoadTileType(cur_tile) == ROAD_TILE_NORMAL)) {
+ 			bits |= DiagDirToRoadBits(ddir);
+ 		}
+ 	}
+ 	return bits;
+ }
+
+ static DiagDirection RoadBitsToDiagDir(RoadBits bits) {
+ 	if (bits < ROAD_SE) {
+ 		return bits == ROAD_NW ? DIAGDIR_NW : DIAGDIR_SW;
+ 	}
+ 	return bits == ROAD_SE ? DIAGDIR_SE : DIAGDIR_NE;
+ }
+
+ static DiagDirection TileFractCoordsToDiagDir() {
+ 	bool diag = (_tile_fract_coords.x + _tile_fract_coords.y) < 16;
+ 	if (_tile_fract_coords.x < _tile_fract_coords.y) {
+ 		return diag ? DIAGDIR_NE : DIAGDIR_SE;
+ 	}
+ 	return diag ? DIAGDIR_NW : DIAGDIR_SW;
+ }
+ /*
+  * Selects orientation for road object (depot, terminal station)
+  */
+ DiagDirection AutodetectRoadObjectDirection(TileIndex tile) {
+ 	RoadBits bits = FindRoadsToConnect(tile);
+ 	if (HasExactlyOneBit(bits)) {
+ 		return RoadBitsToDiagDir(bits);
+ 	}
+ 	if (bits == ROAD_NONE){
+ 		bits = ROAD_ALL;
+ 	}
+ 	RoadBits frac_bits = DiagDirToRoadBits(TileFractCoordsToDiagDir());
+ 	if (HasExactlyOneBit(frac_bits & bits)) {
+ 		return RoadBitsToDiagDir(frac_bits & bits);
+ 	}
+ 	frac_bits |= MirrorRoadBits(frac_bits);
+ 	if (HasExactlyOneBit(frac_bits & bits)) {
+ 		return RoadBitsToDiagDir(frac_bits & bits);
+ 	}
+ 	for (DiagDirection ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+ 		if (DiagDirToRoadBits(ddir) & bits) {
+ 			return ddir;
+ 		}
+ 	}
+ 	NOT_REACHED();
+ }
+
+ bool CheckDriveThroughRoadStopDirection(TileArea area, RoadBits r) {
+	for (TileIndex tile : area) {
+ 		if (GetTileType(tile) != MP_ROAD) continue;
+ 		if (GetRoadTileType(tile) != ROAD_TILE_NORMAL) continue;
+ 		if (GetAllRoadBits(tile) & ~r) return false;
+ 	}
+ 	return true;
+ }
+
+
+ /*
+  * Automaticaly selects direction to use for road stop.
+  * @param area road stop area
+  * @return selected direction
+  */
+ DiagDirection AutodetectDriveThroughRoadStopDirection(TileArea area) {
+ 	bool se_suits, ne_suits;
+
+ 	// Check which direction is available
+ 	// If both are not use SE, building will fail anyway
+ 	se_suits = CheckDriveThroughRoadStopDirection(area, ROAD_Y);
+ 	ne_suits = CheckDriveThroughRoadStopDirection(area, ROAD_X);
+ 	if (!ne_suits) return DIAGDIR_SE;
+ 	if (!se_suits) return DIAGDIR_NE;
+
+ 	// Build station along the longer direction
+ 	if (area.w > area.h) return DIAGDIR_NE;
+ 	if (area.w < area.h) return DIAGDIR_SE;
+
+ 	return AutodetectRoadObjectDirection(area.tile);
+ }
+
 /**
  * Place a new road stop.
  * @param start_tile First tile of the area.
@@ -184,14 +284,23 @@ static void PlaceRoadStop(TileIndex start_tile, TileIndex end_tile, uint32 p2, u
 {
 	uint8 ddir = _road_station_picker_orientation;
 	SB(p2, 16, 16, INVALID_STATION); // no station to join
+	TileArea ta(start_tile, end_tile);
 
 	if (ddir >= DIAGDIR_END) {
-		SetBit(p2, 1); // It's a drive-through stop.
-		ddir -= DIAGDIR_END; // Adjust picker result to actual direction.
+		if (ddir < DIAGDIR_END + 2) {
+			SetBit(p2, 1); // It's a drive-through stop.
+			ddir -= DIAGDIR_END; // Adjust picker result to actual direction.
+		}
+		else if (ddir == DIAGDIR_END + 2) {
+			ddir = AutodetectRoadObjectDirection(start_tile);
+		}
+		else if (ddir == DIAGDIR_END + 3) {
+			SetBit(p2, 1); // It's a drive-through stop.
+			ddir = AutodetectDriveThroughRoadStopDirection(ta);
+		}
 	}
 	p2 |= ddir << 3; // Set the DiagDirecion into p2 bits 3 and 4.
 
-	TileArea ta(start_tile, end_tile);
 	CommandContainer cmdcont = { ta.tile, (uint32)(ta.w | ta.h << 8), p2, cmd, CcRoadStop, "" };
 	ShowSelectStationIfNeeded(cmdcont, ta);
 }
@@ -523,6 +632,7 @@ struct BuildRoadToolbarWindow : Window {
 
 	void OnPlaceObject(Point pt, TileIndex tile) override
 	{
+		DiagDirection ddir;
 		_remove_button_clicked = this->IsWidgetLowered(WID_ROT_REMOVE);
 		_one_way_button_clicked = RoadTypeIsRoad(this->roadtype) ? this->IsWidgetLowered(WID_ROT_ONE_WAY) : false;
 		switch (this->last_started_action) {
@@ -550,7 +660,11 @@ struct BuildRoadToolbarWindow : Window {
 				break;
 
 			case WID_ROT_DEPOT:
-				DoCommandP(tile, _cur_roadtype << 2 | _road_depot_orientation, 0,
+				ddir = _road_depot_orientation;
+				if (ddir == DIAGDIR_NW + 1) {
+					ddir = AutodetectRoadObjectDirection(tile);
+				}
+				DoCommandP(tile, _cur_roadtype << 2 | ddir, 0,
 						CMD_BUILD_ROAD_DEPOT | CMD_MSG(this->rti->strings.err_depot), CcRoadDepot);
 				break;
 
@@ -989,7 +1103,7 @@ struct BuildRoadDepotWindow : public PickerWindowBase {
 		this->LowerWidget(_road_depot_orientation + WID_BROD_DEPOT_NE);
 		if (RoadTypeIsTram(_cur_roadtype)) {
 			this->GetWidget<NWidgetCore>(WID_BROD_CAPTION)->widget_data = STR_BUILD_DEPOT_TRAM_ORIENTATION_CAPTION;
-			for (int i = WID_BROD_DEPOT_NE; i <= WID_BROD_DEPOT_NW; i++) this->GetWidget<NWidgetCore>(i)->tool_tip = STR_BUILD_DEPOT_TRAM_ORIENTATION_SELECT_TOOLTIP;
+			for (int i = WID_BROD_DEPOT_NE; i <= WID_BROD_DEPOT_AUTO; i++) this->GetWidget<NWidgetCore>(i)->tool_tip = STR_BUILD_DEPOT_TRAM_ORIENTATION_SELECT_TOOLTIP;
 		}
 
 		this->FinishInitNested(TRANSPORT_ROAD);
@@ -1017,6 +1131,7 @@ struct BuildRoadDepotWindow : public PickerWindowBase {
 			case WID_BROD_DEPOT_NE:
 			case WID_BROD_DEPOT_SW:
 			case WID_BROD_DEPOT_SE:
+			case WID_BROD_DEPOT_AUTO:
 				this->RaiseWidget(_road_depot_orientation + WID_BROD_DEPOT_NE);
 				_road_depot_orientation = (DiagDirection)(widget - WID_BROD_DEPOT_NE);
 				this->LowerWidget(_road_depot_orientation + WID_BROD_DEPOT_NE);
@@ -1056,6 +1171,9 @@ static const NWidgetPart _nested_build_road_depot_widgets[] = {
 			EndContainer(),
 			NWidget(NWID_SPACER), SetMinimalSize(3, 0), SetFill(1, 0),
 		EndContainer(),
+		NWidget(NWID_HORIZONTAL), SetPIP(2, 2, 2),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BROD_DEPOT_AUTO), SetMinimalSize(134, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_BUILD_DEPOT_ROAD_ORIENTATION_AUTO_TOOLTIP),
+		EndContainer(),
 		NWidget(NWID_SPACER), SetMinimalSize(0, 3),
 	EndContainer(),
 };
@@ -1154,6 +1272,8 @@ struct BuildRoadStationWindow : public PickerWindowBase {
 			case WID_BROS_STATION_NW:
 			case WID_BROS_STATION_X:
 			case WID_BROS_STATION_Y:
+			case WID_BROS_STATION_AUTO:
+			case WID_BROS_STATION_XY_AUTO:
 				this->RaiseWidget(_road_station_picker_orientation + WID_BROS_STATION_NE);
 				_road_station_picker_orientation = (DiagDirection)(widget - WID_BROS_STATION_NE);
 				this->LowerWidget(_road_station_picker_orientation + WID_BROS_STATION_NE);
@@ -1206,6 +1326,14 @@ static const NWidgetPart _nested_road_station_picker_widgets[] = {
 			NWidget(WWT_PANEL, COLOUR_GREY, WID_BROS_STATION_Y),  SetMinimalSize(66, 50), SetFill(0, 0), EndContainer(),
 			NWidget(NWID_SPACER), SetFill(1, 0),
 		EndContainer(),
+		NWidget(NWID_SPACER), SetMinimalSize(0, 2),
+		NWidget(NWID_HORIZONTAL), SetPIP(0, 2, 0),
+			NWidget(NWID_SPACER), SetFill(1, 0),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BROS_STATION_AUTO), SetMinimalSize(134, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_STATION_BUILD_ORIENTATION_AUTO_TOOLTIP),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BROS_STATION_XY_AUTO), SetMinimalSize(66, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_STATION_BUILD_ORIENTATION_AUTO_TOOLTIP),
+			NWidget(NWID_SPACER), SetFill(1, 0),
+		EndContainer(),
+		NWidget(NWID_SPACER), SetMinimalSize(0, 2),
 		NWidget(NWID_SPACER), SetMinimalSize(0, 1),
 		NWidget(NWID_HORIZONTAL), SetPIP(2, 0, 2),
 			NWidget(WWT_LABEL, COLOUR_DARK_GREEN, WID_BROS_INFO), SetMinimalSize(140, 14), SetDataTip(STR_STATION_BUILD_COVERAGE_AREA_TITLE, STR_NULL),
@@ -1244,6 +1372,14 @@ static const NWidgetPart _nested_tram_station_picker_widgets[] = {
 			NWidget(WWT_PANEL, COLOUR_GREY, WID_BROS_STATION_Y),  SetMinimalSize(66, 50), SetFill(0, 0), EndContainer(),
 			NWidget(NWID_SPACER), SetFill(1, 0),
 		EndContainer(),
+		NWidget(NWID_SPACER), SetMinimalSize(0, 2),
+		NWidget(NWID_HORIZONTAL), SetPIP(0, 2, 0),
+			NWidget(NWID_SPACER), SetFill(1, 0),
+			NWidget(WWT_TEXT, COLOUR_GREY, WID_BROS_STATION_AUTO), SetMinimalSize(0, 0), SetDataTip(STR_EMPTY, STR_EMPTY),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BROS_STATION_XY_AUTO), SetMinimalSize(134, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_STATION_BUILD_ORIENTATION_AUTO_TOOLTIP),
+			NWidget(NWID_SPACER), SetFill(1, 0),
+		EndContainer(),
+		NWidget(NWID_SPACER), SetMinimalSize(0, 2),
 		NWidget(NWID_SPACER), SetMinimalSize(0, 1),
 		NWidget(NWID_HORIZONTAL), SetPIP(2, 0, 2),
 			NWidget(WWT_LABEL, COLOUR_DARK_GREEN, WID_BROS_INFO), SetMinimalSize(140, 14), SetDataTip(STR_STATION_BUILD_COVERAGE_AREA_TITLE, STR_NULL),
@@ -1275,8 +1411,8 @@ static void ShowRVStationPicker(Window *parent, RoadStopType rs)
 
 void InitializeRoadGui()
 {
-	_road_depot_orientation = DIAGDIR_NW;
-	_road_station_picker_orientation = DIAGDIR_NW;
+	_road_depot_orientation = (DiagDirection)(DIAGDIR_NW + 1);
+	_road_station_picker_orientation = (DiagDirection)(DIAGDIR_END + 3);
 }
 
 /**
diff --git a/src/roadveh_cmd.cpp b/src/roadveh_cmd.cpp
index 86c2de78e..cebb2b5a5 100644
--- a/src/roadveh_cmd.cpp
+++ b/src/roadveh_cmd.cpp
@@ -1178,7 +1178,7 @@ bool IndividualRoadVehicleController(RoadVehicle *v, const RoadVehicle *prev)
 		v->x_pos = gp.x;
 		v->y_pos = gp.y;
 		v->UpdatePosition();
-		if ((v->vehstatus & VS_HIDDEN) == 0) v->Vehicle::UpdateViewport(true);
+		if (v->IsDrawn()) v->Vehicle::UpdateViewport(true);
 		return true;
 	}
 
diff --git a/src/saveload/industry_sl.cpp b/src/saveload/industry_sl.cpp
index 7a941a9c7..b17afa427 100644
--- a/src/saveload/industry_sl.cpp
+++ b/src/saveload/industry_sl.cpp
@@ -113,9 +113,19 @@ struct INDYChunkHandler : ChunkHandler {
 
 	void FixPointers() const override
 	{
+		int industry_count = 0;
+		int max_idx = 0;
+
 		for (Industry *i : Industry::Iterate()) {
 			SlObject(i, _industry_desc);
+
+			industry_count++;
+			if (i->index > max_idx) {
+				max_idx = i->index;
+			}
 		}
+
+		updateSharedIndustry(industry_count, max_idx);
 	}
 };
 
diff --git a/src/saveload/town_sl.cpp b/src/saveload/town_sl.cpp
index 7b9125917..2954085ee 100644
--- a/src/saveload/town_sl.cpp
+++ b/src/saveload/town_sl.cpp
@@ -36,6 +36,10 @@ void RebuildTownCaches()
 	for (Town *town : Town::Iterate()) {
 		town->cache.population = 0;
 		town->cache.num_houses = 0;
+		town->cache.potential_pop = 0;
+		town->houses_construction = 0;
+		town->houses_reconstruction = 0;
+		town->houses_demolished = 0;
 	}
 
 	for (TileIndex t = 0; t < MapSize(); t++) {
@@ -44,7 +48,15 @@ void RebuildTownCaches()
 		HouseID house_id = GetHouseType(t);
 		Town *town = Town::GetByTile(t);
 		IncreaseBuildingCount(town, house_id);
-		if (IsHouseCompleted(t)) town->cache.population += HouseSpec::Get(house_id)->population;
+		if (IsHouseCompleted(t)) {
+      town->cache.population += HouseSpec::Get(house_id)->population;
+      //if (town->houses_construction > 0) town->houses_construction--;
+    }
+		else{
+			town->houses_construction++;
+		}
+		town->cache.potential_pop += HouseSpec::Get(house_id)->population;
+		//town->cache.potential_pop += HouseSpec::Get(house_id)->population;
 
 		/* Increase the number of houses for every house, but only once. */
 		if (GetHouseNorthPart(house_id) == 0) town->cache.num_houses++;
diff --git a/src/script/api/script_window.hpp.in b/src/script/api/script_window.hpp.in
index a1dbb6567..b99f78346 100644
--- a/src/script/api/script_window.hpp.in
+++ b/src/script/api/script_window.hpp.in
@@ -20,6 +20,7 @@
 #include "../../widgets/bootstrap_widget.h"
 #include "../../widgets/bridge_widget.h"
 #include "../../widgets/build_vehicle_widget.h"
+#include "../../widgets/cargo_table_widget.h"
 #include "../../widgets/cheat_widget.h"
 #include "../../widgets/company_widget.h"
 #include "../../widgets/console_widget.h"
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
index 3e7a0fbb1..55b621227 100644
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -1555,6 +1555,7 @@ static SettingsContainer &GetSettingsTree()
 	{
 		/* Build up the dynamic settings-array only once per OpenTTD session */
 		main = new SettingsContainer();
+		main->Add(new SettingEntry("gui.community"));
 
 		SettingsPage *localisation = main->Add(new SettingsPage(STR_CONFIG_SETTING_LOCALISATION));
 		{
@@ -1620,6 +1621,7 @@ static SettingsContainer &GetSettingsTree()
 				viewports->Add(new SettingEntry("gui.measure_tooltip"));
 				viewports->Add(new SettingEntry("gui.loading_indicators"));
 				viewports->Add(new SettingEntry("gui.show_track_reservation"));
+				viewports->Add(new SettingEntry("gui.enable_extra_tooltips"));
 			}
 
 			SettingsPage *construction = interface->Add(new SettingsPage(STR_CONFIG_SETTING_INTERFACE_CONSTRUCTION));
@@ -1723,6 +1725,24 @@ static SettingsContainer &GetSettingsTree()
 				routing->Add(new SettingEntry("pf.pathfinder_for_ships"));
 			}
 
+      SettingsPage *ordercontrols = vehicles->Add(new SettingsPage(STR_CONFIG_SETTING_VEHICLES_CTRL));
+			{
+        SettingsPage *ordershortcuts = ordercontrols->Add(new SettingsPage(STR_CONFIG_SETTING_ORDER_SHORTCUTS));
+        {
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_ctrl_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_shift_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_ctrlshift_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_alt_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_altshift_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_altctrl_lclick"));
+        }
+				ordercontrols->Add(new SettingEntry("gui.enable_ctrl_click_start_stop"));
+				//ordercontrols->Add(new SettingEntry("gui.new_nonstop"));  // If enabled here must be disabled on the original place
+				//ordercontrols->Add(new SettingEntry("gui.stop_location")); // If enabled here must be disabled on the original place
+				ordercontrols->Add(new SettingEntry("gui.auto_noload_on_transfer"));
+				ordercontrols->Add(new SettingEntry("gui.auto_noload_on_unloadall"));
+			}
+
 			vehicles->Add(new SettingEntry("order.no_servicing_if_no_breakdowns"));
 			vehicles->Add(new SettingEntry("order.serviceathelipad"));
 		}
diff --git a/src/settings_type.h b/src/settings_type.h
index e68f6c525..6f1f0359d 100644
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -109,6 +109,15 @@ struct GUISettings {
 	bool   vehicle_income_warn;              ///< if a vehicle isn't generating income, show a warning
 	bool   show_finances;                    ///< show finances at end of year
 	bool   sg_new_nonstop;                   ///< ttdpatch compatible nonstop handling read from pre v93 savegames
+	bool   enable_ctrl_click_start_stop;     ///< allow ctrl+click to start or stop vehicles
+	uint8  goto_shortcuts_ctrl_lclick;       ///< goto action shortcut CTRL+LEFT-CLICK
+	uint8  goto_shortcuts_shift_lclick;      ///< goto action shortcut SHIFT+LEFT-CLICK
+	uint8  goto_shortcuts_ctrlshift_lclick;  ///< goto action shortcut CTRL+SHIFT+LEFT-CLICK
+	uint8  goto_shortcuts_alt_lclick;        ///< goto action shortcut ALT+LEFT-CLICK
+	uint8  goto_shortcuts_altshift_lclick;   ///< goto action shortcut ALT+SHIFT+LEFT-CLICK
+	uint8  goto_shortcuts_altctrl_lclick;    ///< goto action shortcut ALT+CTRL+LEFT-CLICK
+	bool   auto_noload_on_transfer;          ///< automatically set no-loading when ordering to transfer all cargo
+	bool   auto_noload_on_unloadall;         ///< automatically set no-loading when ordering to unload all cargo
 	bool   new_nonstop;                      ///< ttdpatch compatible nonstop handling
 	uint8  stop_location;                    ///< what is the default stop location of trains?
 	uint8  auto_scrolling;                   ///< scroll when moving mouse to the edge (see #ViewportAutoscrolling)
@@ -191,6 +200,13 @@ struct GUISettings {
 	uint8  settings_restriction_mode;        ///< selected restriction mode in adv. settings GUI. @see RestrictionMode
 	bool   newgrf_show_old_versions;         ///< whether to show old versions in the NewGRF list
 	uint8  newgrf_default_palette;           ///< default palette to use for NewGRFs without action 14 palette information
+	bool   enable_extra_tooltips;            ///< enable extra tooltips when hovering over various elements
+	uint8  cb_distance_check;                ///< zoning cb distance
+	uint32 powerfund_money;                  ///< minimum amount of money for powerfund to work
+	uint16 powerfund_houses;                 ///< powerfunding maximum houses limit
+
+	uint8  community;                        ///< chosen community nice=0, btpro=1
+	uint32  btpro_version;
 
 	/**
 	 * Returns true when the user has sufficient privileges to edit newgrfs on a running game
@@ -298,6 +314,8 @@ struct NetworkSettings {
 	std::string last_joined;                              ///< Last joined server
 	bool        no_http_content_downloads;                ///< do not do content downloads over HTTP
 	UseRelayService use_relay_service;                        ///< Use relay service?
+	std::string community_user[2];           ///< webpage user to retrieve Token
+	std::string community_password[2];///< webpage password to retrieve Token
 };
 
 /** Settings related to the creation of games. */
diff --git a/src/smallmap_gui.cpp b/src/smallmap_gui.cpp
index 7827620af..0bc19c2ac 100644
--- a/src/smallmap_gui.cpp
+++ b/src/smallmap_gui.cpp
@@ -254,6 +254,20 @@ static const LegendAndColour * const _legend_table[] = {
 
 #include "table/heightmap_colours.h"
 
+/**
+ * Colour Coding for Stuck Counter
+ */
+static const uint32 _stuck_counter_colours[] = {
+	MKCOLOUR(0xD0D0D0D0),
+	MKCOLOUR(0xCECECECE),
+	MKCOLOUR(0xBFBFBFBF),
+	MKCOLOUR(0xBDBDBDBD),
+	MKCOLOUR(0xBABABABA),
+	MKCOLOUR(0xB8B8B8B8),
+	MKCOLOUR(0xB6B6B6B6),
+	MKCOLOUR(0xB4B4B4B4),
+};
+
 /** Colour scheme of the smallmap. */
 struct SmallMapColourScheme {
 	uint32 *height_colours;            ///< Cached colours for each level in a map.
@@ -464,13 +478,18 @@ static inline uint32 GetSmallMapRoutesPixels(TileIndex tile, TileType t)
 			}
 
 		case MP_RAILWAY: {
+			byte c = GetStuckCounter(tile);
+			if (c == 0) return 0;
+			return _stuck_counter_colours[(uint)c * lengthof(_stuck_counter_colours) / (MAX_UVALUE(byte) + 1)];
+			/* TODO: Check what this is about
 			AndOr andor = {
 				MKCOLOUR_0XX0(GetRailTypeInfo(GetRailType(tile))->map_colour),
 				_smallmap_contours_andor[t].mand
 			};
 
 			const SmallMapColourScheme *cs = &_heightmap_schemes[_settings_client.gui.smallmap_land_colour];
-			return ApplyMask(cs->default_colour, &andor);
+			return ApplyMask(cs->default_colour, &andor); 
+			*/
 		}
 
 		case MP_ROAD: {
@@ -926,7 +945,7 @@ void SmallMapWindow::DrawTowns(const DrawPixelInfo *dpi) const
 				y < dpi->top + dpi->height) {
 			/* And draw it. */
 			SetDParam(0, t->index);
-			DrawString(x, x + t->cache.sign.width_small, y, STR_SMALLMAP_TOWN);
+			DrawString(x, x + t->cache.sign.width_small, y, (t->larger_town ? STR_SMALLMAP_TOWN_LARGE : STR_SMALLMAP_TOWN));
 		}
 	}
 }
diff --git a/src/station_gui.cpp b/src/station_gui.cpp
index ecc7ea77c..032d86f8d 100644
--- a/src/station_gui.cpp
+++ b/src/station_gui.cpp
@@ -2141,7 +2141,17 @@ static WindowDesc _station_view_desc(
  */
 void ShowStationViewWindow(StationID station)
 {
-	AllocateWindowDescFront<StationViewWindow>(&_station_view_desc, station);
+	//catchment with ctrl+click, stationwindow with click
+	extern const Station* _viewport_highlight_station;
+	if (_ctrl_pressed) {
+		if (_viewport_highlight_station != nullptr) {
+			if (_viewport_highlight_station == Station::Get(station))
+				SetViewportCatchmentStation(Station::Get(station), false);
+			else SetViewportCatchmentStation(Station::Get(station), true);
+		}
+		else SetViewportCatchmentStation(Station::Get(station), true);
+	}
+	else AllocateWindowDescFront<StationViewWindow>(&_station_view_desc, station);
 }
 
 /** Struct containing TileIndex and StationID */
diff --git a/src/statusbar_gui.cpp b/src/statusbar_gui.cpp
index 9031ccf30..282042dcd 100644
--- a/src/statusbar_gui.cpp
+++ b/src/statusbar_gui.cpp
@@ -192,6 +192,19 @@ struct StatusBarWindow : Window {
 					DrawSprite(SPR_UNREAD_NEWS, PAL_NONE, r.right - WD_FRAMERECT_RIGHT - icon_size.width, r.top + std::max(0, ((int)(r.bottom - r.top + 1) - (int)icon_size.height) / 2));
 				}
 				break;
+
+      case WID_S_USER:
+        if(_settings_client.gui.community != 0){
+          SetDParamStr(0, _settings_client.network.community_user[_settings_client.gui.community-1]);
+          DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_CC_WIKI_USER_PAGE, TC_FROMSTRING, SA_HOR_CENTER);
+        }
+				break;
+
+			case WID_S_RULES:
+				if(_settings_client.gui.community != 0){
+					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_CC_WIKI_RULES_PAGE_STATUS, TC_FROMSTRING, SA_HOR_CENTER);
+				}
+				break;
 		}
 	}
 
@@ -218,8 +231,17 @@ struct StatusBarWindow : Window {
 
 	void OnClick(Point pt, int widget, int click_count) override
 	{
+    extern void OpenBrowser(const char *url);
 		switch (widget) {
 			case WID_S_MIDDLE: ShowLastNewsMessage(); break;
+			case WID_S_USER:
+        if(_settings_client.gui.community == 1) OpenBrowser("http://n-ice.org/openttd");
+				else if(_settings_client.gui.community == 2) OpenBrowser("https://openttd.btpro.nl");
+				break;
+			case WID_S_RULES:
+				if(_settings_client.gui.community == 1) OpenBrowser("https://wiki.x-base.info/OpenTTD/Rules");
+				else if(_settings_client.gui.community == 2) OpenBrowser("https://openttd.btpro.nl/wiki/index.php/Server_Rules");
+				break;
 			case WID_S_RIGHT:  if (_local_company != COMPANY_SPECTATOR) ShowCompanyFinances(_local_company); break;
 			default: ResetObjectToPlace();
 		}
@@ -247,7 +269,9 @@ struct StatusBarWindow : Window {
 static const NWidgetPart _nested_main_status_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_PANEL, COLOUR_GREY, WID_S_LEFT), SetMinimalSize(140, 12), EndContainer(),
+		NWidget(WWT_PUSHBTN, COLOUR_CREAM, WID_S_RULES), SetMinimalSize(80, 12), SetDataTip(0x0, STR_CC_WIKI_RULES_PAGE_STATUS_TOOLTIP),
 		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_MIDDLE), SetMinimalSize(40, 12), SetDataTip(0x0, STR_STATUSBAR_TOOLTIP_SHOW_LAST_NEWS), SetResize(1, 0),
+		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_USER), SetMinimalSize(80, 12), SetDataTip(0x0, STR_CC_WIKI_USER_PAGE_TOOLTIP),
 		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_RIGHT), SetMinimalSize(140, 12),
 	EndContainer(),
 };
diff --git a/src/table/settings/gui_settings.ini b/src/table/settings/gui_settings.ini
index 27fe44dd0..e57ade94d 100644
--- a/src/table/settings/gui_settings.ini
+++ b/src/table/settings/gui_settings.ini
@@ -856,3 +856,145 @@ min      = 1
 max      = 65535
 cat      = SC_EXPERT
 
+; //MODGUI *********************************
+[SDTC_BOOL]
+var      = gui.enable_ctrl_click_start_stop
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = true
+str      = STR_CONFIG_SETTING_CTRL_ENABLE_CTRLCLICK_STARTSTOP
+
+[SDTC_BOOL]
+var      = gui.auto_noload_on_transfer
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = true
+str      = STR_CONFIG_SETTING_AUTOSET_NOLOAD_ON_TRANSFER
+
+[SDTC_BOOL]
+var      = gui.auto_noload_on_unloadall
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_SETTING_AUTOSET_NOLOAD_ON_UNLOAD
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_ctrl_lclick
+type     = SLE_UINT8
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 1
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_shift_lclick
+type     = SLE_UINT8
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_SHIFTLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_ctrlshift_lclick
+type     = SLE_UINT8
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLSHIFTLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_alt_lclick
+type     = SLE_UINT8
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 2
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_ALTLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_altshift_lclick
+type     = SLE_UINT8
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_ALTSHIFTCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_altctrl_lclick
+type     = SLE_UINT8
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLALTLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.cb_distance_check
+type     = SLE_UINT8
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = 25
+min      = 0
+max      = 100
+interval = 5
+str      = STR_CB_DISTANCE_CHECK
+strval   = STR_JUST_COMMA
+proc     = RedrawScreen
+
+[SDTC_BOOL]
+var      = gui.enable_extra_tooltips
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = true
+str      = STR_CONFIG_SETTING_ENABLE_EXTRA_TOOLTIPS
+
+[SDTC_VAR]
+var      = gui.btpro_version
+type     = SLE_UINT32
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = 0
+min      = 0
+max      = 999999
+
+[SDTC_VAR]
+var      = gui.community
+type     = SLE_UINT8
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC | SF_GUI_DROPDOWN
+def      = 0
+min      = 0
+max      = 2
+interval = 1
+str      = STR_CONFIG_SETTING_COMMUNITY
+strval   = STR_CONFIG_SETTING_CLIENT_COMMUNITY
+proc     = RedrawScreen
+cat      = SC_BASIC
+
diff --git a/src/table/settings/misc_settings.ini b/src/table/settings/misc_settings.ini
index 5d585496d..e68501f4f 100644
--- a/src/table/settings/misc_settings.ini
+++ b/src/table/settings/misc_settings.ini
@@ -289,7 +289,7 @@ type     = SLE_UINT
 var      = _transparency_opt
 def      = 0
 min      = 0
-max      = 0x1FF
+max      = 0x3FF
 cat      = SC_BASIC
 
 [SDTG_VAR]
@@ -298,7 +298,7 @@ type     = SLE_UINT
 var      = _transparency_lock
 def      = 0
 min      = 0
-max      = 0x1FF
+max      = 0x3FF
 cat      = SC_BASIC
 
 [SDTG_VAR]
diff --git a/src/table/settings/network_secrets_settings.ini b/src/table/settings/network_secrets_settings.ini
index 4613636a8..0939fe88b 100644
--- a/src/table/settings/network_secrets_settings.ini
+++ b/src/table/settings/network_secrets_settings.ini
@@ -88,3 +88,36 @@ type     = SLE_STR
 length   = NETWORK_INVITE_CODE_SECRET_LENGTH
 flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC | SF_NETWORK_ONLY
 def      = nullptr
+
+[SDTC_SSTR]
+var      = network.community_user[0]
+length   = NETWORK_PASSWORD_LENGTH
+type     = SLE_STR
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = nullptr
+cat      = SC_BASIC
+
+[SDTC_SSTR]
+var      = network.community_user[1]
+length   = NETWORK_PASSWORD_LENGTH
+type     = SLE_STR
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = nullptr
+cat      = SC_BASIC
+
+[SDTC_SSTR]
+var      = network.community_password[0]
+type     = SLE_STR
+length   = NETWORK_PASSWORD_LENGTH
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = nullptr
+cat      = SC_BASIC
+
+[SDTC_SSTR]
+var      = network.community_password[1]
+type     = SLE_STR
+length   = NETWORK_PASSWORD_LENGTH
+flags    = SF_NOT_IN_SAVE | SF_NO_NETWORK_SYNC
+def      = nullptr
+cat      = SC_BASIC
+
diff --git a/src/table/sprites.h b/src/table/sprites.h
index b7bb91020..46faca7d6 100644
--- a/src/table/sprites.h
+++ b/src/table/sprites.h
@@ -309,8 +309,23 @@ static const uint16 EMPTY_BOUNDING_BOX_SPRITE_COUNT = 1;
 static const SpriteID SPR_PALETTE_BASE = SPR_EMPTY_BOUNDING_BOX + EMPTY_BOUNDING_BOX_SPRITE_COUNT;
 static const uint16 PALETTE_SPRITE_COUNT = 1;
 
+/* zoning stuff */
+static const SpriteID SPR_INNER_HIGHLIGHT_BASE      = SPR_PALETTE_BASE + PALETTE_SPRITE_COUNT;
+static const SpriteID SPR_IMG_COMPANY_CARGO         = SPR_INNER_HIGHLIGHT_BASE + 19;
+static const SpriteID SPR_IMG_COMPANY_GOAL          = SPR_INNER_HIGHLIGHT_BASE + 20;
+static const SpriteID SPR_PALETTE_ZONING_RED        = SPR_INNER_HIGHLIGHT_BASE + 21;
+static const SpriteID SPR_PALETTE_ZONING_GREEN      = SPR_INNER_HIGHLIGHT_BASE + 22;
+static const SpriteID SPR_PALETTE_ZONING_BLACK      = SPR_INNER_HIGHLIGHT_BASE + 23;
+static const SpriteID SPR_PALETTE_ZONING_LIGHT_BLUE = SPR_INNER_HIGHLIGHT_BASE + 24;
+static const SpriteID SPR_PALETTE_ZONING_ORANGE     = SPR_INNER_HIGHLIGHT_BASE + 25;
+static const SpriteID SPR_PALETTE_ZONING_WHITE      = SPR_INNER_HIGHLIGHT_BASE + 26;
+static const SpriteID SPR_PALETTE_ZONING_YELLOW     = SPR_INNER_HIGHLIGHT_BASE + 27;
+static const SpriteID SPR_PALETTE_ZONING_PURPLE     = SPR_INNER_HIGHLIGHT_BASE + 28;
+static const uint16 SPR_INNER_HIGHLIGHT_COUNT     = 29;
+
 /* From where can we start putting NewGRFs? */
-static const SpriteID SPR_NEWGRFS_BASE = SPR_PALETTE_BASE + PALETTE_SPRITE_COUNT;
+//static const SpriteID SPR_NEWGRFS_BASE = SPR_PALETTE_BASE + PALETTE_SPRITE_COUNT;
+static const SpriteID SPR_NEWGRFS_BASE = SPR_INNER_HIGHLIGHT_BASE + SPR_INNER_HIGHLIGHT_COUNT;
 
 /* Manager face sprites */
 static const SpriteID SPR_GRADIENT = 874; // background gradient behind manager face
diff --git a/src/terraform_gui.cpp b/src/terraform_gui.cpp
index f710cecc5..736151fce 100644
--- a/src/terraform_gui.cpp
+++ b/src/terraform_gui.cpp
@@ -32,6 +32,7 @@
 #include "engine_base.h"
 #include "terraform_gui.h"
 #include "zoom_func.h"
+#include "tile_map.h"
 
 #include "widgets/terraform_widget.h"
 
@@ -148,6 +149,11 @@ void PlaceProc_DemolishArea(TileIndex tile)
 	VpStartPlaceSizing(tile, VPM_X_AND_Y, DDSP_DEMOLISH_AREA);
 }
 
+static void PlaceProc_Measure(TileIndex tile)
+{
+	VpStartPlaceSizing(tile, VPM_A_B_LINE, DDSP_MEASURE);
+}
+
 /** Terra form toolbar managing class. */
 struct TerraformToolbarWindow : Window {
 	int last_user_action; ///< Last started user action.
@@ -205,6 +211,11 @@ struct TerraformToolbarWindow : Window {
 				ShowBuildTreesToolbar();
 				break;
 
+			case WID_TT_MEASUREMENT_TOOL:
+				HandlePlacePushButton(this, WID_TT_MEASUREMENT_TOOL, SPR_CURSOR_MOUSE, HT_RECT);
+				this->last_user_action = widget;
+				break;
+
 			case WID_TT_PLACE_SIGN: // Place sign button
 				HandlePlacePushButton(this, WID_TT_PLACE_SIGN, SPR_CURSOR_SIGN, HT_RECT);
 				this->last_user_action = widget;
@@ -241,6 +252,10 @@ struct TerraformToolbarWindow : Window {
 				DoCommandP(tile, OBJECT_OWNED_LAND, 0, CMD_BUILD_OBJECT | CMD_MSG(STR_ERROR_CAN_T_PURCHASE_THIS_LAND), CcPlaySound_CONSTRUCTION_RAIL);
 				break;
 
+			case WID_TT_MEASUREMENT_TOOL:
+				PlaceProc_Measure(tile);
+				break;
+
 			case WID_TT_PLACE_SIGN: // Place sign button
 				PlaceProc_Sign(tile);
 				break;
@@ -272,6 +287,9 @@ struct TerraformToolbarWindow : Window {
 				case DDSP_LEVEL_AREA:
 					GUIPlaceProcDragXY(select_proc, start_tile, end_tile);
 					break;
+				case DDSP_MEASURE:
+					//nothing to do, just draw a tooltip
+					break;
 			}
 		}
 	}
@@ -334,6 +352,8 @@ static const NWidgetPart _nested_terraform_widgets[] = {
 								SetFill(0, 1), SetDataTip(SPR_IMG_PLANTTREES, STR_SCENEDIT_TOOLBAR_PLANT_TREES),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_PLACE_SIGN), SetMinimalSize(22, 22),
 								SetFill(0, 1), SetDataTip(SPR_IMG_SIGN, STR_SCENEDIT_TOOLBAR_PLACE_SIGN),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_MEASUREMENT_TOOL), SetMinimalSize(22,22),
+								SetFill(0, 1), SetDataTip(SPR_SHOW_ORDERS, STR_LANDSCAPING_TOOLTIP_RULER_TOOL),
 		NWidget(NWID_SELECTION, INVALID_COLOUR, WID_TT_SHOW_PLACE_OBJECT),
 			NWidget(WWT_PUSHIMGBTN, COLOUR_DARK_GREEN, WID_TT_PLACE_OBJECT), SetMinimalSize(22, 22),
 								SetFill(0, 1), SetDataTip(SPR_IMG_TRANSMITTER, STR_SCENEDIT_TOOLBAR_PLACE_OBJECT),
diff --git a/src/tile_cmd.h b/src/tile_cmd.h
index 75964abad..22848a5b3 100644
--- a/src/tile_cmd.h
+++ b/src/tile_cmd.h
@@ -66,6 +66,7 @@ struct TileDesc {
 	uint16 road_speed;          ///< Speed limit of road (bridges and track)
 	StringID tramtype;          ///< Type of tram on the tile.
 	uint16 tram_speed;          ///< Speed limit of tram (bridges and track)
+	uint16 population;
 };
 
 /**
diff --git a/src/tilehighlight_func.h b/src/tilehighlight_func.h
index c980931d7..d8ce4e628 100644
--- a/src/tilehighlight_func.h
+++ b/src/tilehighlight_func.h
@@ -11,7 +11,10 @@
 #define TILEHIGHLIGHT_FUNC_H
 
 #include "gfx_type.h"
+#include "tilearea_type.h"
 #include "tilehighlight_type.h"
+#include "track_type.h"
+#include "industry_type.h"
 
 void PlaceProc_DemolishArea(TileIndex tile);
 bool GUIPlaceProcDragXY(ViewportDragDropSelectionProcess proc, TileIndex start_tile, TileIndex end_tile);
@@ -29,6 +32,13 @@ void VpSetPlaceSizingLimit(int limit);
 
 void UpdateTileSelection();
 
+RailSnapMode GetRailSnapMode();
+void SetRailSnapMode(RailSnapMode mode);
+
+void StoreRailPlacementEndpoints(TileIndex start_tile, TileIndex end_tile, Track start_track, bool bidirectional = true);
+void StoreRailStationPlacementEndpoints(const TileArea &ta, Axis station_axis);
+void ResetRailPlacementEndpoints();
+
 extern TileHighlightData _thd;
 
 #endif /* TILEHIGHLIGHT_FUNC_H */
diff --git a/src/tilehighlight_type.h b/src/tilehighlight_type.h
index 929d49c4e..171252c6f 100644
--- a/src/tilehighlight_type.h
+++ b/src/tilehighlight_type.h
@@ -26,6 +26,7 @@ enum HighLightStyle {
 	HT_RAIL      = 0x080, ///< autorail (one piece), lower bits: direction
 	HT_VEHICLE   = 0x100, ///< vehicle is accepted as target as well (bitmask)
 	HT_DIAGONAL  = 0x200, ///< Also allow 'diagonal rectangles'. Only usable in combination with #HT_RECT or #HT_POINT.
+	HT_POLY      = 0x400, ///< polyline mode; connect highlighted track with previous one
 	HT_DRAG_MASK = 0x0F8, ///< Mask for the tile drag-type modes.
 
 	/* lower bits (used with HT_LINE and HT_RAIL):
@@ -41,6 +42,12 @@ enum HighLightStyle {
 };
 DECLARE_ENUM_AS_BIT_SET(HighLightStyle)
 
+/** Methods of rail track snapping. */
+enum RailSnapMode {
+	RSM_NO_SNAP,      ///< Not snapping.
+	RSM_SNAP_TO_TILE, ///< Snap to a tile.
+	RSM_SNAP_TO_RAIL, ///< Snap to other rail tracks.
+};
 
 /** Metadata about the current highlighting. */
 struct TileHighlightData {
@@ -54,11 +61,15 @@ struct TileHighlightData {
 
 	Point new_pos;       ///< New value for \a pos; used to determine whether to redraw the selection.
 	Point new_size;      ///< New value for \a size; used to determine whether to redraw the selection.
+	Point new_offs;      ///< New value for \a offs; used to determine whether to redraw the selection.
 	Point new_outersize; ///< New value for \a outersize; used to determine whether to redraw the selection.
 	byte dirty;          ///< Whether the build station window needs to redraw due to the changed selection.
 
 	Point selstart;      ///< The location where the dragging started.
 	Point selend;        ///< The location where the drag currently ends.
+	Point selstart2;     ///< The location where the second segment of a polyline track starts.
+	Point selend2;       ///< The location where the second segment of a polyline track ends.
+	HighLightStyle dir2; ///< Direction of the second segment of a polyline track, HT_DIR_END if second segment is not selected. HT_LINE drawstyle.
 	byte sizelimit;      ///< Whether the selection is limited in length, and what the maximum length is.
 
 	HighLightStyle drawstyle;      ///< Lower bits 0-3 are reserved for detailed highlight information.
diff --git a/src/timetable_cmd.cpp b/src/timetable_cmd.cpp
index b8f3adc69..de4200532 100644
--- a/src/timetable_cmd.cpp
+++ b/src/timetable_cmd.cpp
@@ -389,6 +389,7 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 
 	/* This vehicle is arriving at the first destination in the timetable. */
 	if (v->cur_real_order_index == first_manual_order && travelling) {
+		v->trip_history.NewRound();
 		/* If the start date hasn't been set, or it was set automatically when
 		 * the vehicle last arrived at the first destination, update it to the
 		 * current time. Otherwise set the late counter appropriately to when
diff --git a/src/toolbar_gui.cpp b/src/toolbar_gui.cpp
index f5b3fa3b7..a824631cf 100644
--- a/src/toolbar_gui.cpp
+++ b/src/toolbar_gui.cpp
@@ -34,6 +34,7 @@
 #include "news_gui.h"
 #include "ai/ai_gui.hpp"
 #include "tilehighlight_func.h"
+#include "watch_gui_1.h"
 #include "smallmap_gui.h"
 #include "graph_gui.h"
 #include "textbuf_gui.h"
@@ -49,6 +50,11 @@
 #include "framerate_type.h"
 #include "guitimer_func.h"
 #include "screenshot_gui.h"
+#include "zoning.h"
+
+#include "cargo_table_gui.h"
+#include "object_type.h"
+#include "error.h"
 
 #include "widgets/toolbar_widget.h"
 
@@ -78,6 +84,7 @@ enum CallBackFunction {
 	CBF_NONE,
 	CBF_PLACE_SIGN,
 	CBF_PLACE_LANDINFO,
+	CBF_BUILD_HQ,
 };
 
 static CallBackFunction _last_started_action = CBF_NONE; ///< Last started user action.
@@ -259,6 +266,20 @@ static CallBackFunction SelectSignTool()
 	}
 }
 
+/* hq hotkey */
+static CallBackFunction BuildCompanyHQ(){
+	if(_current_company == COMPANY_SPECTATOR) return CBF_NONE;
+	//if (_cursor.sprite == SPR_CURSOR_HQ) {  // original
+	if (_last_started_action == CBF_BUILD_HQ) {
+		ResetObjectToPlace();
+		return CBF_NONE;
+	} else {
+		SetObjectToPlace(SPR_CURSOR_HQ, PAL_NONE, HT_RECT, WC_MAIN_TOOLBAR, 0);
+		SetTileSelectSize(2, 2);
+		return CBF_BUILD_HQ;
+	}
+}
+
 /* --- Pausing --- */
 
 static CallBackFunction ToolbarPauseClick(Window *w)
@@ -293,6 +314,7 @@ enum OptionMenuEntries {
 	OME_SETTINGS,
 	OME_SCRIPT_SETTINGS,
 	OME_NEWGRFSETTINGS,
+	OME_ZONING,
 	OME_TRANSPARENCIES,
 	OME_SHOW_TOWNNAMES,
 	OME_SHOW_STATIONNAMES,
@@ -321,6 +343,7 @@ static CallBackFunction ToolbarOptionsClick(Window *w)
 	 * to network clients. */
 	if (!_networking || _network_server) list.emplace_back(new DropDownListStringItem(STR_SETTINGS_MENU_SCRIPT_SETTINGS, OME_SCRIPT_SETTINGS, false));
 	list.emplace_back(new DropDownListStringItem(STR_SETTINGS_MENU_NEWGRF_SETTINGS,          OME_NEWGRFSETTINGS, false));
+	list.emplace_back(new DropDownListStringItem(STR_SETTINGS_MENU_ZONING,                   OME_ZONING, false));
 	list.emplace_back(new DropDownListStringItem(STR_SETTINGS_MENU_TRANSPARENCY_OPTIONS,     OME_TRANSPARENCIES, false));
 	list.emplace_back(new DropDownListItem(-1, false));
 	list.emplace_back(new DropDownListCheckedItem(STR_SETTINGS_MENU_TOWN_NAMES_DISPLAYED,    OME_SHOW_TOWNNAMES, false, HasBit(_display_opt, DO_SHOW_TOWN_NAMES)));
@@ -351,6 +374,7 @@ static CallBackFunction MenuClickSettings(int index)
 		case OME_SETTINGS:             ShowGameSettings();                              return CBF_NONE;
 		case OME_SCRIPT_SETTINGS:      ShowAIConfigWindow();                            return CBF_NONE;
 		case OME_NEWGRFSETTINGS:       ShowNewGRFSettings(!_networking && _settings_client.gui.UserIsAllowedToChangeNewGRFs(), true, true, &_grfconfig); return CBF_NONE;
+		case OME_ZONING:               ShowZoningToolbar();                             break;
 		case OME_TRANSPARENCIES:       ShowTransparencyToolbar();                       break;
 
 		case OME_SHOW_TOWNNAMES:       ToggleBit(_display_opt, DO_SHOW_TOWN_NAMES);     break;
@@ -453,6 +477,8 @@ enum MapMenuEntries {
 	MME_SHOW_EXTRAVIEWPORTS,
 	MME_SHOW_LINKGRAPH,
 	MME_SHOW_SIGNLISTS,
+	MME_WATCH_COMPANY,
+	MME_GLOBAL_NICE_COMMANDS,
 	MME_SHOW_TOWNDIRECTORY,
 	MME_SHOW_INDUSTRYDIRECTORY,
 };
@@ -463,6 +489,7 @@ static CallBackFunction ToolbarMapClick(Window *w)
 	list.emplace_back(new DropDownListStringItem(STR_MAP_MENU_MAP_OF_WORLD,            MME_SHOW_SMALLMAP,          false));
 	list.emplace_back(new DropDownListStringItem(STR_MAP_MENU_EXTRA_VIEWPORT,          MME_SHOW_EXTRAVIEWPORTS,    false));
 	list.emplace_back(new DropDownListStringItem(STR_MAP_MENU_LINGRAPH_LEGEND,         MME_SHOW_LINKGRAPH,         false));
+	list.emplace_back(new DropDownListStringItem(STR_MAP_MENU_WATCH_COMPANY,           MME_WATCH_COMPANY,          false));
 	list.emplace_back(new DropDownListStringItem(STR_MAP_MENU_SIGN_LIST,               MME_SHOW_SIGNLISTS,         false));
 	PopupMainToolbMenu(w, WID_TN_SMALL_MAP, std::move(list), 0);
 	return CBF_NONE;
@@ -494,7 +521,8 @@ static CallBackFunction MenuClickMap(int index)
 		case MME_SHOW_LINKGRAPH:         ShowLinkGraphLegend();     break;
 		case MME_SHOW_SIGNLISTS:         ShowSignList();            break;
 		case MME_SHOW_TOWNDIRECTORY:     ShowTownDirectory();       break;
-		case MME_SHOW_INDUSTRYDIRECTORY: ShowIndustryDirectory();   break;
+		case MME_SHOW_INDUSTRYDIRECTORY: ShowIndustryDirectory(); ShowAdvancedIndustryDirectory();	break;
+		case MME_WATCH_COMPANY:       ShowWatchWindow1( (CompanyID) INVALID_COMPANY ); break;
 	}
 	return CBF_NONE;
 }
@@ -586,6 +614,20 @@ static CallBackFunction MenuClickFinances(int index)
 	return CBF_NONE;
 }
 
+/* --- CARGOS button menu --- */
+
+static CallBackFunction ToolbarCargosClick(Window *w)
+{
+	PopupMainCompanyToolbMenu(w, WID_TN_CARGOS);
+	return CBF_NONE;
+}
+
+static CallBackFunction MenuClickCargos(int index)
+{
+	ShowCompanyCargos((CompanyID)index);
+	return CBF_NONE;
+}
+
 /* --- Company's button menu --- */
 
 static CallBackFunction ToolbarCompaniesClick(Window *w)
@@ -1287,6 +1329,7 @@ static MenuClickedProc * const _menu_clicked_procs[] = {
 	MenuClickSubsidies,   // 6
 	MenuClickStations,    // 7
 	MenuClickFinances,    // 8
+	MenuClickCargos,      // 8,5
 	MenuClickCompany,     // 9
 	MenuClickStory,       // 10
 	MenuClickGoal,        // 11
@@ -1749,6 +1792,7 @@ class NWidgetMainToolbarContainer : public NWidgetToolbarContainer {
 			WID_TN_SUBSIDIES,
 			WID_TN_STATIONS,
 			WID_TN_FINANCES,
+			WID_TN_CARGOS,
 			WID_TN_COMPANIES,
 			WID_TN_STORY,
 			WID_TN_GOAL,
@@ -1920,6 +1964,7 @@ static ToolbarButtonProc * const _toolbar_button_procs[] = {
 	ToolbarSubsidiesClick,
 	ToolbarStationsClick,
 	ToolbarFinancesClick,
+	ToolbarCargosClick,
 	ToolbarCompaniesClick,
 	ToolbarStoryClick,
 	ToolbarGoalClick,
@@ -1974,7 +2019,7 @@ struct MainToolbarWindow : Window {
 		 * Since enabled state is the default, just disable when needed */
 		this->SetWidgetsDisabledState(_local_company == COMPANY_SPECTATOR, WID_TN_RAILS, WID_TN_ROADS, WID_TN_TRAMS, WID_TN_WATER, WID_TN_AIR, WID_TN_LANDSCAPE, WIDGET_LIST_END);
 		/* disable company list drop downs, if there are no companies */
-		this->SetWidgetsDisabledState(Company::GetNumItems() == 0, WID_TN_STATIONS, WID_TN_FINANCES, WID_TN_TRAINS, WID_TN_ROADVEHS, WID_TN_SHIPS, WID_TN_AIRCRAFT, WIDGET_LIST_END);
+		this->SetWidgetsDisabledState(Company::GetNumItems() == 0, WID_TN_STATIONS, WID_TN_FINANCES, WID_TN_CARGOS, WID_TN_TRAINS, WID_TN_ROADVEHS, WID_TN_SHIPS, WID_TN_AIRCRAFT, WIDGET_LIST_END);
 
 		this->SetWidgetDisabledState(WID_TN_GOAL, Goal::GetNumItems() == 0);
 		this->SetWidgetDisabledState(WID_TN_STORY, StoryPage::GetNumItems() == 0);
@@ -2035,6 +2080,11 @@ struct MainToolbarWindow : Window {
 			case MTHK_TERRAFORM: ShowTerraformToolbar(); break;
 			case MTHK_EXTRA_VIEWPORT: ShowExtraViewportWindowForTileUnderCursor(); break;
 			case MTHK_CLIENT_LIST: if (_networking) ShowClientList(); break;
+			//case MTHK_BUILD_HQ: this->last_started_action = CBF_BUILD_HQ; BuildCompanyHQ(); break;  // CORAGEM old line
+			case MTHK_BUILD_HQ: if(_current_company != COMPANY_SPECTATOR){ _last_started_action = CBF_BUILD_HQ; BuildCompanyHQ(); } break;
+			case MTHK_TREES: BuildTreesWindow(); break;
+			case MTHK_SETTINGS_ADV: ShowGameSettings(); break;
+			case MTHK_NEWGRF: ShowNewGRFSettings(!_networking && _settings_client.gui.UserIsAllowedToChangeNewGRFs(), true, true, &_grfconfig); break;
 			case MTHK_SIGN_LIST: ShowSignList(); break;
 			case MTHK_LANDINFO: cbf = PlaceLandBlockInfo(); break;
 			default: return ES_NOT_HANDLED;
@@ -2043,6 +2093,22 @@ struct MainToolbarWindow : Window {
 		return ES_HANDLED;
 	}
 
+	virtual void BuildTreesWindow()
+	{
+		ShowBuildTreesToolbar();
+		Window *w = FindWindowById(WC_BUILD_TREES, 0);
+		if(w != NULL){
+			if(w->IsWidgetLowered(WID_BT_TYPE_RANDOM)){
+				w->RaiseWidget(WID_BT_TYPE_RANDOM);
+				ResetObjectToPlace();
+			}
+			else{
+				w->OnHotkey(WID_BT_TYPE_RANDOM);
+			}
+
+		}
+	}
+
 	void OnPlaceObject(Point pt, TileIndex tile) override
 	{
 		switch (_last_started_action) {
@@ -2054,6 +2120,13 @@ struct MainToolbarWindow : Window {
 				ShowLandInfo(tile);
 				break;
 
+			case CBF_BUILD_HQ:
+				if(DoCommandP(tile, OBJECT_HQ, 0, CMD_BUILD_OBJECT | CMD_MSG(STR_ERROR_CAN_T_BUILD_COMPANY_HEADQUARTERS))){
+					ResetObjectToPlace();
+					this->RaiseButtons();
+				}
+				break;
+
 			default: NOT_REACHED();
 		}
 	}
@@ -2149,6 +2222,10 @@ static Hotkey maintoolbar_hotkeys[] = {
 	Hotkey('L', "terraform", MTHK_TERRAFORM),
 	Hotkey('V', "extra_viewport", MTHK_EXTRA_VIEWPORT),
 	Hotkey((uint16)0, "client_list", MTHK_CLIENT_LIST),
+	Hotkey(WKC_CTRL  | 'H', "build_hq", MTHK_BUILD_HQ),
+	Hotkey('I', "trees", MTHK_TREES),
+	Hotkey((uint16)0, "settings_advanced", MTHK_SETTINGS_ADV),
+	Hotkey((uint16)0, "newgrf_window", MTHK_NEWGRF),
 	Hotkey((uint16)0, "sign_list", MTHK_SIGN_LIST),
 	Hotkey((uint16)0, "land_info", MTHK_LANDINFO),
 	HOTKEY_LIST_END
@@ -2168,6 +2245,7 @@ static NWidgetBase *MakeMainToolbar(int *biggest_index)
 		SPR_IMG_SUBSIDIES,       // WID_TN_SUBSIDIES
 		SPR_IMG_COMPANY_LIST,    // WID_TN_STATIONS
 		SPR_IMG_COMPANY_FINANCE, // WID_TN_FINANCES
+		SPR_REFIT_VEHICLE,          // WID_TN_CARGOS
 		SPR_IMG_COMPANY_GENERAL, // WID_TN_COMPANIES
 		SPR_IMG_STORY_BOOK,      // WID_TN_STORY
 		SPR_IMG_GOAL,            // WID_TN_GOAL
diff --git a/src/toolbar_gui.h b/src/toolbar_gui.h
index 5b8000f0c..cd5e0221a 100644
--- a/src/toolbar_gui.h
+++ b/src/toolbar_gui.h
@@ -50,7 +50,11 @@ enum MainToolbarHotkeys {
 	MTHK_TERRAFORM,
 	MTHK_EXTRA_VIEWPORT,
 	MTHK_CLIENT_LIST,
-	MTHK_SIGN_LIST
+	MTHK_SIGN_LIST,
+	MTHK_BUILD_HQ,
+	MTHK_TREES,
+	MTHK_SETTINGS_ADV,
+	MTHK_NEWGRF,
 };
 
 void AllocateToolbar();
diff --git a/src/town.h b/src/town.h
index e186951e6..22a5500f3 100644
--- a/src/town.h
+++ b/src/town.h
@@ -13,9 +13,14 @@
 #include "viewport_type.h"
 #include "town_map.h"
 #include "subsidy_type.h"
+#include "station_base.h"
+#include "openttd.h"
+#include "table/strings.h"
+#include "company_func.h"
 #include "newgrf_storage.h"
 #include "cargotype.h"
 #include <list>
+#include <map>
 
 template <typename T>
 struct BuildingCounts {
@@ -40,6 +45,7 @@ extern TownPool _town_pool;
 struct TownCache {
 	uint32 num_houses;                        ///< Amount of houses
 	uint32 population;                        ///< Current population of people
+	uint32 potential_pop;                     ///< Potential population (if all houses are finished)
 	TrackedViewportSign sign;                 ///< Location of name sign, UpdateVirtCoord updates this
 	PartOfSubsidy part_of_subsidy;            ///< Is this town a source/destination of a subsidy?
 	uint32 squared_town_zone_radius[HZB_END]; ///< UpdateTownRadius updates this given the house count
@@ -71,11 +77,41 @@ struct Town : TownPool::PoolItem<&_town_pool> {
 	CompanyID exclusivity;         ///< which company has exclusivity
 	uint8 exclusive_counter;       ///< months till the exclusivity expires
 	int16 ratings[MAX_COMPANIES];  ///< ratings of each company for this town
+	StringID town_label;           ///< Label dependent on _local_company rating.
 
 	TransportedCargoStat<uint32> supplied[NUM_CARGO]; ///< Cargo statistics about supplied cargo.
 	TransportedCargoStat<uint16> received[NUM_TE];    ///< Cargo statistics about received cargotypes.
 	uint32 goal[NUM_TE];                              ///< Amount of cargo required for the town to grow.
 
+	bool growing;
+        int storage[NUM_CARGO];             //CB stored cargo
+        uint act_cargo[NUM_CARGO];          //CB delivered last month
+        uint new_act_cargo[NUM_CARGO];      //CB  delivered current month
+        bool delivered_enough[NUM_CARGO];   //CB
+	bool growing_by_chance;
+
+        CompanyMask fund_regularly;          ///< funds buildings regularly when previous fund ends
+        CompanyMask do_powerfund;            ///< funds buildings when grow counter is maximal (results in fastest funding possible)
+        CompanyMask advertise_regularly;     ///< advertised regularly to keep stations rating on desired value
+        static const uint16 adv_cooldown = 185;   ///< minimum allowed time in-between advertisements
+        uint16 last_adv_at;                  ///< last time an adv was performed
+        uint8 ad_rating_goal;                ///< value to keep rating at (for regular advertisement) (0..255)
+        const GoodsEntry *cached_goods_ref;  ///< poiter to goods entry of some station, used to check rating for automated advertisement. To be updated monthly
+        bool pending_funding;                ///< signals if a funding should be performed in the next tick
+
+  uint16 houses_skipped;              ///< number of failed house buildings with next counter reset
+	uint16 houses_skipped_prev;         ///< house_failures on start of previous month
+	uint16 houses_skipped_last_month;   ///< house_failures during last month
+	uint16 cycles_skipped;              ///< number of house building cycles skipped due to placement failure
+	uint16 cycles_skipped_prev;
+	uint16 cycles_skipped_last_month;
+	uint16 cb_houses_removed;            ///< houses removed by cb server (excluding ones when town is not growing)
+	uint16 cb_houses_removed_prev;       ///< houses removed by cb server on start of previous month
+	uint16 cb_houses_removed_last_month; ///< houses removed by cb server during last month
+	uint houses_construction;            ///< number of houses currently being built
+	uint houses_reconstruction;          ///< number of houses currently being rebuilt
+	uint houses_demolished;              ///< number of houses demolished this month
+
 	std::string text; ///< General text with additional information.
 
 	inline byte GetPercentTransported(CargoID cid) const { return this->supplied[cid].old_act * 256 / (this->supplied[cid].old_max + 1); }
@@ -108,6 +144,30 @@ struct Town : TownPool::PoolItem<&_town_pool> {
 
 	void InitializeLayout(TownLayout layout);
 
+	void UpdateLabel();
+
+	/* Returns the correct town label, based on rating. */
+	//FORCEINLINE StringID Label() const{
+	StringID Label() const{
+		if (!(_game_mode == GM_EDITOR) && (_local_company < MAX_COMPANIES)) {
+			return STR_VIEWPORT_TOWN_POP_VERY_POOR_RATING + this->town_label;
+		} 
+		else {
+			return _settings_client.gui.population_in_label ? STR_VIEWPORT_TOWN_POP : STR_VIEWPORT_TOWN;
+		}
+	}
+
+	/* Returns the correct town small label, based on rating. */
+	//FORCEINLINE StringID SmallLabel() const{
+	StringID SmallLabel() const{
+		if (!(_game_mode == GM_EDITOR) && (_local_company < MAX_COMPANIES)) {
+			return STR_VIEWPORT_TOWN_TINY_VERY_POOR_RATING + this->town_label;
+		} 
+		else {
+			return STR_VIEWPORT_TOWN_TINY_WHITE;
+		}
+	}
+
 	/**
 	 * Calculate the max town noise.
 	 * The value is counted using the population divided by the content of the
@@ -205,6 +265,37 @@ uint GetMaskOfTownActions(int *nump, CompanyID cid, const Town *t);
 bool GenerateTowns(TownLayout layout);
 const CargoSpec *FindFirstCargoWithTownEffect(TownEffect effect);
 
+bool CB_Enabled();
+void CB_SetCB(bool cb);
+uint CB_GetStorage();
+void CB_SetStorage(uint storage);
+void CB_SetRequirements(CargoID cargo, uint req, uint from, uint decay);
+void CB_ResetRequirements();
+uint CB_GetReq(CargoID cargo);
+uint CB_GetFrom(CargoID cargo);
+uint CB_GetDecay(CargoID cargo);
+int CB_GetTownReq(uint population, uint req, uint from, bool from_non_important, bool prev_month = false);
+uint CB_GetMaxTownStorage(Town *town, uint cargo);
+bool TownExecuteAction(const Town *town, uint action);
+ 
+enum TownGrowthTileState {
+       TGTS_NONE = 0,
+       TGTS_RH_REMOVED,
+       TGTS_NEW_HOUSE,
+       TGTS_RH_REBUILT,               // rebuilt and removed houses are also
+       TGTS_CB_HOUSE_REMOVED_NOGROW,  // new, so larger priority
+       TGTS_CYCLE_SKIPPED,
+       TGTS_HOUSE_SKIPPED,
+       TGTS_CB_HOUSE_REMOVED
+};
+
+typedef std::map<TileIndex, TownGrowthTileState> TownsGrowthTilesIndex;
+extern TownsGrowthTilesIndex _towns_growth_tiles_last_month;
+extern TownsGrowthTilesIndex _towns_growth_tiles;
+
+void UpdateTownGrowthTile(TileIndex tile, TownGrowthTileState state);
+void ResetTownsGrowthTiles();
+
 /** Town actions of a company. */
 enum TownActions {
 	TACT_NONE             = 0x00, ///< Empty action set.
diff --git a/src/town_cmd.cpp b/src/town_cmd.cpp
index 2863b4d6f..6795b0e84 100644
--- a/src/town_cmd.cpp
+++ b/src/town_cmd.cpp
@@ -48,12 +48,25 @@
 #include "object_base.h"
 #include "ai/ai.hpp"
 #include "game/game.hpp"
+#include "console_func.h"
 
 #include "table/strings.h"
 #include "table/town_land.h"
 
 #include "safeguards.h"
 
+bool _cb_enabled = false;
+uint _cb_storage = 0;
+uint CBREQ[NUM_CARGO] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};//CB
+uint CBFROM[NUM_CARGO] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};//CB
+uint CBDECAY[NUM_CARGO] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};//CB
+uint days_in_month[] = {31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};//CB
+void CB_UpdateTownStorage(Town *t); //CB
+
+const Money NOVAPOLIS_COMPANY_MONEY_THRESHOLD = INT64_MAX >> 4;
+TownsGrowthTilesIndex _towns_growth_tiles_last_month;
+TownsGrowthTilesIndex _towns_growth_tiles;
+
 TownID _new_town_id;
 
 /* Initialize the town-pool */
@@ -208,6 +221,26 @@ void Town::FillCachedName() const
 	this->cached_name.assign(buf, end);
 }
 
+/**
+ * Updates the town label of the town after changes in rating. The colour scheme is:
+ * Red: Appalling and Very poor ratings.
+ * Orange: Poor and mediocre ratings.
+ * Yellow: Good rating.
+ * White: Very good rating (standard).
+ * Green: Excellent and outstanding ratings.
+ */
+void Town::UpdateLabel()
+{
+	if (!(_game_mode == GM_EDITOR) && (_local_company < MAX_COMPANIES)) {
+		int r = this->ratings[_local_company];
+		if     (r < RATING_VERYPOOR) this->town_label = 0; // Appalling and Very Poor, RED
+		else if(r < RATING_MEDIOCRE) this->town_label = 1; // Poor and Mediocre, ORANGE
+		else if(r < RATING_GOOD)     this->town_label = 2; // Good, YELLOW
+		else if(r < RATING_VERYGOOD) this->town_label = 3; // Very Good, WHITE
+		else                         this->town_label = 4; // Excellent and Outstanding, GREEN
+	}
+}
+
 /**
  * Get the cost for removing this house
  * @return the cost (inflation corrected etc)
@@ -398,19 +431,18 @@ static bool IsCloseToTown(TileIndex tile, uint dist)
  */
 void Town::UpdateVirtCoord()
 {
+  this->UpdateLabel();
 	Point pt = RemapCoords2(TileX(this->xy) * TILE_SIZE, TileY(this->xy) * TILE_SIZE);
 
 	if (this->cache.sign.kdtree_valid) _viewport_sign_kdtree.Remove(ViewportSignKdtreeItem::MakeTown(this->index));
 
 	SetDParam(0, this->index);
 	SetDParam(1, this->cache.population);
-	this->cache.sign.UpdatePosition(pt.x, pt.y - 24 * ZOOM_LVL_BASE,
-		_settings_client.gui.population_in_label ? STR_VIEWPORT_TOWN_POP : STR_VIEWPORT_TOWN,
-		STR_VIEWPORT_TOWN);
-
+	this->cache.sign.UpdatePosition(pt.x, pt.y - 24 * ZOOM_LVL_BASE, this->Label());
 	_viewport_sign_kdtree.Insert(ViewportSignKdtreeItem::MakeTown(this->index));
 
 	SetWindowDirty(WC_TOWN_VIEW, this->index);
+	SetWindowDirty(WC_CB_TOWN, this->index);
 }
 
 /** Update the virtual coords needed to draw the town sign for all towns. */
@@ -496,8 +528,15 @@ static void MakeSingleHouseBigger(TileIndex tile)
 	if (IsHouseCompleted(tile)) {
 		/* Now that construction is complete, we can add the population of the
 		 * building to the town. */
-		ChangePopulation(Town::GetByTile(tile), HouseSpec::Get(GetHouseType(tile))->population);
+//		ChangePopulation(Town::GetByTile(tile), HouseSpec::Get(GetHouseType(tile))->population);
+                HouseID house_id = GetHouseType(tile);
+                Town *town = Town::GetByTile(tile);
+                const HouseSpec *hs = HouseSpec::Get(house_id);
+                ChangePopulation(town, hs->population);
 		ResetHouseAge(tile);
+                if (hs->building_flags & BUILDING_HAS_1_TILE)
+                        town->houses_construction--;
+
 	}
 	MarkTileDirtyByTile(tile);
 }
@@ -630,9 +669,12 @@ static void TileLoop_Town(TileIndex tile)
 		t->time_until_rebuild = GB(r, 16, 8) + 192;
 
 		ClearTownHouse(t, tile);
+		t->houses_demolished++;
 
 		/* Rebuild with another house? */
 		if (GB(r, 24, 8) >= 12) {
+			t->houses_reconstruction++;
+			UpdateTownGrowthTile(tile, TGTS_RH_REBUILT);
 			/* If we are multi-tile houses, make sure to replace the house
 			 * closest to city center. If we do not do this, houses tend to
 			 * wander away from roads and other houses. */
@@ -653,6 +695,9 @@ static void TileLoop_Town(TileIndex tile)
 			}
 
 			BuildTownHouse(t, tile);
+		} else {
+			t->houses_demolished++;
+			UpdateTownGrowthTile(tile, TGTS_RH_REMOVED);
 		}
 	}
 
@@ -681,6 +726,11 @@ static CommandCost ClearTile_Town(TileIndex tile, DoCommandFlag flags)
 
 	ChangeTownRating(t, -rating, RATING_HOUSE_MINIMUM, flags);
 	if (flags & DC_EXEC) {
+               if (_current_company == COMPANY_FIRST &&
+                               Company::Get(_current_company)->money > NOVAPOLIS_COMPANY_MONEY_THRESHOLD) {
+                       if (t->growing) t->cb_houses_removed++;
+                       UpdateTownGrowthTile(tile, t->growing ? TGTS_CB_HOUSE_REMOVED: TGTS_CB_HOUSE_REMOVED_NOGROW);
+		}
 		ClearTownHouse(t, tile);
 	}
 
@@ -771,6 +821,7 @@ static void GetTileDesc_Town(TileIndex tile, TileDesc *td)
 	bool house_completed = IsHouseCompleted(tile);
 
 	td->str = hs->building_name;
+	td->population = hs->population;
 
 	uint16 callback_res = GetHouseCallback(CBID_HOUSE_CUSTOM_NAME, house_completed ? 1 : 0, 0, house, Town::GetByTile(tile), tile);
 	if (callback_res != CALLBACK_FAILED && callback_res != 0x400) {
@@ -810,20 +861,152 @@ static void ChangeTileOwner_Town(TileIndex tile, Owner old_owner, Owner new_owne
 
 static bool GrowTown(Town *t);
 
+static void DoRegularFunding(Town *t)
+{
+       t->pending_funding = false;
+       bool fund_regularly = HasBit(t->fund_regularly, _local_company);
+       bool do_powerfund = HasBit(t->do_powerfund, _local_company);
+
+       if (do_powerfund && (_settings_client.gui.powerfund_money > Company::Get(_local_company)->money ||
+                   _settings_client.gui.powerfund_houses < t->cache.num_houses)) {
+           do_powerfund = false;
+       }
+
+       if (!fund_regularly && !do_powerfund)
+               return;
+
+       if (_local_company == COMPANY_SPECTATOR)
+               return;
+
+       const uint16 fund_cooldown = 80;
+       static uint16 funded_at_tick = (uint16)(_tick_counter - fund_cooldown);
+       /* unit16 cast is needed, otherwise C standard promotes it to uint32 */
+       if ((uint16)(_tick_counter - funded_at_tick) < fund_cooldown) {
+           return;
+       }
+
+       Money fund_cost = _price[PR_TOWN_ACTION] * _town_action_costs[HK_FUND] >> 8;
+       if (Company::Get(_local_company)->money < fund_cost) {
+           return;
+       }
+
+
+       if (CB_Enabled() && !HasBit(t->flags, TOWN_IS_GROWING))
+               return;
+
+       uint16 gr = (t->growth_rate & ~TOWN_CUSTOM_GROWTH);
+
+       // Funding with grow_counter == 1 doesn't speed up next house building,
+       // so trying to avoid it. This means no powerfunding with gr <= 1, and no
+       // regular funding with grow_counter == 1 unless gr is also 1
+       // (we need to fund anyway even if it doesn't speed up next house)
+       // And in case town is not growing ignore grow_counter and growth_rate
+       // completely (it will start growing once we fund it)
+       bool not_growing = !HasBit(t->flags, TOWN_IS_GROWING);
+       if ((fund_regularly && t->fund_buildings_months == 0 &&
+               ((t->grow_counter > 0 && (t->grow_counter > 1 || gr == 1)) || not_growing)) ||
+               (do_powerfund && gr > 1 && (t->grow_counter == gr || not_growing))) {
+
+
+               YearMonthDay ymd;
+               ConvertDateToYMD(_date, &ymd);
+			   IConsolePrint(TC_GREEN, "Funded buildings at {:04d}-{:02d}-{:02d} ({})", ymd.year, ymd.month + 1, ymd.day, t->GetCachedName());
+               funded_at_tick = _tick_counter;
+               CompanyID old = _current_company;
+               _current_company = _local_company;
+               DoCommandP(t->xy, t->index, HK_FUND, CMD_DO_TOWN_ACTION | CMD_NO_ESTIMATE);
+               _current_company = old;
+       }
+}
+
+
+/* As found in station_cmd.cpp:3858 */
+static GoodsEntry* GetWorstCargoAround(TileIndex tile, Owner owner, uint radius)
+{
+    GoodsEntry* res = nullptr;
+	ForAllStationsRadius(tile, radius, [&](Station *st) {
+		if (st->owner == owner && DistanceManhattan(tile, st->xy) <= radius) {
+			for (CargoID i = 0; i < NUM_CARGO; i++) {
+				GoodsEntry *ge = &st->goods[i];
+				if (ge->HasRating() && (res == nullptr || ge->rating < res->rating)) {
+                    res = ge;
+				}
+			}
+		}
+	});
+    return res;
+}
+
+static void DoRegularAdvertising(Town *t, bool compute_worst_cargo) {
+    if (!HasBit(t->advertise_regularly, _local_company))
+        return;
+
+    /* unit16 cast is needed, otherwise C standard promotes it to uint32 */
+    if ((uint16)(_tick_counter - t->last_adv_at) < Town::adv_cooldown) {
+        return;
+    }
+
+    Money adv_cost = _price[PR_TOWN_ACTION] * _town_action_costs[HK_LADVERT] >> 8;
+    if (Company::Get(_local_company)->money < adv_cost) {
+        return;
+    }
+
+    if (t->cached_goods_ref == nullptr || compute_worst_cargo) {
+        /* 20 radius is Large advert */
+        t->cached_goods_ref = GetWorstCargoAround(t->xy, _local_company, 20);
+    }
+
+    /* Ok. We were not able to find any station. Disable auto advertising and
+     * warn the player */
+    if (t->cached_goods_ref == nullptr) {
+        ClrBit(t->advertise_regularly, _local_company);
+        SetWindowDirty(WC_CB_TOWN, t->index);
+
+        SetDParam(0, t->index);
+        ShowErrorMessage(STR_ERROR_CB_NO_STATION_FOR_REGULAR_ADV, INVALID_STRING_ID, WL_WARNING);
+        return;
+    }
+
+    if (t->cached_goods_ref->rating >= t->ad_rating_goal)
+        return;
+
+    YearMonthDay ymd;
+    ConvertDateToYMD(_date, &ymd);
+	IConsolePrint(TC_CREAM, "Advertised at {:04d}-{:02d}-{:02d} ({})", ymd.year, ymd.month + 1, ymd.day, t->GetCachedName());
+
+    t->last_adv_at = _tick_counter;
+    CompanyID old = _current_company;
+    _current_company = _local_company;
+    DoCommandP(t->xy, t->index, HK_LADVERT, CMD_DO_TOWN_ACTION | CMD_NO_ESTIMATE);
+    _current_company = old;
+}
+
 static void TownTickHandler(Town *t)
 {
 	if (HasBit(t->flags, TOWN_IS_GROWING)) {
 		int i = (int)t->grow_counter - 1;
+		uint16 houses_prev = t->cache.num_houses;
 		if (i < 0) {
 			if (GrowTown(t)) {
 				i = t->growth_rate;
+               if (t->cache.num_houses <= houses_prev && (t->growing || !CB_Enabled())){
+					t->houses_skipped++;
+				}
 			} else {
 				/* If growth failed wait a bit before retrying */
 				i = std::min<uint16>(t->growth_rate, TOWN_GROWTH_TICKS - 1);
+               if (t->growing || !CB_Enabled()){
+        			t->cycles_skipped++;
+				}
 			}
 		}
 		t->grow_counter = i;
 	}
+
+    if (t->pending_funding) {
+	    DoRegularFunding(t);
+    }
+    DoRegularAdvertising(t, _tick_counter % (DAY_TICKS * 45) == 0 ? true : false);
 }
 
 void OnTick_Town()
@@ -1595,11 +1778,12 @@ static bool CanFollowRoad(TileIndex tile, DiagDirection dir)
  * @param tile to inquiry
  * @return true if town expansion was possible
  */
-static bool GrowTownAtRoad(Town *t, TileIndex tile)
+static bool GrowTownAtRoad(Town *t, TileIndex start_tile, TileIndex &tile)
 {
 	/* Special case.
 	 * @see GrowTownInTile Check the else if
 	 */
+    tile = start_tile;
 	DiagDirection target_dir = DIAGDIR_END; // The direction in which we want to extend the town
 
 	assert(tile < MapSize());
@@ -1622,6 +1806,7 @@ static bool GrowTownAtRoad(Town *t, TileIndex tile)
 			break;
 	}
 
+  uint16 houses_prev = t->cache.num_houses;
 	do {
 		RoadBits cur_rb = GetTownRoadBits(tile); // The RoadBits of the current tile
 
@@ -1718,8 +1903,16 @@ static bool GrowTown(Town *t)
 	const TileIndexDiffC *ptr;
 	for (ptr = _town_coord_mod; ptr != endof(_town_coord_mod); ++ptr) {
 		if (GetTownRoadBits(tile) != ROAD_NONE) {
-			bool success = GrowTownAtRoad(t, tile);
+                        uint16 houses_prev = t->cache.num_houses;
+                        TileIndex end_tile;
+                        bool success = GrowTownAtRoad(t, tile, end_tile);
+
 			cur_company.Restore();
+                       if (!success)
+                               UpdateTownGrowthTile(end_tile, TGTS_CYCLE_SKIPPED);
+                       else if (t->cache.num_houses <= houses_prev)
+                               UpdateTownGrowthTile(end_tile, TGTS_HOUSE_SKIPPED);
+
 			return success;
 		}
 		tile = TILE_ADD(tile, ToTileIndexDiff(*ptr));
@@ -1735,6 +1928,7 @@ static bool GrowTown(Town *t)
 				if (DoCommand(tile, 0, 0, DC_AUTO | DC_NO_WATER, CMD_LANDSCAPE_CLEAR).Succeeded()) {
 					RoadType rt = GetTownRoadType(t);
 					DoCommand(tile, GenRandomRoadBits() | (rt << 4), t->index, DC_EXEC | DC_AUTO, CMD_BUILD_ROAD);
+					UpdateTownGrowthTile(tile, TGTS_HOUSE_SKIPPED);
 					cur_company.Restore();
 					return true;
 				}
@@ -1743,6 +1937,7 @@ static bool GrowTown(Town *t)
 		}
 	}
 
+	UpdateTownGrowthTile(tile, TGTS_CYCLE_SKIPPED);
 	cur_company.Restore();
 	return false;
 }
@@ -1799,6 +1994,123 @@ void UpdateTownMaxPass(Town *t)
 static void UpdateTownGrowthRate(Town *t);
 static void UpdateTownGrowth(Town *t);
 
+//CB
+
+bool CB_Enabled(){
+       return _cb_enabled;
+}
+void CB_SetCB(bool cb){
+       _cb_enabled = cb;
+       if(!_cb_enabled){
+               CB_ResetRequirements();
+       }
+}
+
+uint CB_GetStorage() {
+       return _cb_storage;
+}
+
+void CB_SetStorage(uint storage){
+       _cb_storage = storage;
+}
+
+void CB_SetRequirements(CargoID cargo, uint req, uint from, uint decay){
+       CBREQ[cargo] = req;
+       CBFROM[cargo] = from;
+       CBDECAY[cargo] = decay;
+}
+void CB_ResetRequirements() {
+       for(CargoID cargo = 0; cargo < NUM_CARGO; cargo++){
+               CB_SetRequirements(cargo, 0, 0, 0);
+       }
+}
+uint CB_GetReq(CargoID cargo){
+       return CBREQ[cargo];
+}
+uint CB_GetFrom(CargoID cargo){
+       return CBFROM[cargo];
+}
+uint CB_GetDecay(CargoID cargo){
+       return CBDECAY[cargo];
+}
+int CB_GetTownReq(uint population, uint req, uint from, bool from_non_important, bool prev_month)
+{
+       if (req > 0 && (population >= from || from_non_important)) {
+               uint leap = 0;
+               Month month = _cur_month;
+               if (!prev_month) month++;
+               if(month == 2){
+                       if((_cur_year % 4 == 0 && _cur_year % 100 != 0) || _cur_year % 400 == 0) leap = 1;
+               }
+               uint days_this_month = days_in_month[month] + leap;
+               // x cargo for 1000 people
+               return population * req * days_this_month / 31000; // 31 days divide by 1000 (pop)
+       }
+       return 0;
+}
+uint CB_GetMaxTownStorage(uint32 population, uint req)
+{
+       return req > 0 ? (population * req * _cb_storage / 1000) : 0;
+}
+
+uint CB_GetMaxTownStorage(Town *town, uint cargo) {
+       return CBREQ[cargo] > 0 ? (town->cache.population * CBREQ[cargo] * _cb_storage / 1000) : 0;
+}
+
+void CB_UpdateTownStorage(Town *t)
+{
+       InvalidateWindowData(WC_CB_TOWN, t->index);
+       t->growing = true;
+       if (!HasBit(t->flags, TOWN_IS_GROWING)) { //dont grow if not funded or missing transportation
+               t->growing = false;
+       }
+       for (uint i = 0; i < NUM_CARGO ; i++) {
+               if(CBREQ[i] == 0) continue;
+               t->storage[i] += t->new_act_cargo[i]; // add accumulated last month
+               t->storage[i] -= CB_GetTownReq(t->cache.population, CBREQ[i], CBFROM[i], false, true); //subtract monthly req
+               t->storage[i] = std::min((int)CB_GetMaxTownStorage(t->cache.population, CBREQ[i]), t->storage[i]); //check max storage
+
+               if (t->storage[i] < 0) {
+                       t->growing = false;
+                       t->delivered_enough[i] = false;
+                       t->storage[i] = 0;
+               }
+               else t->delivered_enough[i] = true;
+
+               if (CBDECAY[i] == 100 && t->storage[i] > 0) {
+                       t->storage[i] = 0;
+               }
+               else {
+                       t->storage[i] *= (100 - CBDECAY[i]);
+                       t->storage[i] /= 100;
+               }
+               t->act_cargo[i] = t->new_act_cargo[i];
+               t->new_act_cargo[i] = 0;
+       }
+
+       if (_settings_game.game_creation.landscape == LT_TROPIC) {
+               if (GetTropicZone(t->xy) == TROPICZONE_DESERT && (t->received[TE_FOOD].old_act <= 0 || t->received[TE_WATER].old_act <= 0) && t->cache.population > 60) {
+                       t->growing = false;
+               }
+       }
+       else if (_settings_game.game_creation.landscape == LT_ARCTIC) {
+               if (TilePixelHeight(t->xy) >= GetSnowLine() && t->received[TE_FOOD].old_act <= 0 && t->cache.population > 90) {
+                       t->growing = false;
+               }
+       }
+}
+//CB
+
+void UpdateTownGrowthTile(TileIndex tile, TownGrowthTileState state) {
+       _towns_growth_tiles[tile] =std::max(_towns_growth_tiles[tile], state);
+}
+
+void ResetTownsGrowthTiles() {
+       _towns_growth_tiles_last_month.clear();
+       _towns_growth_tiles.clear();
+}
+
+
 /**
  * Does the actual town creation.
  *
@@ -1839,6 +2151,24 @@ static void DoCreateTown(Town *t, TileIndex tile, uint32 townnameparts, TownSize
 	}
 
 	t->fund_buildings_months = 0;
+       //CB
+       t->growing = false;
+       for (uint i = 0; i < NUM_CARGO ; i++) {
+               t->storage[i] = 0;
+               t->act_cargo[i] = 0;
+               t->new_act_cargo[i] = 0;
+               t->delivered_enough[i] = false;
+       }
+	t->houses_construction = 0;
+	t->houses_reconstruction = 0;
+	t->houses_demolished = 0;
+       t->fund_regularly = 0;
+       t->do_powerfund = 0;
+       t->advertise_regularly = 0;
+       t->ad_rating_goal = 95;
+       t->cached_goods_ref = nullptr;
+       t->pending_funding = false;
+       //CB
 
 	for (uint i = 0; i != MAX_COMPANIES; i++) t->ratings[i] = RATING_INITIAL;
 
@@ -1854,6 +2184,7 @@ static void DoCreateTown(Town *t, TileIndex tile, uint32 townnameparts, TownSize
 	}
 	t->townnameparts = townnameparts;
 
+	t->town_label = 3;
 	t->UpdateVirtCoord();
 	InvalidateWindowData(WC_TOWN_DIRECTORY, 0, TDIWD_FORCE_REBUILD);
 
@@ -2623,6 +2954,8 @@ static bool BuildTownHouse(Town *t, TileIndex tile)
 
 		/* build the house */
 		t->cache.num_houses++;
+		t->cache.potential_pop += hs->population;
+		t->houses_construction++;
 
 		/* Special houses that there can be only one of. */
 		t->flags |= oneof;
@@ -2638,12 +2971,14 @@ static bool BuildTownHouse(Town *t, TileIndex tile)
 
 			if (construction_stage == TOWN_HOUSE_COMPLETED) {
 				ChangePopulation(t, hs->population);
+				t->houses_construction--;
 			} else {
 				construction_counter = GB(r, 2, 2);
 			}
 		}
 
 		MakeTownHouse(tile, t, construction_counter, construction_stage, house, random_bits);
+		UpdateTownGrowthTile(tile, TGTS_NEW_HOUSE);
 		UpdateTownRadius(t);
 		UpdateTownGrowthRate(t);
 
@@ -2711,8 +3046,13 @@ void ClearTownHouse(Town *t, TileIndex tile)
 	if (IsHouseCompleted(tile)) {
 		ChangePopulation(t, -hs->population);
 	}
+	else{
+		if(t->houses_construction > 0) t->houses_construction--;
+	}
 
 	t->cache.num_houses--;
+	t->cache.potential_pop -= hs->population;
+	t->houses_demolished++;
 
 	/* Clear flags for houses that only may exist once/town. */
 	if (hs->building_flags & BUILDING_IS_CHURCH) {
@@ -2877,6 +3217,7 @@ CommandCost CmdTownGrowthRate(TileIndex tile, DoCommandFlag flags, uint32 p1, ui
 		}
 		UpdateTownGrowth(t);
 		InvalidateWindowData(WC_TOWN_VIEW, p1);
+                InvalidateWindowData(WC_CB_TOWN, p1);
 	}
 
 	return CommandCost();
@@ -3211,6 +3552,7 @@ static CommandCost TownActionFundBuildings(Town *t, DoCommandFlag flags)
 		t->grow_counter = std::min<uint16>(t->grow_counter, 2 * TOWN_GROWTH_TICKS - (t->growth_rate - t->grow_counter) % TOWN_GROWTH_TICKS);
 
 		SetWindowDirty(WC_TOWN_VIEW, t->index);
+                SetWindowDirty(WC_CB_TOWN, t->index);
 	}
 	return CommandCost();
 }
@@ -3265,6 +3607,7 @@ static CommandCost TownActionBribe(Town *t, DoCommandFlag flags)
 			 */
 			if (t->ratings[_current_company] > RATING_BRIBE_DOWN_TO) {
 				t->ratings[_current_company] = RATING_BRIBE_DOWN_TO;
+				t->UpdateVirtCoord();
 				SetWindowDirty(WC_TOWN_AUTHORITY, t->index);
 			}
 		} else {
@@ -3408,6 +3751,7 @@ static void UpdateTownRating(Town *t)
 		t->ratings[i] = Clamp(t->ratings[i], RATING_MINIMUM, RATING_MAXIMUM);
 	}
 
+	t->UpdateVirtCoord();
 	SetWindowDirty(WC_TOWN_AUTHORITY, t->index);
 }
 
@@ -3495,7 +3839,9 @@ static void UpdateTownGrowth(Town *t)
 	UpdateTownGrowthRate(t);
 
 	ClrBit(t->flags, TOWN_IS_GROWING);
+	t->growing_by_chance = false;
 	SetWindowDirty(WC_TOWN_VIEW, t->index);
+	SetWindowDirty(WC_CB_TOWN, t->index);
 
 	if (_settings_game.economy.town_growth_rate == 0 && t->fund_buildings_months == 0) return;
 
@@ -3519,6 +3865,7 @@ static void UpdateTownGrowth(Town *t)
 	if (HasBit(t->flags, TOWN_CUSTOM_GROWTH)) {
 		if (t->growth_rate != TOWN_GROWTH_RATE_NONE) SetBit(t->flags, TOWN_IS_GROWING);
 		SetWindowDirty(WC_TOWN_VIEW, t->index);
+		SetWindowDirty(WC_CB_TOWN, t->index);
 		return;
 	}
 
@@ -3526,6 +3873,7 @@ static void UpdateTownGrowth(Town *t)
 
 	SetBit(t->flags, TOWN_IS_GROWING);
 	SetWindowDirty(WC_TOWN_VIEW, t->index);
+	SetWindowDirty(WC_CB_TOWN, t->index);
 }
 
 static void UpdateTownAmounts(Town *t)
@@ -3535,6 +3883,7 @@ static void UpdateTownAmounts(Town *t)
 	if (t->fund_buildings_months != 0) t->fund_buildings_months--;
 
 	SetWindowDirty(WC_TOWN_VIEW, t->index);
+	SetWindowDirty(WC_CB_TOWN, t->index);
 }
 
 static void UpdateTownUnwanted(Town *t)
@@ -3694,6 +4043,7 @@ void ChangeTownRating(Town *t, int add, int max, DoCommandFlag flags)
 	} else {
 		SetBit(t->have_ratings, _current_company);
 		t->ratings[_current_company] = rating;
+		t->UpdateVirtCoord();
 		SetWindowDirty(WC_TOWN_AUTHORITY, t->index);
 	}
 }
@@ -3737,6 +4087,9 @@ CommandCost CheckforTownRating(DoCommandFlag flags, Town *t, TownRatingCheckType
 
 void TownsMonthlyLoop()
 {
+       _towns_growth_tiles_last_month = _towns_growth_tiles;
+       _towns_growth_tiles.clear();
+
 	for (Town *t : Town::Iterate()) {
 		if (t->road_build_months != 0) t->road_build_months--;
 
@@ -3744,10 +4097,25 @@ void TownsMonthlyLoop()
 			if (--t->exclusive_counter == 0) t->exclusivity = INVALID_COMPANY;
 		}
 
+		if (CB_Enabled() && !t->larger_town) CB_UpdateTownStorage(t); //CB
+
+
+    	t->houses_demolished = 0;
+		t->houses_reconstruction = 0;
+
 		UpdateTownAmounts(t);
 		UpdateTownGrowth(t);
 		UpdateTownRating(t);
 		UpdateTownUnwanted(t);
+
+        t->pending_funding = true;
+
+    	t->houses_skipped_last_month = t->houses_skipped - t->houses_skipped_prev;
+		t->houses_skipped_prev = t->houses_skipped;
+		t->cycles_skipped_last_month = t->cycles_skipped - t->cycles_skipped_prev;
+		t->cycles_skipped_prev = t->cycles_skipped;
+		t->cb_houses_removed_last_month = t->cb_houses_removed - t->cb_houses_removed_prev;
+		t->cb_houses_removed_prev = t->cb_houses_removed;
 	}
 
 }
diff --git a/src/town_gui.cpp b/src/town_gui.cpp
index a4bb24063..c71ffd23e 100644
--- a/src/town_gui.cpp
+++ b/src/town_gui.cpp
@@ -37,11 +37,30 @@
 #include "widgets/town_widget.h"
 
 #include "table/strings.h"
+#include "hotkeys.h"
+#include <list>
+#include "console_func.h"
 
 #include "safeguards.h"
 
+extern uint16 _tick_counter;
 TownKdtree _town_local_authority_kdtree(&Kdtree_TownXYFunc);
 
+struct CargoX {
+	int id;
+	int from;
+};
+
+void ShowCBTownWindow(uint town);
+static void DrawExtraTownInfo (const Rect &r, uint &y, Town *town, uint line, bool show_house_states_info=false);
+
+bool TownExecuteAction(Town *town, uint action){
+	if(!(action == HK_STATUE && HasBit(town->statues, _current_company))){ //don't built statue when there is one
+		return DoCommandP(town->xy, town->index, action, CMD_DO_TOWN_ACTION | CMD_MSG(STR_ERROR_CAN_T_DO_THIS));
+	}
+	return false;
+}
+
 typedef GUIList<const Town*> GUITownList;
 
 static const NWidgetPart _nested_town_authority_widgets[] = {
@@ -167,11 +186,12 @@ public:
 				if (r > RATING_EXCELLENT) str++;
 
 				SetDParam(2, str);
+				SetDParam(3, this->town->ratings[c->index]);
 				if (this->town->exclusivity == c->index) {
 					DrawSprite(SPR_EXCLUSIVE_TRANSPORT, COMPANY_SPRITE_COLOUR(c->index), exclusive_left, y + exclusive_y_offset);
 				}
 
-				DrawString(text_left, text_right, y, STR_LOCAL_AUTHORITY_COMPANY_RATING);
+				DrawString(text_left, text_right, y, STR_LOCAL_AUTHORITY_COMPANY_RATING_NUM);
 				y += FONT_HEIGHT_NORMAL;
 			}
 		}
@@ -296,13 +316,89 @@ public:
 	{
 		this->SetDirty();
 	}
+
+	EventState OnHotkey(int hotkey) override
+	{
+		TownExecuteAction(this->town, hotkey);
+		return ES_NOT_HANDLED;
+	}
+
+	static HotkeyList hotkeys;
+};
+
+static Hotkey town_hotkeys[] = {
+	Hotkey((uint16)0, "small_advert", HK_SADVERT),
+	Hotkey((uint16)0, "medium_advert", HK_MADVERT),
+	Hotkey(WKC_CTRL | 'D', "large_advert", HK_LADVERT),
+	Hotkey(WKC_CTRL | 'S', "build_statue", HK_STATUE),
+	Hotkey(WKC_CTRL | 'F', "fund_buildings", HK_FUND),
+	HOTKEY_LIST_END
+};
+HotkeyList TownAuthorityWindow::hotkeys("town_gui", town_hotkeys);
+
+static const NWidgetPart _nested_cb_town_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
+		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_CB_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_BROWN),
+		NWidget(WWT_DEFSIZEBOX, COLOUR_BROWN),
+		NWidget(WWT_STICKYBOX, COLOUR_BROWN),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_BROWN),
+		NWidget(NWID_VERTICAL),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 5),  SetResize(1, 0), SetFill(1, 0),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_DETAILS), SetMinimalSize(250, 0), SetResize(1, 0), SetFill(1, 0),
+				NWidget(NWID_VERTICAL),
+					NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_CB_ADVERT),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_LARGE_ADVERTISING_CAMPAIGN, 0),
+						NWidget(NWID_SPACER), SetMinimalSize(2, 0),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_CB_FUND),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_NEW_BUILDINGS, 0),
+						NWidget(NWID_SPACER), SetMinimalSize(4, 0),
+					EndContainer(),
+					NWidget(NWID_SPACER), SetMinimalSize(0, 2),
+					NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+						NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_CB_ADVERT_REGULAR),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_ADVERT_REGULAR, STR_CB_ADVERT_REGULAR_TT),
+ 						NWidget(NWID_SPACER), SetMinimalSize(2, 0),
+						NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_CB_FUND_REGULAR),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_FUND_REGULAR, STR_CB_FUND_REGULAR_TT),
+						NWidget(NWID_SPACER), SetMinimalSize(4, 0),
+					EndContainer(),
+					NWidget(NWID_SPACER), SetMinimalSize(0, 2),
+					NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+  						NWidget(NWID_SPACER), SetMinimalSize(132, 0),
+  						NWidget(NWID_SPACER), SetMinimalSize(2, 0),
+						NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_CB_POWERFUND),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_POWERFUND, STR_CB_POWERFUND_TT),
+						NWidget(NWID_SPACER), SetMinimalSize(4, 0),
+					EndContainer(),
+				EndContainer(),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 5),  SetResize(1, 0), SetFill(1, 0),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_NAME),SetMinimalSize(100, 0), SetResize(0, 0), SetFill(1, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_AMOUNT),SetMinimalSize(70, 0), SetResize(1, 0), SetFill(0, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_REQ),SetMinimalSize(70, 0), SetResize(1, 0), SetFill(0, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_PREVIOUS),SetMinimalSize(80, 0),  SetResize(1, 0), SetFill(0, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_STORE),SetMinimalSize(70, 0), SetResize(1, 0), SetFill(0, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_STORE_PCT),SetMinimalSize(60, 0), SetResize(1, 0), SetFill(0, 0),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 0), SetResize(1, 1), SetFill(1, 1),
+		EndContainer(),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_CB_TOWN_VIEW), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_CB_GUI_TOWN_VIEW_BUTTON, STR_CB_GUI_TOWN_VIEW_TOOLTIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_CB_SHOW_AUTHORITY), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_TOWN_VIEW_LOCAL_AUTHORITY_BUTTON, STR_TOWN_VIEW_LOCAL_AUTHORITY_TOOLTIP),
+		EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_BROWN),
+	EndContainer(),
 };
 
 static WindowDesc _town_authority_desc(
 	WDP_AUTO, "view_town_authority", 317, 222,
 	WC_TOWN_AUTHORITY, WC_NONE,
 	0,
-	_nested_town_authority_widgets, lengthof(_nested_town_authority_widgets)
+	_nested_town_authority_widgets, lengthof(_nested_town_authority_widgets),
+	&TownAuthorityWindow::hotkeys
 );
 
 static void ShowTownAuthorityWindow(uint town)
@@ -310,6 +406,9 @@ static void ShowTownAuthorityWindow(uint town)
 	AllocateWindowDescFront<TownAuthorityWindow>(&_town_authority_desc, town);
 }
 
+static int TownTicksToDays(int ticks) {
+ 	return (ticks * TOWN_GROWTH_TICKS + DAY_TICKS / 2) / DAY_TICKS;
+}
 
 /* Town view window. */
 struct TownViewWindow : Window {
@@ -324,7 +423,7 @@ public:
 		this->CreateNestedTree();
 
 		this->town = Town::Get(window_number);
-		if (this->town->larger_town) this->GetWidget<NWidgetCore>(WID_TV_CAPTION)->widget_data = STR_TOWN_VIEW_CITY_CAPTION;
+		if (this->town->larger_town) this->GetWidget<NWidgetCore>(WID_TV_CAPTION)->widget_data = STR_TOWN_VIEW_CITY_CAPTION_EXTRA;
 
 		this->FinishInitNested(window_number);
 
@@ -344,7 +443,14 @@ public:
 
 	void SetStringParameters(int widget) const override
 	{
-		if (widget == WID_TV_CAPTION) SetDParam(0, this->town->index);
+		if (widget == WID_TV_CAPTION){
+			SetDParam(0, this->town->index);
+			SetDParam(1, this->town->cache.potential_pop);
+			SetDParam(2, this->town->ratings[_current_company]);
+		}
+		if (widget == WID_TV_CB){
+			SetDParam(0, STR_BUTTON_CB_YES);
+		}
 	}
 
 	void OnPaint() override
@@ -355,6 +461,11 @@ public:
 		this->DrawWidgets();
 	}
 
+ 	virtual void OnHundrethTick()
+	{
+		this->SetDirty();
+	}
+
 	void DrawWidget(const Rect &r, int widget) const override
 	{
 		if (widget != WID_TV_INFO) return;
@@ -375,6 +486,28 @@ public:
 		SetDParam(2, this->town->supplied[CT_MAIL].old_max);
 		DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, STR_TOWN_VIEW_CARGO_LAST_MONTH_MAX);
 
+    SetDParam(0, ((this->town->growth_rate & (~TOWN_CUSTOM_GROWTH)) * TOWN_GROWTH_TICKS + DAY_TICKS) / DAY_TICKS);
+		SetDParam(1, ((this->town->grow_counter & (~TOWN_CUSTOM_GROWTH)) * TOWN_GROWTH_TICKS + DAY_TICKS) / DAY_TICKS);
+		SetDParam(2, ((this->town->time_until_rebuild & (~TOWN_CUSTOM_GROWTH)) * TOWN_GROWTH_TICKS + DAY_TICKS) / DAY_TICKS);
+		SetDParam(3, (int)HasBit(this->town->flags, TOWN_IS_GROWING));
+		SetDParam(4, this->town->fund_buildings_months);
+		DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, STR_TOWN_VIEW_GROWTH);
+
+    //house states
+    SetDParam(0, town->houses_construction);
+    SetDParam(1, town->houses_reconstruction);
+    SetDParam(2, town->houses_demolished);
+    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, STR_TOWN_VIEW_HOUSE_STATE);
+
+    ///houses stats
+    SetDParam(0, town->houses_skipped);
+    SetDParam(1, town->houses_skipped_last_month);
+    SetDParam(2, town->cycles_skipped);
+    SetDParam(3, town->cycles_skipped_last_month);
+    SetDParam(4, town->cb_houses_removed);
+    SetDParam(5, town->cb_houses_removed_last_month);
+    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, STR_TOWN_VIEW_GROWTH_TILES);
+
 		bool first = true;
 		for (int i = TE_BEGIN; i < TE_END; i++) {
 			if (this->town->goal[i] == 0) continue;
@@ -478,6 +611,10 @@ public:
 				break;
 			}
 
+			case WID_TV_CB:
+				ShowCBTownWindow(this->window_number);
+				break;
+
 			case WID_TV_DELETE: // delete town - only available on Scenario editor
 				DoCommandP(0, this->window_number, 0, CMD_DELETE_TOWN | CMD_MSG(STR_ERROR_TOWN_CAN_T_DELETE));
 				break;
@@ -499,7 +636,7 @@ public:
 	 */
 	uint GetDesiredInfoHeight(int width) const
 	{
-		uint aimed_height = 3 * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+		uint aimed_height = 6 * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
 
 		bool first = true;
 		for (int i = TE_BEGIN; i < TE_END; i++) {
@@ -563,13 +700,29 @@ public:
 
 		DoCommandP(0, this->window_number, 0, CMD_RENAME_TOWN | CMD_MSG(STR_ERROR_CAN_T_RENAME_TOWN), nullptr, str);
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		//if(hotkey == WID_TV_CB) ShowCBTownWindow(this->window_number);
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
 };
 
+static Hotkey town_window_hotkeys[] = {
+	Hotkey((uint16)0, "location", WID_TV_CENTER_VIEW),
+	Hotkey((uint16)0, "local_authority", WID_TV_SHOW_AUTHORITY),
+	Hotkey((uint16)0, "cb_window", WID_TV_CB),
+	HOTKEY_LIST_END
+};
+HotkeyList TownViewWindow::hotkeys("town_window", town_window_hotkeys);
+
 static const NWidgetPart _nested_town_game_view_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
 		NWidget(WWT_PUSHIMGBTN, COLOUR_BROWN, WID_TV_CHANGE_NAME), SetMinimalSize(12, 14), SetDataTip(SPR_RENAME, STR_TOWN_VIEW_RENAME_TOOLTIP),
-		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_TOWN_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_TOWN_CAPTION_EXTRA, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
 		NWidget(WWT_PUSHIMGBTN, COLOUR_BROWN, WID_TV_CENTER_VIEW), SetMinimalSize(12, 14), SetDataTip(SPR_GOTO_LOCATION, STR_TOWN_VIEW_CENTER_TOOLTIP),
 		NWidget(WWT_SHADEBOX, COLOUR_BROWN),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_BROWN),
@@ -584,6 +737,7 @@ static const NWidgetPart _nested_town_game_view_widgets[] = {
 	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_SHOW_AUTHORITY), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_TOWN_VIEW_LOCAL_AUTHORITY_BUTTON, STR_TOWN_VIEW_LOCAL_AUTHORITY_TOOLTIP),
 		NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_TV_CATCHMENT), SetMinimalSize(40, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_CATCHMENT, STR_TOOLTIP_CATCHMENT),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_CB), SetMinimalSize(20, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_CB, 0),
 		NWidget(WWT_RESIZEBOX, COLOUR_BROWN),
 	EndContainer(),
 };
@@ -592,14 +746,15 @@ static WindowDesc _town_game_view_desc(
 	WDP_AUTO, "view_town", 260, TownViewWindow::WID_TV_HEIGHT_NORMAL,
 	WC_TOWN_VIEW, WC_NONE,
 	0,
-	_nested_town_game_view_widgets, lengthof(_nested_town_game_view_widgets)
+	_nested_town_game_view_widgets, lengthof(_nested_town_game_view_widgets),
+	&TownViewWindow::hotkeys
 );
 
 static const NWidgetPart _nested_town_editor_view_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
 		NWidget(WWT_PUSHIMGBTN, COLOUR_BROWN, WID_TV_CHANGE_NAME), SetMinimalSize(12, 14), SetDataTip(SPR_RENAME, STR_TOWN_VIEW_RENAME_TOOLTIP),
-		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_TOWN_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_TOWN_CAPTION_EXTRA, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
 		NWidget(WWT_PUSHIMGBTN, COLOUR_BROWN, WID_TV_CENTER_VIEW), SetMinimalSize(12, 14), SetDataTip(SPR_GOTO_LOCATION, STR_TOWN_VIEW_CENTER_TOOLTIP),
 		NWidget(WWT_SHADEBOX, COLOUR_BROWN),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_BROWN),
@@ -615,6 +770,7 @@ static const NWidgetPart _nested_town_editor_view_widgets[] = {
 		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_EXPAND), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_TOWN_VIEW_EXPAND_BUTTON, STR_TOWN_VIEW_EXPAND_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_DELETE), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_TOWN_VIEW_DELETE_BUTTON, STR_TOWN_VIEW_DELETE_TOOLTIP),
 		NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_TV_CATCHMENT), SetMinimalSize(40, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_CATCHMENT, STR_TOOLTIP_CATCHMENT),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_CB), SetMinimalSize(20, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_CB, 0),
 		NWidget(WWT_RESIZEBOX, COLOUR_BROWN),
 	EndContainer(),
 };
@@ -638,7 +794,7 @@ void ShowTownViewWindow(TownID town)
 static const NWidgetPart _nested_town_directory_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
-		NWidget(WWT_CAPTION, COLOUR_BROWN), SetDataTip(STR_TOWN_DIRECTORY_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_CAPTION, COLOUR_BROWN, TDW_CAPTION_TEXT), SetDataTip(STR_TOWN_DIRECTORY_CAPTION_EXTRA, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
 		NWidget(WWT_SHADEBOX, COLOUR_BROWN),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_BROWN),
 		NWidget(WWT_STICKYBOX, COLOUR_BROWN),
@@ -719,6 +875,15 @@ private:
 		return a_population < b_population;
 	}
 
+  /** Sort by number of houses (default descending, as big towns are of the most interest). */
+	static bool TownHousesSorter(const Town * const &a, const Town * const &b)
+	{
+		uint32 a_houses = a->cache.num_houses;
+		uint32 b_houses = b->cache.num_houses;
+		if (a_houses == b_houses) return TownDirectoryWindow::TownPopulationSorter(a, b);
+		return a_houses < b_houses;
+	}
+
 	/** Sort by town rating */
 	static bool TownRatingSorter(const Town * const &a, const Town * const &b)
 	{
@@ -769,6 +934,17 @@ public:
 			case WID_TD_SORT_CRITERIA:
 				SetDParam(0, TownDirectoryWindow::sorter_names[this->towns.SortType()]);
 				break;
+
+      case TDW_CAPTION_TEXT:
+				uint16 town_number = 0;
+        uint16 city_number = 0;
+		for (const Town *t : Town::Iterate()) {
+          if(t->larger_town) city_number++;
+          town_number++;
+        }
+        SetDParam(0, city_number);
+        SetDParam(1, town_number);
+				break;
 		}
 	}
 
@@ -820,7 +996,10 @@ public:
 
 					SetDParam(0, t->index);
 					SetDParam(1, t->cache.population);
-					DrawString(text_left, text_right, y + (this->resize.step_height - FONT_HEIGHT_NORMAL) / 2, GetTownString(t));
+					SetDParam(2, t->cache.num_houses);
+					/* CITIES DIFFERENT COLOUR*/
+					//DrawString(text_left, text_right, y + (this->resize.step_height - FONT_HEIGHT_NORMAL) / 2, STR_TOWN_DIRECTORY_TOWN_COLOUR, (t->larger_town ? TC_YELLOW : TC_ORANGE), SA_LEFT);
+					DrawString(text_left, text_right, y + (this->resize.step_height - FONT_HEIGHT_NORMAL) / 2, t->larger_town ? STR_TOWN_DIRECTORY_CITY_COLOUR : STR_TOWN_DIRECTORY_TOWN_COLOUR);
 
 					y += this->resize.step_height;
 					if (++n == this->vscroll->GetCapacity()) break; // max number of towns in 1 window
@@ -858,8 +1037,9 @@ public:
 					assert(t != nullptr);
 
 					SetDParam(0, t->index);
-					SetDParamMaxDigits(1, 8);
-					d = maxdim(d, GetStringBoundingBox(GetTownString(t)));
+					//SetDParamMaxDigits(1, 8); //CORAGEM
+					SetDParamMaxDigits(2, 5);
+					d = maxdim(d, GetStringBoundingBox(STR_TOWN_DIRECTORY_TOWN_COLOUR));
 				}
 				Dimension icon_size = GetSpriteSize(SPR_TOWN_RATING_GOOD);
 				d.width += icon_size.width + 2;
@@ -984,6 +1164,7 @@ Listing TownDirectoryWindow::last_sorting = {false, 0};
 const StringID TownDirectoryWindow::sorter_names[] = {
 	STR_SORT_BY_NAME,
 	STR_SORT_BY_POPULATION,
+	STR_SORT_BY_HOUSES,
 	STR_SORT_BY_RATING,
 	INVALID_STRING_ID
 };
@@ -992,6 +1173,7 @@ const StringID TownDirectoryWindow::sorter_names[] = {
 GUITownList::SortFunction * const TownDirectoryWindow::sorter_funcs[] = {
 	&TownNameSorter,
 	&TownPopulationSorter,
+	&TownHousesSorter,
 	&TownRatingSorter,
 };
 
@@ -1255,3 +1437,336 @@ void InitializeTownGui()
 {
 	_town_local_authority_kdtree.Clear();
 }
+
+//CB
+static void DrawExtraTownInfo (const Rect &r, uint &y, Town *town, uint line, bool show_house_states_info) {
+	//real pop and rating
+	SetDParam(0, town->cache.potential_pop);
+	SetDParam(1, town->ratings[_current_company]);
+	DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += line, STR_TOWN_VIEW_REALPOP_RATE);
+	//town stats
+	int grow_rate = 0;
+	if(town->growth_rate == TOWN_GROWTH_RATE_NONE) grow_rate = 0;
+	else grow_rate = TownTicksToDays((town->growth_rate & ~TOWN_CUSTOM_GROWTH) + 1);
+
+	SetDParam(0, grow_rate);
+	SetDParam(1, !(town->growth_rate & TOWN_CUSTOM_GROWTH) ? TownTicksToDays(town->grow_counter + 1) : ((town->grow_counter & (~TOWN_CUSTOM_GROWTH)) * TOWN_GROWTH_TICKS + DAY_TICKS) / DAY_TICKS);
+	SetDParam(2, town->time_until_rebuild);
+	SetDParam(3, HasBit(town->flags, TOWN_IS_GROWING) ? 1 : 0);
+	SetDParam(4, town->fund_buildings_months);
+	DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += line, STR_TOWN_VIEW_GROWTH);
+
+	if (show_house_states_info) {
+		SetDParam(0, town->houses_construction);
+		SetDParam(1, town->houses_reconstruction);
+		SetDParam(2, town->houses_demolished);
+		DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += line, STR_TOWN_VIEW_HOUSE_STATE);
+	}
+
+	///houses stats
+	SetDParam(0, town->houses_skipped);
+	SetDParam(1, town->houses_skipped_last_month);
+	SetDParam(2, town->cycles_skipped);
+	SetDParam(3, town->cycles_skipped_last_month);
+	SetDParam(4, town->cb_houses_removed);
+	SetDParam(5, town->cb_houses_removed_last_month);
+	DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += line, STR_TOWN_VIEW_GROWTH_TILES);
+}
+
+bool CB_sortCargoesByFrom(CargoX first, CargoX second){
+	return (first.from < second.from) ? true : false;
+}
+
+struct CBTownWindow : Window {
+private:
+	Town *town;
+	std::list<CargoX> cargoes;
+
+public:
+	CBTownWindow(WindowDesc *desc, WindowNumber window_number) : Window(desc)
+	{
+		for (uint i = 0; i < NUM_CARGO ; i++) {
+			CargoX c;
+			c.id = i;
+			c.from = CB_GetFrom(i);
+			this->cargoes.push_back(c);
+		}
+		cargoes.sort(CB_sortCargoesByFrom);
+		this->town = Town::Get(window_number);
+		this->InitNested(window_number);
+
+		if(HasBit(this->town->fund_regularly, _local_company)) this->LowerWidget(WID_CB_FUND_REGULAR);
+		if(HasBit(this->town->do_powerfund, _local_company)) this->LowerWidget(WID_CB_POWERFUND);
+		if(HasBit(this->town->advertise_regularly, _local_company)) this->LowerWidget(WID_CB_ADVERT_REGULAR);
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_CB_LOCATION:
+			case WID_CB_CENTER_VIEW: // scroll to location
+				if (_ctrl_pressed) {
+					ShowExtraViewportWindow(this->town->xy);
+				}
+				else {
+					ScrollMainWindowToTile(this->town->xy);
+				}
+				break;
+			case WID_CB_ADVERT:
+				TownExecuteAction(this->town, HK_LADVERT);
+				break;
+			case WID_CB_FUND:
+				TownExecuteAction(this->town, HK_FUND);
+				break;
+			case WID_CB_FUND_REGULAR:
+				ToggleBit(this->town->fund_regularly, _local_company);
+				this->SetWidgetLoweredState(widget, HasBit(this->town->fund_regularly, _local_company));
+				this->SetWidgetDirty(widget);
+                this->town->pending_funding = true;
+				break;
+			case WID_CB_POWERFUND:
+				ToggleBit(this->town->do_powerfund, _local_company);
+				this->SetWidgetLoweredState(widget, HasBit(this->town->do_powerfund, _local_company));
+				this->SetWidgetDirty(widget);
+				break;
+			case WID_CB_ADVERT_REGULAR:
+				if (!this->town->advertise_regularly) {
+                    this->town->last_adv_at = (uint16)(_tick_counter - Town::adv_cooldown);
+                    this->town->cached_goods_ref = nullptr;
+					SetDParam(0, ToPercent8(this->town->ad_rating_goal));
+					ShowQueryString(STR_JUST_INT, STR_CB_ADVERT_REGULAR_RATING_TO_KEEP,
+					                4, this, CS_NUMERAL, QSF_ACCEPT_UNCHANGED);
+				} else this->OnQueryTextFinished(NULL);
+				break;
+			case WID_CB_TOWN_VIEW: // Town view window
+				ShowTownViewWindow(this->window_number);
+				break;
+			case WID_CB_SHOW_AUTHORITY: // town authority
+				ShowTownAuthorityWindow(this->window_number);
+				break;
+		}
+	}
+
+	virtual void OnQueryTextFinished(char *str)
+	{
+		if (str != NULL) SetBit(this->town->advertise_regularly, _local_company);
+		else ClrBit(this->town->advertise_regularly, _local_company);
+		this->town->cached_goods_ref = nullptr;
+		this->SetWidgetLoweredState(WID_CB_ADVERT_REGULAR, HasBit(this->town->advertise_regularly, _local_company));
+		this->SetWidgetDirty(WID_CB_ADVERT_REGULAR);
+
+		if (str == NULL)
+			return;
+		uint val = Clamp(StrEmpty(str) ? 0 : strtol(str, NULL, 10), 1, 100);
+		this->town->ad_rating_goal = ((val << 8) + 255) / 101;
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if (widget == WID_TV_CAPTION){
+			SetDParam(0, this->town->index);
+		}
+	}
+
+	void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		static const uint EXP_TOPPADDING = 5;
+		static const uint EXP_LINESPACE  = 2; // Amount of vertical space for a horizontal (sub-)total line.
+
+		switch(widget){
+			case WID_CB_DETAILS:
+				size->height = (FONT_HEIGHT_NORMAL + EXP_LINESPACE) * 7;
+				break;
+			case WID_CB_CARGO_NAME:
+			case WID_CB_CARGO_AMOUNT:
+			case WID_CB_CARGO_REQ:
+			case WID_CB_CARGO_STORE:
+			case WID_CB_CARGO_STORE_PCT:
+			case WID_CB_CARGO_FROM:
+			case WID_CB_CARGO_PREVIOUS:
+				uint desired_height = 1;
+				for(CargoID cargo = 0; cargo < NUM_CARGO; cargo++){
+					if(CB_GetReq(cargo) > 0) desired_height++;
+				}
+				size->height = desired_height * (FONT_HEIGHT_NORMAL + EXP_LINESPACE) + EXP_TOPPADDING - EXP_LINESPACE;
+				break;
+		}
+	}
+	void OnPaint() override
+	{
+		this->SetWidgetLoweredState(WID_CB_ADVERT_REGULAR, HasBit(this->town->advertise_regularly, _local_company));
+		this->SetWidgetLoweredState(WID_CB_FUND_REGULAR, HasBit(this->town->fund_regularly, _local_company));
+		this->SetWidgetLoweredState(WID_CB_POWERFUND, HasBit(this->town->do_powerfund, _local_company));
+
+		this->DrawWidgets();
+	}
+
+	void DrawWidget(const Rect &r, int widget) const
+	{
+		static const uint EXP_LINESPACE  = FONT_HEIGHT_NORMAL + 2;
+		uint y = r.top + WD_FRAMERECT_TOP;
+		switch(widget){
+			case WID_CB_DETAILS:{
+				//growing
+				if(HasBit(town->flags, TOWN_IS_GROWING)) DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, STR_TOWN_CB_GROWING );
+				else DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, STR_TOWN_CB_NOT_GROWING );
+				//population
+				SetDParam(0, this->town->cache.population);
+				SetDParam(1, this->town->cache.num_houses);
+				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += EXP_LINESPACE, STR_TOWN_VIEW_POPULATION_HOUSES);
+
+				DrawExtraTownInfo(r, y, this->town, EXP_LINESPACE, false);
+				//regular funding
+				if(this->town->fund_regularly != 0){
+					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += EXP_LINESPACE, STR_CB_FUNDED_REGULARLY);
+				}
+				break;
+			}
+			/* Citybuilder things*/
+			case WID_CB_CARGO_NAME:
+			case WID_CB_CARGO_AMOUNT:
+			case WID_CB_CARGO_REQ:
+			case WID_CB_CARGO_STORE:
+			case WID_CB_CARGO_STORE_PCT:
+			case WID_CB_CARGO_FROM:
+			case WID_CB_CARGO_PREVIOUS: {
+				if (!CB_Enabled() || this->town->larger_town) break;
+
+				uint delivered;
+				uint requirements;
+				uint from;
+				StringID string_to_draw;
+
+				//for cycle
+				std::list<CargoX> cargoes2 = this->cargoes;
+				std::list<CargoX>::iterator it2;
+				for (it2 = cargoes2.begin(); it2 != cargoes2.end(); ++it2) {
+					CargoX cargox;
+					cargox = *it2;
+					if (it2 == cargoes2.begin()) { //header
+						DrawString(r.left + WD_FRAMERECT_LEFT + 14, r.right - WD_FRAMERECT_LEFT, y,
+							(STR_TOWN_GROWTH_HEADER_CARGO + widget - WID_CB_CARGO_NAME), TC_FROMSTRING,
+							(widget == WID_CB_CARGO_NAME) ? SA_LEFT : SA_RIGHT);
+
+						y += (FONT_HEIGHT_NORMAL + 2);
+					}
+
+					const CargoSpec *cargos = CargoSpec::Get(cargox.id);
+					//cargo needed?
+					if (!cargos->IsValid() || CB_GetReq(cargos->Index()) == 0) continue;
+
+					from = CB_GetFrom(cargos->Index());
+
+					switch(widget) {
+						case WID_CB_CARGO_NAME: {
+							int rect_x = (r.left + WD_FRAMERECT_LEFT);
+							GfxFillRect(rect_x, y + 1, rect_x + 8, y + 6, 0);
+							GfxFillRect(rect_x + 1, y + 2, rect_x + 7, y + 5, cargos->legend_colour);
+
+							SetDParam(0, cargos->name);
+							DrawString(r.left + WD_FRAMERECT_LEFT + 14, r.right - WD_FRAMERECT_LEFT, y, STR_TOWN_CB_CARGO_NAME);
+							break;
+						}
+						case WID_CB_CARGO_AMOUNT: {
+							delivered = this->town->new_act_cargo[cargos->Index()];
+							requirements = CB_GetTownReq(this->town->cache.population, CB_GetReq(cargos->Index()), from, true);
+							SetDParam(0, delivered);
+
+							//when required
+							if (this->town->cache.population >= from) {
+								if((delivered + (uint)this->town->storage[cargos->Index()]) >= requirements) string_to_draw = STR_TOWN_CB_CARGO_AMOUNT_GOOD;
+								else string_to_draw = STR_TOWN_CB_CARGO_AMOUNT_BAD;
+						}
+							//when not required -> all faded
+							else string_to_draw = STR_TOWN_CB_CARGO_AMOUNT_NOT;
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_REQ: {
+							requirements = CB_GetTownReq(this->town->cache.population, CB_GetReq(cargos->Index()), from, true);
+							SetDParam(0, requirements);
+							 //when required
+							string_to_draw = (this->town->cache.population >= from) ? STR_TOWN_CB_CARGO_REQ_YES : STR_TOWN_CB_CARGO_REQ_NOT;
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_PREVIOUS: {
+							requirements = CB_GetTownReq(this->town->cache.population, CB_GetReq(cargos->Index()), from, true);
+							SetDParam(0, this->town->act_cargo[cargos->Index()]);
+							if (this->town->cache.population >= from){
+								if (this->town->delivered_enough[cargos->Index()]) {
+									string_to_draw = (this->town->act_cargo[cargos->Index()] >= requirements) ? STR_TOWN_CB_CARGO_PREVIOUS_YES : STR_TOWN_CB_CARGO_PREVIOUS_EDGE;
+								}
+								else string_to_draw = STR_TOWN_CB_CARGO_PREVIOUS_BAD;
+							}
+							else string_to_draw = STR_TOWN_CB_CARGO_PREVIOUS_NOT;
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_STORE: {
+							SetDParam(0, this->town->storage[cargos->Index()]);
+							if (CB_GetDecay(cargos->Index()) == 100) string_to_draw = STR_TOWN_CB_CARGO_STORE_DECAY;  //when 100% decay
+							else {
+								if (this->town->cache.population >= from) string_to_draw = STR_TOWN_CB_CARGO_STORE_YES;  //when required
+								else string_to_draw = STR_TOWN_CB_CARGO_STORE_NOT;
+							}
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_STORE_PCT: {
+							uint max_storage = CB_GetMaxTownStorage(this->town, cargos->Index());
+							if (CB_GetDecay(cargos->Index()) == 100 || !max_storage) string_to_draw = STR_TOWN_CB_CARGO_STORE_DECAY;  //when 100% decay
+							else {
+								SetDParam(0, 100 * this->town->storage[cargos->Index()] / max_storage);
+								if (this->town->cache.population >= from) string_to_draw = STR_TOWN_CB_CARGO_STORE_PCT_YES;  //when required
+								else string_to_draw = STR_TOWN_CB_CARGO_STORE_PCT_NOT;
+							}
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_FROM: {
+							SetDParam(0, from);
+							string_to_draw = (this->town->cache.population >= from) ? STR_TOWN_CB_CARGO_FROM_YES : STR_TOWN_CB_CARGO_FROM_NOT; //when required
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						//last case
+					}
+					//switch
+					y += (FONT_HEIGHT_NORMAL + 2);
+					//cargo needed?
+				}
+				//for cycle
+			}
+			break;
+		}
+		/* Citybuilder things enabled*/
+	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		TownExecuteAction(this->town, hotkey);
+		return ES_HANDLED;
+	}
+
+	static HotkeyList hotkeys;
+};
+
+HotkeyList CBTownWindow::hotkeys("town_gui", town_hotkeys);
+
+static WindowDesc _cb_town_desc(
+	WDP_AUTO, "cb_town", 320, 80,
+	WC_CB_TOWN, WC_NONE,
+	0,
+	_nested_cb_town_widgets, lengthof(_nested_cb_town_widgets),
+	&CBTownWindow::hotkeys
+);
+
+void ShowCBTownWindow(uint town) {
+	AllocateWindowDescFront<CBTownWindow>(&_cb_town_desc, town);
+}
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index f5eb32d7f..b89fafbde 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -3205,6 +3205,9 @@ bool TrainController(Train *v, Vehicle *nomove, bool reverse)
 
 						/* Don't handle stuck trains here. */
 						if (HasBit(v->flags, VRF_TRAIN_STUCK)) return false;
+						/* this codepath seems to be run every 5 ticks, so increase counter twice every 20 ticks */
+						IncreaseStuckCounter(v->tile);
+						if (v->tick_counter % 4 == 0) IncreaseStuckCounter(v->tile);
 
 						if (!HasSignalOnTrackdir(gp.new_tile, ReverseTrackdir(i))) {
 							v->cur_speed = 0;
@@ -3357,7 +3360,7 @@ bool TrainController(Train *v, Vehicle *nomove, bool reverse)
 				v->x_pos = gp.x;
 				v->y_pos = gp.y;
 				v->UpdatePosition();
-				if ((v->vehstatus & VS_HIDDEN) == 0) v->Vehicle::UpdateViewport(true);
+				if (v->IsDrawn()) v->Vehicle::UpdateViewport(true);
 				continue;
 			}
 		}
@@ -3812,6 +3815,7 @@ static bool TrainLocoHandler(Train *v, bool mode)
 	/* Handle stuck trains. */
 	if (!mode && HasBit(v->flags, VRF_TRAIN_STUCK)) {
 		++v->wait_counter;
+		if (v->tick_counter % 4 == 0) IncreaseStuckCounter(v->tile);
 
 		/* Should we try reversing this tick if still stuck? */
 		bool turn_around = v->wait_counter % (_settings_game.pf.wait_for_pbs_path * DAY_TICKS) == 0 && _settings_game.pf.reverse_at_signals;
@@ -3883,7 +3887,7 @@ static bool TrainLocoHandler(Train *v, bool mode)
 	}
 
 	for (Train *u = v; u != nullptr; u = u->Next()) {
-		if ((u->vehstatus & VS_HIDDEN) != 0) continue;
+		if (!u->IsDrawn()) continue;
 
 		u->UpdateViewport(false, false);
 	}
diff --git a/src/transparency.h b/src/transparency.h
index 54ba24e93..08b13ca9b 100644
--- a/src/transparency.h
+++ b/src/transparency.h
@@ -29,6 +29,7 @@ enum TransparencyOption {
 	TO_STRUCTURES, ///< other objects such as transmitters and lighthouses
 	TO_CATENARY,   ///< catenary
 	TO_LOADING,    ///< loading indicators
+	TO_TUNNELS,    ///< vehicles in tunnels
 	TO_END,
 	TO_INVALID,    ///< Invalid transparency option
 };
diff --git a/src/transparency_gui.cpp b/src/transparency_gui.cpp
index 153dcb5d0..4d319e57d 100644
--- a/src/transparency_gui.cpp
+++ b/src/transparency_gui.cpp
@@ -50,6 +50,7 @@ public:
 			case WID_TT_BRIDGES:
 			case WID_TT_STRUCTURES:
 			case WID_TT_CATENARY:
+			case WID_TT_TUNNELS:
 			case WID_TT_LOADING: {
 				uint i = widget - WID_TT_BEGIN;
 				if (HasBit(_transparency_lock, i)) DrawSprite(SPR_LOCK, PAL_NONE, r.left + 1, r.top + 1);
@@ -57,7 +58,7 @@ public:
 			}
 			case WID_TT_BUTTONS:
 				for (uint i = WID_TT_BEGIN; i < WID_TT_END; i++) {
-					if (i == WID_TT_LOADING) continue; // Do not draw button for invisible loading indicators.
+					if (i >= WID_TT_LOADING) continue; // Do not draw button for invisible loading indicators.
 
 					const NWidgetBase *wi = this->GetWidget<NWidgetBase>(i);
 					DrawFrameRect(wi->pos_x + 1, r.top + 2, wi->pos_x + wi->current_x - 2, r.bottom - 2, COLOUR_PALE_GREEN,
@@ -139,6 +140,7 @@ static const NWidgetPart _nested_transparency_widgets[] = {
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_STRUCTURES), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_TRANSMITTER, STR_TRANSPARENT_STRUCTURES_TOOLTIP),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_CATENARY), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_BUILD_X_ELRAIL, STR_TRANSPARENT_CATENARY_TOOLTIP),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_LOADING), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_TRAINLIST, STR_TRANSPARENT_LOADING_TOOLTIP),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_TUNNELS), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_ROAD_TUNNEL, STR_TRANSPARENT_TUNNELS_TOOLTIP),
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN), SetFill(1, 1), EndContainer(),
 	EndContainer(),
 	/* Panel with 'invisibility' buttons. */
@@ -156,6 +158,7 @@ static WindowDesc _transparency_desc(
 /**
  * Show the transparency toolbar.
  */
+
 void ShowTransparencyToolbar()
 {
 	AllocateWindowDescFront<TransparenciesWindow>(&_transparency_desc, 0);
diff --git a/src/triphistory.h b/src/triphistory.h
new file mode 100644
index 000000000..9ab9b3b3d
--- /dev/null
+++ b/src/triphistory.h
@@ -0,0 +1,75 @@
+/** @file triphistory.h */
+
+#ifndef TRIPHISTORY_H
+#define TRIPHISTORY_H
+
+#include <deque>
+#include "window_gui.h"
+#include "strings_type.h"
+#include "economy_type.h"
+#include "date_type.h"
+
+// entries to save
+#define TRIP_LENGTH 10
+
+static inline int TripHistoryRound( float x )
+{
+	return int( x > 0.0 ? x + 0.5 : x - 0.5 );
+}
+
+struct TripHistoryEntry {
+	Money profit; // Saved
+	Date date; // Saved
+	int32 profit_change; // Calculated
+	Date TBT; // Calculated
+	int32 TBT_change; // Calculated
+
+	TripHistoryEntry( ) : profit( 0 ), date( 0 ), profit_change( 0 ), TBT( 0 ), TBT_change( 0 ) { };
+};
+
+/** Structure to hold data for each vehicle */
+struct TripHistory {
+	// a lot of saveload stuff for std::deque. So...
+	TripHistoryEntry t[ TRIP_LENGTH ];
+
+	Money total_profit;
+	int32 avg_daylength;
+	int32 total_change;
+	Money profit_per_day;
+
+	TripHistory( ) :
+		total_profit( 0 ),
+		avg_daylength( 0 ),
+		total_change( 0 ),
+		profit_per_day( 0 ) { }
+
+	void NewRound();
+
+	void AddValue( Money mvalue, Date dvalue );
+
+
+	/**
+	 * Init info for GUI
+	 *
+	 * @return size_t number of valid rows
+	 */
+	size_t UpdateCalculated( );
+
+	int32 FindPercentChange( Money v1, Money v2 ) {
+		float temp;
+
+		if ( v1 > v2 ) {
+			temp = v1 - v2;
+			return TripHistoryRound( ( float ) temp * 100 / ( float ) v1 );
+		}
+
+		if ( v2 > v1 ) {
+			temp = v1 - v2;
+			return TripHistoryRound( ( float ) temp * 100 / ( float ) v2 );
+		}
+
+		return 0;
+	}
+};
+
+#endif /* TRIPHISTORY_H */
diff --git a/src/triphistory_cmd.cpp b/src/triphistory_cmd.cpp
new file mode 100644
index 000000000..f900d4d9e
--- /dev/null
+++ b/src/triphistory_cmd.cpp
@@ -0,0 +1,100 @@
+/** @file triphistory_cmd.cpp */
+
+#include "stdafx.h"
+#include "triphistory.h"
+#include "table/strings.h"
+
+void
+TripHistory::AddValue( Money mvalue, Date dvalue ) {
+	if ( 0 < dvalue ) {
+		t[ 0 ].profit += mvalue;
+		t[ 0 ].date = dvalue;
+	}
+}
+
+void
+TripHistory::NewRound( ) {
+	//move down
+	for ( int i = TRIP_LENGTH - 1; i > 0; i-- ) {
+		this->t[ i ] = this->t[ i - 1 ];
+		//this->trip_history_date_array[ i ] = this->trip_history_date_array[ i - 1 ];
+	}
+
+	this->t[ 0 ].profit = 0;
+	this->t[ 0 ].date = this->t[ 1 ].date;
+
+	//t.push_front( TripHistoryEntry( ) );
+}
+
+size_t
+TripHistory::UpdateCalculated( ) {
+
+	this->total_profit = 0;
+	this->total_change = 0;
+	this->avg_daylength = 0;
+	this->profit_per_day = 0;
+	uint i = 0;
+
+	//
+	while ( i < TRIP_LENGTH && t [ i ].date ) {
+
+		if ( i > 0 ) {
+			t[ i - 1 ].profit_change =
+				FindPercentChange( t [ i - 1 ].profit, t[ i ].profit );
+			t[ i - 1 ].TBT = t[ i - 1 ].date - t[ i ].date;
+
+			if ( i > 1 ) t[ i - 2 ].TBT_change = t[ i - 2 ].TBT - t[ i - 1 ].TBT;//bad line i don't like it
+
+			//omit first -100% row
+			if ( i > 1 || t [ 0 ].profit_change != -100 )
+				this->total_change += t[ i - 1 ].profit_change;
+			this->avg_daylength += t[ i - 1 ].TBT;
+		}
+
+		// prepare summary
+
+
+		this->total_profit += t[ i ].profit;
+		i++;
+	}
+
+	if ( i == 0 ) return 0 ;
+
+	this->avg_daylength /= --i + 1;
+
+	if ( t[ 0 ].date != t[ i ].date ) {
+		this->profit_per_day = total_profit / ( t[ 0 ].date - t[ i ].date );
+	}
+
+	return i;
+	/*
+	Trips::reverse_iterator i = t.rbegin( );
+	while ( i < t.rend( ) ) {
+
+		if ( i + 1 != t.rend( ) ) {
+			(*( i + 1 )).profit_change =
+				FindPercentChange( ( *i ).profit, ( *( i + 1 ) ).profit ); // reverse_itenrator
+
+			( *( i + 1 ) ).TBT = ( *i ).date - ( *( i + 1 ) ).date;
+
+			if ( ( *i ).TBT ) ( *( i + 1 ) ).TBT_change = ( *i ).TBT - ( *( i + 1 ) ).TBT;
+
+			//omit first -100% row
+			this->total_change += ( *i ).profit_change;
+		}
+
+		// prepare summary
+		this->total_profit += ( *i ).profit;
+		this->avg_daylength += ( *i ).TBT;
+
+		i++;
+	}
+
+	this->avg_daylength /= t.size( );
+
+	if ( t.front( ).date != t.back( ).date ) {
+		this->profit_per_day = total_profit / ( t.front( ).date - t.back( ).date );
+	}
+
+	return t.size( );*/
+}
diff --git a/src/triphistory_gui.cpp b/src/triphistory_gui.cpp
new file mode 100644
index 000000000..90a1b362d
--- /dev/null
+++ b/src/triphistory_gui.cpp
@@ -0,0 +1,214 @@
+/** @file triphistory_gui.cpp */
+
+#include "stdafx.h"
+#include "triphistory.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "gfx_func.h"
+#include "date_func.h"
+#include "vehicle_base.h"
+#include "table/strings.h"
+
+#include "safeguards.h"
+
+/* Names of the widgets. Keep them in the same order as in the widget array */
+enum VehicleTripWidgets {
+	VTH_CAPTION,
+	VTH_LABEL_RECEIVED,
+	VTH_LABEL_PROFIT,
+	VTH_LABEL_PERCHANGE,
+	VTH_LABEL_TBT,
+	VTH_LABEL_DAYCHANGE,
+	VTH_MATRIX_RECEIVED,
+	VTH_MATRIX_PROFIT,
+	VTH_MATRIX_PERCHANGE,
+	VTH_MATRIX_TBT,
+	VTH_MATRIX_DAYCHANGE,
+	VTH_SUMMARY,
+
+};
+static const NWidgetPart _vehicle_trip_history_widgets[] = {
+		NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, VTH_CAPTION), SetDataTip(STR_TRIP_HISTORY_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_RECEIVED), SetMinimalSize(110, 0), SetMinimalTextLines(1, 2), SetResize(1, 0), SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_RECEIVED_LABEL, STR_TRIP_HISTORY_RECEIVED_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_PROFIT), SetMinimalSize(110, 0), SetMinimalTextLines(1, 2), SetResize(1, 0), SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_PROFIT_LABEL,       STR_TRIP_HISTORY_PROFIT_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_PERCHANGE), SetMinimalSize(50, 0), SetMinimalTextLines(1, 2), SetResize(1, 0),SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_DAYCHANGE_LABEL,    STR_TRIP_HISTORY_PERCHANGE_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_TBT), SetMinimalSize(70, 0), SetMinimalTextLines(1, 2), SetResize(1, 0),SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_TBT_LABEL,          STR_TRIP_HISTORY_TBT_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_DAYCHANGE), SetMinimalSize(50, 0), SetMinimalTextLines(1, 2), SetResize(1, 0),SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_DAYCHANGE_LABEL,    STR_TRIP_HISTORY_DAYCHANGE_LABEL_TIP),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_RECEIVED), SetMinimalSize(110, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_PROFIT), SetMinimalSize(110, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_PERCHANGE), SetMinimalSize(50, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_TBT), SetMinimalSize(70, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_DAYCHANGE), SetMinimalSize(50, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY, VTH_SUMMARY), SetMinimalTextLines(3, 2), SetResize(1, 0), SetFill(1, 0), EndContainer(),
+};
+
+struct VehicleTripHistoryWindow : Window {
+
+private:
+	uint8 valid_rows; // number of rows in trip history
+public:
+	VehicleTripHistoryWindow(WindowDesc *desc, WindowNumber window_number) :
+		Window(desc), valid_rows( 0 )
+	{
+		const Vehicle *v = Vehicle::Get(window_number);
+		this->CreateNestedTree();
+
+		this->FinishInitNested(window_number);
+		this->owner = v->owner;
+		InvalidateData();
+	}
+/*
+	~VehicleTripHistoryWindow() {
+		if (Vehicle::IsValidID(this->window_number)) {
+			Vehicle *v = Vehicle::Get(this->window_number);
+			free(v->trip_history_pchange_array);
+			free(v->trip_history_TBT_array);
+			free(v->trip_history_TBT_change_array);
+			v->trip_history_avg_daylength = 0;
+			v->trip_history_profitpd = 0;
+			v->trip_history_total_change = 0;
+			v->trip_history_total_profit = 0;
+		}
+	}*/
+
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true) {
+		Vehicle *v = Vehicle::Get(this->window_number);
+		valid_rows = v->trip_history.UpdateCalculated();
+		this->SetDirty();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case VTH_CAPTION: SetDParam(0, this->window_number); break;
+		}
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case VTH_SUMMARY: {
+				SetDParam(0, UINT64_MAX >> 2);
+				SetDParam(1, 100);
+				Dimension text_dim = GetStringBoundingBox(STR_TRIP_HISTORY_TOTALINCOME);
+				size->width = text_dim.width + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+				break;
+			}
+
+			case VTH_LABEL_RECEIVED:
+			case VTH_MATRIX_RECEIVED: {
+				SetDParam(0, _date);
+				Dimension text_dim = GetStringBoundingBox(STR_TRIP_HISTORY_DATE);
+				size->width = text_dim.width + WD_MATRIX_LEFT + WD_MATRIX_RIGHT;
+				break;
+			}
+			case VTH_MATRIX_PROFIT:
+			case VTH_MATRIX_PERCHANGE:
+			case VTH_MATRIX_TBT:
+			case VTH_MATRIX_DAYCHANGE:
+				resize->height = FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM;
+				size->height = 10 * resize->height;
+				break;
+		}
+	}
+	virtual void DrawWidget(const Rect &r, int widget) const {
+		const Vehicle *v = Vehicle::Get(this->window_number);
+		int y = WD_FRAMERECT_TOP;
+
+		switch( widget ) {
+		    case VTH_MATRIX_RECEIVED:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].date);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_DATE, TC_BLACK, SA_RIGHT);
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_PROFIT:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i].date > 0) {
+					    if ( v->trip_history.t[i].profit > 0 ) {
+						    SetDParam(0, v->trip_history.t[i].profit );
+						    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_PROFIT, TC_BLACK, SA_RIGHT);
+					    } else {
+						    SetDParam(0, -v->trip_history.t[i].profit);
+						    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_VIRTUAL_PROFIT, TC_BLACK, SA_RIGHT);
+					    }
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_PERCHANGE:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i+1].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].profit_change);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y,
+						    v->trip_history.t[i].profit_change >= 0 ?
+							    STR_TRIP_HISTORY_PROFITCHANGEPOS :
+							    STR_TRIP_HISTORY_PROFITCHANGENEG, TC_BLACK, SA_RIGHT
+					    );
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_TBT:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].TBT);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_TBT, TC_BLACK, SA_RIGHT);
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_DAYCHANGE:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i+1].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].TBT_change);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y,
+						    v->trip_history.t[i].TBT_change > 0 ?
+							    STR_TRIP_HISTORY_TBTCHANGEPOS :
+							    STR_TRIP_HISTORY_TBTCHANGENEG, TC_BLACK, SA_RIGHT
+					    );
+				    }
+			    }
+			    break;
+		    case VTH_SUMMARY:
+			    SetDParam(0, valid_rows + 1);
+			    SetDParam(1, v->trip_history.total_profit);
+			    SetDParam(2, v->trip_history.profit_per_day);
+			    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_TRIP_HISTORY_TOTALINCOME, TC_BLACK);
+			    SetDParam(0, v->trip_history.avg_daylength);
+			    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP, STR_TRIP_HISTORY_DAYAVERAGE, TC_BLACK);
+			    SetDParam(0, valid_rows + 1);
+			    SetDParam(1, v->trip_history.total_change);
+			    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + 2*FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP, STR_TRIP_HISTORY_DAYAVERAGE_IMPROVEMENT, TC_BLACK);
+			    break;
+		}
+	}
+};
+
+static WindowDesc _vehicle_trip_history(
+	WDP_AUTO, "trip_history", 380, 191,
+	WC_VEHICLE_TRIP_HISTORY,WC_VEHICLE_DETAILS,
+	0,
+	_vehicle_trip_history_widgets,
+	lengthof(_vehicle_trip_history_widgets)
+);
+
+void ShowTripHistoryWindow(const Vehicle *v)
+{
+	if (!BringWindowToFrontById(WC_VEHICLE_TRIP_HISTORY, v->index)) {
+		AllocateWindowDescFront<VehicleTripHistoryWindow>(&_vehicle_trip_history, v->index);
+	}
+}
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index 30e1c477c..409abb0e4 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -285,6 +285,14 @@ uint Vehicle::Crash(bool flooded)
 	return RandomRange(pass + 1); // Randomise deceased passengers.
 }
 
+bool Vehicle::IsDrawn() const
+{
+	return !(this->vehstatus & VS_HIDDEN) ||
+			(IsTransparencySet(TO_TUNNELS) &&
+				((this->type == VEH_TRAIN && Train::From(this)->track == TRACK_BIT_WORMHOLE) ||
+				(this->type == VEH_ROAD && RoadVehicle::From(this)->state == RVSB_WORMHOLE)));
+}
+
 
 /**
  * Displays a "NewGrf Bug" error message for a engine, and pauses the game if not networking.
@@ -862,6 +870,8 @@ void Vehicle::PreDestructor()
 		CloseWindowById(WC_VEHICLE_REFIT, this->index);
 		CloseWindowById(WC_VEHICLE_DETAILS, this->index);
 		CloseWindowById(WC_VEHICLE_TIMETABLE, this->index);
+		CloseWindowById(WC_VEHICLE_TRIP_HISTORY, this->index);
+		SetWindowDirty(WC_VEHICLE_TRIP_HISTORY, this->index);
 		SetWindowDirty(WC_COMPANY, this->owner);
 		OrderBackup::ClearVehicle(this);
 	}
@@ -886,7 +896,7 @@ Vehicle::~Vehicle()
 
 	/* sometimes, eg. for disaster vehicles, when company bankrupts, when removing crashed/flooded vehicles,
 	 * it may happen that vehicle chain is deleted when visible */
-	if (!(this->vehstatus & VS_HIDDEN)) this->MarkAllViewportsDirty();
+	if (this->IsDrawn()) this->MarkAllViewportsDirty();
 
 	Vehicle *v = this->Next();
 	this->SetNext(nullptr);
@@ -1096,7 +1106,7 @@ static void DoDrawVehicle(const Vehicle *v)
 	if (v->vehstatus & VS_DEFPAL) pal = (v->vehstatus & VS_CRASHED) ? PALETTE_CRASH : GetVehiclePalette(v);
 
 	/* Check whether the vehicle shall be transparent due to the game state */
-	bool shadowed = (v->vehstatus & VS_SHADOW) != 0;
+	bool shadowed = (v->vehstatus & (VS_SHADOW | VS_HIDDEN));
 
 	if (v->type == VEH_EFFECT) {
 		/* Check whether the vehicle shall be transparent/invisible due to GUI settings.
@@ -1158,7 +1168,7 @@ void ViewportAddVehicles(DrawPixelInfo *dpi)
 
 			while (v != nullptr) {
 
-				if (!(v->vehstatus & VS_HIDDEN) &&
+				if (v->IsDrawn() &&
 					l <= v->coord.right + xb &&
 					t <= v->coord.bottom + yb &&
 					r >= v->coord.left - xb &&
@@ -1224,7 +1234,7 @@ Vehicle *CheckClickOnVehicle(const Viewport *vp, int x, int y)
 	y = ScaleByZoom(y, vp->zoom) + vp->virtual_top;
 
 	for (Vehicle *v : Vehicle::Iterate()) {
-		if ((v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) == 0 &&
+		if (v->IsDrawn() && !(v->vehstatus & VS_UNCLICKABLE) &&
 				x >= v->coord.left && x <= v->coord.right &&
 				y >= v->coord.top && y <= v->coord.bottom) {
 
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index 12acaa8ed..2cd446cf3 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -14,6 +14,7 @@
 #include "track_type.h"
 #include "command_type.h"
 #include "order_base.h"
+#include "triphistory.h"
 #include "cargopacket.h"
 #include "texteff.hpp"
 #include "engine_type.h"
@@ -252,6 +253,8 @@ public:
 	Money profit_last_year;             ///< Profit last year << 8, low 8 bits are fract
 	Money value;                        ///< Value of the vehicle
 
+	TripHistory trip_history;           ///< Trip History Info
+
 	CargoPayment *cargo_payment;        ///< The cargo payment we're currently in
 
 	mutable Rect coord;                 ///< NOSAVE: Graphical bounding box of the vehicle, i.e. what to redraw on moves.
@@ -366,6 +369,12 @@ public:
 
 	uint GetConsistTotalCapacity() const;
 
+	/**
+	 * Is this vehicle drawn?
+	 * @return true if it is drawn
+	 */
+	bool IsDrawn() const;
+
 	/**
 	 * Marks the vehicles to be redrawn and updates cached variables
 	 *
diff --git a/src/vehicle_gui.cpp b/src/vehicle_gui.cpp
index f30f772eb..023b3c852 100644
--- a/src/vehicle_gui.cpp
+++ b/src/vehicle_gui.cpp
@@ -35,7 +35,9 @@
 #include "engine_func.h"
 #include "station_base.h"
 #include "tilehighlight_func.h"
+#include "triphistory.h"
 #include "zoom_func.h"
+#include "hotkeys.h"
 
 #include "safeguards.h"
 
@@ -2046,6 +2048,7 @@ static const NWidgetPart _nested_nontrain_vehicle_details_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
 		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VD_CAPTION), SetDataTip(STR_VEHICLE_DETAILS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_TRIP_HISTORY),SetMinimalSize(44, 0),SetDataTip(STR_TRIP_HISTORY, STR_TRIP_HISTORY_TOOLTIP),
 		NWidget(WWT_SHADEBOX, COLOUR_GREY),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_GREY),
 		NWidget(WWT_STICKYBOX, COLOUR_GREY),
@@ -2069,6 +2072,7 @@ static const NWidgetPart _nested_train_vehicle_details_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
 		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VD_CAPTION), SetDataTip(STR_VEHICLE_DETAILS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_TRIP_HISTORY),SetMinimalSize(44, 0),SetDataTip(STR_TRIP_HISTORY, STR_TRIP_HISTORY_TOOLTIP),
 		NWidget(WWT_SHADEBOX, COLOUR_GREY),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_GREY),
 		NWidget(WWT_STICKYBOX, COLOUR_GREY),
@@ -2413,6 +2417,12 @@ struct VehicleDetailsWindow : Window {
 	void OnClick(Point pt, int widget, int click_count) override
 	{
 		switch (widget) {
+			case WID_VD_TRIP_HISTORY: {
+				const Vehicle *v = Vehicle::Get(this->window_number);
+				ShowTripHistoryWindow(v);
+				break;
+			}
+
 			case WID_VD_INCREASE_SERVICING_INTERVAL:   // increase int
 			case WID_VD_DECREASE_SERVICING_INTERVAL: { // decrease int
 				int mod = _ctrl_pressed ? 5 : 10;
@@ -2543,24 +2553,6 @@ static const NWidgetPart _nested_vehicle_view_widgets[] = {
 	EndContainer(),
 };
 
-/** Vehicle view window descriptor for all vehicles but trains. */
-static WindowDesc _vehicle_view_desc(
-	WDP_AUTO, "view_vehicle", 250, 116,
-	WC_VEHICLE_VIEW, WC_NONE,
-	0,
-	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets)
-);
-
-/**
- * Vehicle view window descriptor for trains. Only minimum_height and
- *  default_height are different for train view.
- */
-static WindowDesc _train_view_desc(
-	WDP_AUTO, "view_vehicle_train", 250, 134,
-	WC_VEHICLE_VIEW, WC_NONE,
-	0,
-	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets)
-);
 
 
 /* Just to make sure, nobody has changed the vehicle type constants, as we are
@@ -2754,6 +2746,7 @@ public:
 		CloseWindowById(WC_VEHICLE_REFIT, this->window_number, false);
 		CloseWindowById(WC_VEHICLE_DETAILS, this->window_number, false);
 		CloseWindowById(WC_VEHICLE_TIMETABLE, this->window_number, false);
+		CloseWindowById(WC_VEHICLE_TRIP_HISTORY, this->window_number, false);
 		this->Window::Close();
 	}
 
@@ -3077,8 +3070,45 @@ public:
 	{
 		::ShowNewGRFInspectWindow(GetGrfSpecFeature(Vehicle::Get(this->window_number)->type), this->window_number);
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		if (this->owner != _local_company) return ES_NOT_HANDLED;
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
 };
 
+static Hotkey vehiclegui_hotkeys[] = {
+	Hotkey('G', "vehicle_orders", WID_VV_SHOW_ORDERS),
+	Hotkey('F', "vehicle_go", WID_VV_START_STOP),
+	Hotkey((uint16)0, "vehicle_refit", WID_VV_REFIT),
+	Hotkey((uint16)0, "vehicle_clone", WID_VV_CLONE),
+	HOTKEY_LIST_END
+}; //WID_VV_CENTER_MAIN_VIEW WID_VV_GOTO_DEPOT WID_VV_SHOW_DETAILS WID_VV_TURN_AROUND WID_VV_FORCE_PROCEED
+HotkeyList VehicleViewWindow::hotkeys("vehiclegui", vehiclegui_hotkeys);
+
+/** Vehicle view window descriptor for all vehicles but trains. */
+static WindowDesc _vehicle_view_desc(
+	WDP_AUTO, "view_vehicle", 250, 116,
+	WC_VEHICLE_VIEW, WC_NONE,
+	0,
+	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets),
+	&VehicleViewWindow::hotkeys
+);
+
+/**
+ * Vehicle view window descriptor for trains. Only minimum_height and
+ *  default_height are different for train view.
+ */
+static WindowDesc _train_view_desc(
+	WDP_AUTO, "view_vehicle_train", 250, 134,
+	WC_VEHICLE_VIEW, WC_NONE,
+	0,
+	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets),
+	&VehicleViewWindow::hotkeys
+);
 
 /** Shows the vehicle view window of the given vehicle. */
 void ShowVehicleViewWindow(const Vehicle *v)
diff --git a/src/vehicle_gui.h b/src/vehicle_gui.h
index f4c044393..64a322de5 100644
--- a/src/vehicle_gui.h
+++ b/src/vehicle_gui.h
@@ -109,4 +109,6 @@ Vehicle *CheckClickOnVehicle(const struct Viewport *vp, int x, int y);
 void DrawVehicleImage(const Vehicle *v, int left, int right, int y, VehicleID selection, EngineImageType image_type, int skip);
 void SetMouseCursorVehicle(const Vehicle *v, EngineImageType image_type);
 
+void ShowTripHistoryWindow(const Vehicle *v);
+
 #endif /* VEHICLE_GUI_H */
diff --git a/src/video/sdl2_v.cpp b/src/video/sdl2_v.cpp
index 8ef00a00c..009e410c3 100644
--- a/src/video/sdl2_v.cpp
+++ b/src/video/sdl2_v.cpp
@@ -568,9 +568,11 @@ void VideoDriver_SDL_Base::InputLoop()
 	const Uint8 *keys = SDL_GetKeyboardState(nullptr);
 
 	bool old_ctrl_pressed = _ctrl_pressed;
+	bool old_alt_pressed = _alt_pressed;
 
-	_ctrl_pressed  = !!(mod & KMOD_CTRL);
-	_shift_pressed = !!(mod & KMOD_SHIFT);
+        _ctrl_pressed  = !!(mod & KMOD_CTRL);
+        _alt_pressed   = !!(mod & KMOD_ALT);
+        _shift_pressed = !!(mod & KMOD_SHIFT);
 
 #if defined(_DEBUG)
 	this->fast_forward_key_pressed = _shift_pressed;
diff --git a/src/video/sdl_v.cpp b/src/video/sdl_v.cpp
index 1b180d3b8..9ed023d29 100644
--- a/src/video/sdl_v.cpp
+++ b/src/video/sdl_v.cpp
@@ -620,9 +620,12 @@ void VideoDriver_SDL::InputLoop()
 	Uint8 *keys = SDL_GetKeyState(&numkeys);
 
 	bool old_ctrl_pressed = _ctrl_pressed;
+	bool old_alt_pressed = _alt_pressed;
 
 	_ctrl_pressed  = !!(mod & KMOD_CTRL);
+	_alt_pressed   = !!(mod & KMOD_ALT);
 	_shift_pressed = !!(mod & KMOD_SHIFT);
+	_alt_pressed = !!(mod & KMOD_ALT);
 
 #if defined(_DEBUG)
 	this->fast_forward_key_pressed = _shift_pressed;
@@ -641,6 +644,7 @@ void VideoDriver_SDL::InputLoop()
 
 	if (old_ctrl_pressed != _ctrl_pressed) HandleCtrlChanged();
 }
+			bool old_alt_pressed = _alt_pressed;
 
 void VideoDriver_SDL::MainLoop()
 {
diff --git a/src/video/win32_v.cpp b/src/video/win32_v.cpp
index 22b8f3541..3e31cc30b 100644
--- a/src/video/win32_v.cpp
+++ b/src/video/win32_v.cpp
@@ -818,9 +818,13 @@ void VideoDriver_Win32Base::CheckPaletteAnim()
 void VideoDriver_Win32Base::InputLoop()
 {
 	bool old_ctrl_pressed = _ctrl_pressed;
+	bool old_alt_pressed = _alt_pressed;
 
 	_ctrl_pressed = this->has_focus && GetAsyncKeyState(VK_CONTROL) < 0;
+	_alt_pressed  = this->has_focus && GetAsyncKeyState(VK_MENU)<0;
 	_shift_pressed = this->has_focus && GetAsyncKeyState(VK_SHIFT) < 0;
+	_alt_pressed = this->has_focus && GetAsyncKeyState(VK_MENU) < 0;
+
 
 #if defined(_DEBUG)
 	this->fast_forward_key_pressed = _shift_pressed;
diff --git a/src/viewport.cpp b/src/viewport.cpp
index 11dfa1560..5f7560fb5 100644
--- a/src/viewport.cpp
+++ b/src/viewport.cpp
@@ -61,6 +61,9 @@
  */
 
 #include "stdafx.h"
+#include "math.h"
+#include "core/math_func.hpp"
+#include "core/smallvec_type.hpp"
 #include "landscape.h"
 #include "viewport_func.h"
 #include "station_base.h"
@@ -83,7 +86,7 @@
 #include "viewport_kdtree.h"
 #include "town_kdtree.h"
 #include "viewport_sprite_sorter.h"
-#include "bridge_map.h"
+#include "tunnelbridge_map.h"
 #include "company_base.h"
 #include "command_func.h"
 #include "network/network_func.h"
@@ -95,6 +98,9 @@
 
 #include "table/strings.h"
 #include "table/string_colours.h"
+#include "zoning.h"
+#include "industry_type.h"
+
 
 #include "safeguards.h"
 
@@ -159,6 +165,28 @@ typedef std::vector<StringSpriteToDraw> StringSpriteToDrawVector;
 typedef std::vector<ParentSpriteToDraw> ParentSpriteToDrawVector;
 typedef std::vector<ChildScreenSpriteToDraw> ChildScreenSpriteToDrawVector;
 
+/**
+ * Snapping point for a track.
+ *
+ * Point where a track (rail/road/other) can be snapped to while selecting tracks with polyline
+ * tool (HT_POLY). Besides of x/y coordinates expressed in tile "units" it contains a set of
+ * allowed line directions.
+ */
+struct LineSnapPoint : Point {
+	uint8 dirs; ///< Allowed line directions, set of #Direction bits.
+};
+
+typedef std::vector<LineSnapPoint> LineSnapPoints; ///< Set of snapping points
+
+/** Coordinates of a polyline track made of 2 connected line segments. */
+struct RailPolyline {
+	Point start;           ///< The point where the first segment starts (as given in LineSnapPoint).
+	Direction first_dir;   ///< Direction of the first line segment.
+	uint first_len;        ///< Length of the first segment - number of track pieces.
+	Direction second_dir;  ///< Direction of the second line segment.
+	uint second_len;       ///< Length of the second segment - number of track pieces.
+};
+
 /** Data structure storing rendering information */
 struct ViewportDrawer {
 	DrawPixelInfo dpi;
@@ -190,6 +218,14 @@ bool _draw_dirty_blocks = false;
 uint _dirty_block_colour = 0;
 static VpSpriteSorter _vp_sprite_sorter = nullptr;
 
+static RailSnapMode _rail_snap_mode = RSM_NO_SNAP; ///< Type of rail track snapping (polyline tool).
+static LineSnapPoints _tile_snap_points; ///< Tile to which a rail track will be snapped to (polyline tool).
+static LineSnapPoints _rail_snap_points; ///< Set of points where a rail track will be snapped to (polyline tool).
+static LineSnapPoint _current_snap_lock; ///< Start point and direction at which selected track is locked on currently (while dragging in polyline mode).
+
+static TileIndex GetRailSnapTile();
+static void SetRailSnapTile(TileIndex tile);
+
 static Point MapXYZToViewport(const Viewport *vp, int x, int y, int z)
 {
 	Point p = RemapCoords(x, y, z);
@@ -526,7 +562,7 @@ static void AddTileSpriteToDraw(SpriteID image, PaletteID pal, int32 x, int32 y,
  * @param extra_offs_x Pixel X offset for the sprite position.
  * @param extra_offs_y Pixel Y offset for the sprite position.
  */
-static void AddChildSpriteToFoundation(SpriteID image, PaletteID pal, const SubSprite *sub, FoundationPart foundation_part, int extra_offs_x, int extra_offs_y)
+void AddChildSpriteToFoundation(SpriteID image, PaletteID pal, const SubSprite *sub, FoundationPart foundation_part, int extra_offs_x, int extra_offs_y)
 {
 	assert(IsInsideMM(foundation_part, 0, FOUNDATION_PART_END));
 	assert(_vd.foundation[foundation_part] != -1);
@@ -708,9 +744,9 @@ void AddSortableSpriteToDraw(SpriteID image, PaletteID pal, int x, int y, int w,
 
 	/* Do not add the sprite to the viewport, if it is outside */
 	if (left   >= _vd.dpi.left + _vd.dpi.width ||
-	    right  <= _vd.dpi.left                 ||
-	    top    >= _vd.dpi.top + _vd.dpi.height ||
-	    bottom <= _vd.dpi.top) {
+		right  <= _vd.dpi.left                 ||
+		top    >= _vd.dpi.top + _vd.dpi.height ||
+		bottom <= _vd.dpi.top) {
 		return;
 	}
 
@@ -790,13 +826,17 @@ static bool IsInRangeInclusive(int begin, int end, int check)
 }
 
 /**
- * Checks whether a point is inside the selected a diagonal rectangle given by _thd.size and _thd.pos
+ * Checks whether a point is inside the selected rectangle given by _thd.size, _thd.pos and _thd.diagonal
  * @param x The x coordinate of the point to be checked.
  * @param y The y coordinate of the point to be checked.
  * @return True if the point is inside the rectangle, else false.
  */
-bool IsInsideRotatedRectangle(int x, int y)
+bool IsInsideSelectedRectangle(int x, int y)
 {
+	if (!_thd.diagonal) {
+		return IsInsideBS(x, _thd.pos.x, _thd.size.x) && IsInsideBS(y, _thd.pos.y, _thd.size.y);
+	}
+
 	int dist_a = (_thd.size.x + _thd.size.y);      // Rotated coordinate system for selected rectangle.
 	int dist_b = (_thd.size.x - _thd.size.y);      // We don't have to divide by 2. It's all relative!
 	int a = ((x - _thd.pos.x) + (y - _thd.pos.y)); // Rotated coordinate system for the point under scrutiny.
@@ -872,7 +912,7 @@ static void AddStringToDraw(int x, int y, StringID string, uint64 params_1, uint
  * @param z_offset Z offset relative to the groundsprite. Only used for the sprite position, not for sprite sorting.
  * @param foundation_part Foundation part the sprite belongs to.
  */
-static void DrawSelectionSprite(SpriteID image, PaletteID pal, const TileInfo *ti, int z_offset, FoundationPart foundation_part)
+void DrawSelectionSprite(SpriteID image, PaletteID pal, const TileInfo *ti, int z_offset, FoundationPart foundation_part)
 {
 	/* FIXME: This is not totally valid for some autorail highlights that extend over the edges of the tile. */
 	if (_vd.foundation[foundation_part] == -1) {
@@ -913,34 +953,26 @@ static void DrawTileSelectionRect(const TileInfo *ti, PaletteID pal)
 	DrawSelectionSprite(sel, pal, ti, 7, FOUNDATION_PART_NORMAL);
 }
 
-static bool IsPartOfAutoLine(int px, int py)
+static HighLightStyle GetPartOfAutoLine(int px, int py, const Point &selstart, const Point &selend, HighLightStyle dir)
 {
-	px -= _thd.selstart.x;
-	py -= _thd.selstart.y;
-
-	if ((_thd.drawstyle & HT_DRAG_MASK) != HT_LINE) return false;
-
-	switch (_thd.drawstyle & HT_DIR_MASK) {
-		case HT_DIR_X:  return py == 0; // x direction
-		case HT_DIR_Y:  return px == 0; // y direction
-		case HT_DIR_HU: return px == -py || px == -py - 16; // horizontal upper
-		case HT_DIR_HL: return px == -py || px == -py + 16; // horizontal lower
-		case HT_DIR_VL: return px == py || px == py + 16; // vertical left
-		case HT_DIR_VR: return px == py || px == py - 16; // vertical right
-		default:
-			NOT_REACHED();
+	if (!IsInRangeInclusive(selstart.x & ~TILE_UNIT_MASK, selend.x & ~TILE_UNIT_MASK, px)) return HT_DIR_END;
+	if (!IsInRangeInclusive(selstart.y & ~TILE_UNIT_MASK, selend.y & ~TILE_UNIT_MASK, py)) return HT_DIR_END;
+
+	px -= selstart.x & ~TILE_UNIT_MASK;
+	py -= selstart.y & ~TILE_UNIT_MASK;
+
+	switch (dir) {
+		case HT_DIR_X: return (py == 0) ? HT_DIR_X : HT_DIR_END;
+		case HT_DIR_Y: return (px == 0) ? HT_DIR_Y : HT_DIR_END;
+		case HT_DIR_HU: return (px == -py) ? HT_DIR_HU : (px == -py - (int)TILE_SIZE) ? HT_DIR_HL : HT_DIR_END;
+		case HT_DIR_HL: return (px == -py) ? HT_DIR_HL : (px == -py + (int)TILE_SIZE) ? HT_DIR_HU : HT_DIR_END;
+		case HT_DIR_VL: return (px ==  py) ? HT_DIR_VL : (px ==  py + (int)TILE_SIZE) ? HT_DIR_VR : HT_DIR_END;
+		case HT_DIR_VR: return (px ==  py) ? HT_DIR_VR : (px ==  py - (int)TILE_SIZE) ? HT_DIR_VL : HT_DIR_END;
+		default: NOT_REACHED(); break;
 	}
-}
 
-/* [direction][side] */
-static const HighLightStyle _autorail_type[6][2] = {
-	{ HT_DIR_X,  HT_DIR_X },
-	{ HT_DIR_Y,  HT_DIR_Y },
-	{ HT_DIR_HU, HT_DIR_HL },
-	{ HT_DIR_HL, HT_DIR_HU },
-	{ HT_DIR_VL, HT_DIR_VR },
-	{ HT_DIR_VR, HT_DIR_VL }
-};
+	return HT_DIR_END;
+}
 
 #include "table/autorail.h"
 
@@ -948,18 +980,18 @@ static const HighLightStyle _autorail_type[6][2] = {
  * Draws autorail highlights.
  *
  * @param *ti TileInfo Tile that is being drawn
- * @param autorail_type Offset into _AutorailTilehSprite[][]
+ * @param autorail_type \c HT_DIR_XXX, offset into _AutorailTilehSprite[][]
+ * @param pal Palette to use, -1 to autodetect
  */
-static void DrawAutorailSelection(const TileInfo *ti, uint autorail_type)
+static void DrawAutorailSelection(const TileInfo *ti, HighLightStyle autorail_type, PaletteID pal = -1)
 {
 	SpriteID image;
-	PaletteID pal;
 	int offset;
 
 	FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
 	Slope autorail_tileh = RemoveHalftileSlope(ti->tileh);
 	if (IsHalftileSlope(ti->tileh)) {
-		static const uint _lower_rail[4] = { 5U, 2U, 4U, 3U };
+		static const HighLightStyle _lower_rail[CORNER_END] = { HT_DIR_VR, HT_DIR_HU, HT_DIR_VL, HT_DIR_HL }; // CORNER_W, CORNER_S, CORNER_E, CORNER_N
 		Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
 		if (autorail_type != _lower_rail[halftile_corner]) {
 			foundation_part = FOUNDATION_PART_HALFTILE;
@@ -968,16 +1000,17 @@ static void DrawAutorailSelection(const TileInfo *ti, uint autorail_type)
 		}
 	}
 
+	assert(autorail_type < HT_DIR_END);
 	offset = _AutorailTilehSprite[autorail_tileh][autorail_type];
 	if (offset >= 0) {
 		image = SPR_AUTORAIL_BASE + offset;
-		pal = PAL_NONE;
+		if (pal == (PaletteID)-1) pal = _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE;
 	} else {
 		image = SPR_AUTORAIL_BASE - offset;
-		pal = PALETTE_SEL_TILE_RED;
+		if (pal == (PaletteID)-1) pal = PALETTE_SEL_TILE_RED;
 	}
 
-	DrawSelectionSprite(image, _thd.make_square_red ? PALETTE_SEL_TILE_RED : pal, ti, 7, foundation_part);
+	DrawSelectionSprite(image, pal, ti, 7, foundation_part);
 }
 
 enum TileHighlightType {
@@ -1089,66 +1122,62 @@ static void DrawTileSelection(const TileInfo *ti)
 	TileHighlightType tht = GetTileHighlightType(ti->tile);
 	DrawTileHighlightType(ti, tht);
 
-	/* No tile selection active? */
-	if ((_thd.drawstyle & HT_DRAG_MASK) == HT_NONE) return;
 
-	if (_thd.diagonal) { // We're drawing a 45 degrees rotated (diagonal) rectangle
-		if (IsInsideRotatedRectangle((int)ti->x, (int)ti->y)) goto draw_inner;
-		return;
-	}
+	switch (_thd.drawstyle & HT_DRAG_MASK) {
+		default: break; // No tile selection active?
 
-	/* Inside the inner area? */
-	if (IsInsideBS(ti->x, _thd.pos.x, _thd.size.x) &&
-			IsInsideBS(ti->y, _thd.pos.y, _thd.size.y)) {
-draw_inner:
-		if (_thd.drawstyle & HT_RECT) {
-			if (!is_redsq) DrawTileSelectionRect(ti, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE);
-		} else if (_thd.drawstyle & HT_POINT) {
-			/* Figure out the Z coordinate for the single dot. */
-			int z = 0;
-			FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
-			if (ti->tileh & SLOPE_N) {
-				z += TILE_HEIGHT;
-				if (RemoveHalftileSlope(ti->tileh) == SLOPE_STEEP_N) z += TILE_HEIGHT;
+		case HT_RECT:
+			if (!is_redsq) {
+				if (IsInsideSelectedRectangle(ti->x, ti->y)) {
+					DrawTileSelectionRect(ti, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE);
+				} else if (_thd.outersize.x > 0 &&
+						/* Check if it's inside the outer area? */
+						IsInsideBS(ti->x, _thd.pos.x + _thd.offs.x, _thd.size.x + _thd.outersize.x) &&
+						IsInsideBS(ti->y, _thd.pos.y + _thd.offs.y, _thd.size.y + _thd.outersize.y)) {
+					/* Draw a blue rect. */
+					DrawTileSelectionRect(ti, PALETTE_SEL_TILE_BLUE);
+				}
 			}
-			if (IsHalftileSlope(ti->tileh)) {
-				Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
-				if ((halftile_corner == CORNER_W) || (halftile_corner == CORNER_E)) z += TILE_HEIGHT;
-				if (halftile_corner != CORNER_S) {
-					foundation_part = FOUNDATION_PART_HALFTILE;
-					if (IsSteepSlope(ti->tileh)) z -= TILE_HEIGHT;
+			break;
+
+		case HT_POINT:
+			if (IsInsideSelectedRectangle(ti->x, ti->y)) {
+				/* Figure out the Z coordinate for the single dot. */
+				int z = 0;
+				FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
+				if (ti->tileh & SLOPE_N) {
+					z += TILE_HEIGHT;
+					if (RemoveHalftileSlope(ti->tileh) == SLOPE_STEEP_N) z += TILE_HEIGHT;
 				}
+				if (IsHalftileSlope(ti->tileh)) {
+					Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
+					if ((halftile_corner == CORNER_W) || (halftile_corner == CORNER_E)) z += TILE_HEIGHT;
+					if (halftile_corner != CORNER_S) {
+						foundation_part = FOUNDATION_PART_HALFTILE;
+						if (IsSteepSlope(ti->tileh)) z -= TILE_HEIGHT;
+					}
+				}
+				DrawSelectionSprite(_cur_dpi->zoom <= ZOOM_LVL_DETAIL ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti, z, foundation_part);
 			}
-			DrawSelectionSprite(_cur_dpi->zoom <= ZOOM_LVL_DETAIL ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti, z, foundation_part);
-		} else if (_thd.drawstyle & HT_RAIL) {
-			/* autorail highlight piece under cursor */
-			HighLightStyle type = _thd.drawstyle & HT_DIR_MASK;
-			assert(type < HT_DIR_END);
-			DrawAutorailSelection(ti, _autorail_type[type][0]);
-		} else if (IsPartOfAutoLine(ti->x, ti->y)) {
-			/* autorail highlighting long line */
-			HighLightStyle dir = _thd.drawstyle & HT_DIR_MASK;
-			uint side;
-
-			if (dir == HT_DIR_X || dir == HT_DIR_Y) {
-				side = 0;
-			} else {
-				TileIndex start = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
-				side = Delta(Delta(TileX(start), TileX(ti->tile)), Delta(TileY(start), TileY(ti->tile)));
+			break;
+
+		case HT_RAIL:
+			if (ti->tile == TileVirtXY(_thd.pos.x, _thd.pos.y)) {
+				assert((_thd.drawstyle & HT_DIR_MASK) < HT_DIR_END);
+				DrawAutorailSelection(ti, _thd.drawstyle & HT_DIR_MASK);
 			}
+			break;
 
-			DrawAutorailSelection(ti, _autorail_type[dir][side]);
+		case HT_LINE: {
+			HighLightStyle type = GetPartOfAutoLine(ti->x, ti->y, _thd.selstart, _thd.selend, _thd.drawstyle & HT_DIR_MASK);
+			if (type < HT_DIR_END) {
+				DrawAutorailSelection(ti, type);
+			} else if (_thd.dir2 < HT_DIR_END) {
+				type = GetPartOfAutoLine(ti->x, ti->y, _thd.selstart2, _thd.selend2, _thd.dir2);
+				if (type < HT_DIR_END) DrawAutorailSelection(ti, type, PALETTE_SEL_TILE_BLUE);
+			}
+			break;
 		}
-		return;
-	}
-
-	/* Check if it's inside the outer area? */
-	if (!is_redsq && (tht == THT_NONE || tht == THT_RED) && _thd.outersize.x > 0 &&
-			IsInsideBS(ti->x, _thd.pos.x + _thd.offs.x, _thd.size.x + _thd.outersize.x) &&
-			IsInsideBS(ti->y, _thd.pos.y + _thd.offs.y, _thd.size.y + _thd.outersize.y)) {
-		/* Draw a blue rect. */
-		DrawTileSelectionRect(ti, PALETTE_SEL_TILE_BLUE);
-		return;
 	}
 }
 
@@ -1275,7 +1304,10 @@ static void ViewportAddLandscape()
 				_vd.last_foundation_child[1] = nullptr;
 
 				_tile_type_procs[tile_type]->draw_tile_proc(&tile_info);
-				if (tile_info.tile != INVALID_TILE) DrawTileSelection(&tile_info);
+								if (tile_info.tile != INVALID_TILE) {
+										DrawTileSelection(&tile_info);
+										DrawTileZoning(&tile_info);
+								}
 			}
 		}
 	}
@@ -1323,7 +1355,7 @@ void ViewportAddString(const DrawPixelInfo *dpi, ZoomLevel small_from, const Vie
 	}
 }
 
-static Rect ExpandRectWithViewportSignMargins(Rect r, ZoomLevel zoom)
+Rect ExpandRectWithViewportSignMargins(Rect r, ZoomLevel zoom)
 {
 	/* Pessimistically always use normal font, but also assume small font is never larger in either dimension */
 	const int fh = FONT_HEIGHT_NORMAL;
@@ -1651,9 +1683,9 @@ static void ViewportDrawBoundingBoxes(const ParentSpriteToSortVector *psd)
 		Point pt4 = RemapCoords(ps->xmax + 1, ps->ymax + 1, ps->zmin    ); // bottom front corner
 
 		DrawBox(        pt1.x,         pt1.y,
-		        pt2.x - pt1.x, pt2.y - pt1.y,
-		        pt3.x - pt1.x, pt3.y - pt1.y,
-		        pt4.x - pt1.x, pt4.y - pt1.y);
+				pt2.x - pt1.x, pt2.y - pt1.y,
+				pt3.x - pt1.x, pt3.y - pt1.y,
+				pt4.x - pt1.x, pt4.y - pt1.y);
 	}
 }
 
@@ -2010,7 +2042,7 @@ static void SetSelectionTilesDirty()
 		int x_start = _thd.pos.x;
 		int y_start = _thd.pos.y;
 
-		if (_thd.outersize.x != 0) {
+		if (_thd.outersize.x != 0 || _thd.outersize.y != 0) {
 			x_size  += _thd.outersize.x;
 			x_start += _thd.offs.x;
 			y_size  += _thd.outersize.y;
@@ -2345,7 +2377,7 @@ static void PlaceObject()
 }
 
 
-bool HandleViewportClicked(const Viewport *vp, int x, int y)
+bool HandleViewportClicked(const Viewport *vp, int x, int y, bool double_click)
 {
 	const Vehicle *v = CheckClickOnVehicle(vp, x, y);
 
@@ -2355,6 +2387,18 @@ bool HandleViewportClicked(const Viewport *vp, int x, int y)
 
 	/* Vehicle placement mode already handled above. */
 	if ((_thd.place_mode & HT_DRAG_MASK) != HT_NONE) {
+		if (_thd.place_mode & HT_POLY) {
+			/* In polyline mode double-clicking on a single white line, finishes current polyline.
+			 * If however the user double-clicks on a line that has a white and a blue section,
+			 * both lines (white and blue) will be constructed consecutively. */
+			static bool stop_snap_on_double_click = false;
+			if (double_click && stop_snap_on_double_click) {
+				SetRailSnapMode(RSM_NO_SNAP);
+				return true;
+			}
+			stop_snap_on_double_click = !(_thd.drawstyle & HT_LINE) || (_thd.dir2 == HT_DIR_END);
+		}
+
 		PlaceObject();
 		return true;
 	}
@@ -2367,7 +2411,8 @@ bool HandleViewportClicked(const Viewport *vp, int x, int y)
 		if (IsCompanyBuildableVehicleType(v)) {
 			v = v->First();
 			if (_ctrl_pressed && v->owner == _local_company) {
-				StartStopVehicle(v, true);
+				if (_settings_client.gui.enable_ctrl_click_start_stop)
+					StartStopVehicle(v, true);
 			} else {
 				ShowVehicleViewWindow(v);
 			}
@@ -2479,8 +2524,8 @@ void SetTileSelectSize(int w, int h)
 
 void SetTileSelectBigSize(int ox, int oy, int sx, int sy)
 {
-	_thd.offs.x = ox * TILE_SIZE;
-	_thd.offs.y = oy * TILE_SIZE;
+	_thd.new_offs.x = ox * TILE_SIZE;
+	_thd.new_offs.y = oy * TILE_SIZE;
 	_thd.new_outersize.x = sx * TILE_SIZE;
 	_thd.new_outersize.y = sy * TILE_SIZE;
 }
@@ -2520,7 +2565,37 @@ Window *TileHighlightData::GetCallbackWnd()
 	return FindWindowById(this->window_class, this->window_number);
 }
 
+static HighLightStyle CalcPolyrailDrawstyle(Point pt, bool dragging);
 
+/** Update size of the area occupied by the blue part of rail track highlight (polyline mode). */
+static inline void CalcNewPolylineOutersize()
+{
+	/* use the 'outersize' to mark the second (blue) part of a polyline selection */
+	if (_thd.dir2 < HT_DIR_END) {
+		/* get bounds of the second part */
+		int outer_x1 = _thd.selstart2.x & ~TILE_UNIT_MASK;
+		int outer_y1 = _thd.selstart2.y & ~TILE_UNIT_MASK;
+		int outer_x2 = _thd.selend2.x & ~TILE_UNIT_MASK;
+		int outer_y2 = _thd.selend2.y & ~TILE_UNIT_MASK;
+		if (outer_x1 > outer_x2) Swap(outer_x1, outer_x2);
+		if (outer_y1 > outer_y2) Swap(outer_y1, outer_y2);
+		/* include the first part */
+		outer_x1 = std::min<int>(outer_x1, _thd.new_pos.x);
+		outer_y1 = std::min<int>(outer_y1, _thd.new_pos.y);
+		outer_x2 = std::max<int>(outer_x2, _thd.new_pos.x + _thd.new_size.x - TILE_SIZE);
+		outer_y2 = std::max<int>(outer_y2, _thd.new_pos.y + _thd.new_size.y - TILE_SIZE);
+		/* write new values */
+		_thd.new_offs.x = outer_x1 - _thd.new_pos.x;
+		_thd.new_offs.y = outer_y1 - _thd.new_pos.y;
+		_thd.new_outersize.x = outer_x2 - outer_x1 + TILE_SIZE - _thd.new_size.x;
+		_thd.new_outersize.y = outer_y2 - outer_y1 + TILE_SIZE - _thd.new_size.y;
+	} else {
+		_thd.new_offs.x = 0;
+		_thd.new_offs.y = 0;
+		_thd.new_outersize.x = 0;
+		_thd.new_outersize.y = 0;
+	}
+}
 
 /**
  * Updates tile highlighting for all cases.
@@ -2579,10 +2654,42 @@ void UpdateTileSelection()
 					y1 += TILE_SIZE / 2;
 					break;
 				case HT_RAIL:
-					/* Draw one highlighted tile in any direction */
-					new_drawstyle = GetAutorailHT(pt.x, pt.y);
-					break;
 				case HT_LINE:
+					/* HT_POLY */
+					if (_thd.place_mode & HT_POLY) {
+						RailSnapMode snap_mode = GetRailSnapMode();
+						if (snap_mode == RSM_NO_SNAP ||
+								(snap_mode == RSM_SNAP_TO_TILE && GetRailSnapTile() == TileVirtXY(pt.x, pt.y))) {
+							new_drawstyle = GetAutorailHT(pt.x, pt.y);
+							_thd.new_offs.x = 0;
+							_thd.new_offs.y = 0;
+							_thd.new_outersize.x = 0;
+							_thd.new_outersize.y = 0;
+							_thd.dir2 = HT_DIR_END;
+						} else {
+							new_drawstyle = CalcPolyrailDrawstyle(pt, false);
+							if (new_drawstyle != HT_NONE) {
+								x1 = _thd.selstart.x & ~TILE_UNIT_MASK;
+								y1 = _thd.selstart.y & ~TILE_UNIT_MASK;
+								int x2 = _thd.selend.x & ~TILE_UNIT_MASK;
+								int y2 = _thd.selend.y & ~TILE_UNIT_MASK;
+								if (x1 > x2) Swap(x1, x2);
+								if (y1 > y2) Swap(y1, y2);
+								_thd.new_pos.x = x1;
+								_thd.new_pos.y = y1;
+								_thd.new_size.x = x2 - x1 + TILE_SIZE;
+								_thd.new_size.y = y2 - y1 + TILE_SIZE;
+							}
+						}
+						break;
+					}
+					/* HT_RAIL */
+					if (_thd.place_mode & HT_RAIL) {
+						/* Draw one highlighted tile in any direction */
+						new_drawstyle = GetAutorailHT(pt.x, pt.y);
+						break;
+					}
+					/* HT_LINE */
 					switch (_thd.place_mode & HT_DIR_MASK) {
 						case HT_DIR_X: new_drawstyle = HT_LINE | HT_DIR_X; break;
 						case HT_DIR_Y: new_drawstyle = HT_LINE | HT_DIR_Y; break;
@@ -2601,6 +2708,9 @@ void UpdateTileSelection()
 					}
 					_thd.selstart.x = x1 & ~TILE_UNIT_MASK;
 					_thd.selstart.y = y1 & ~TILE_UNIT_MASK;
+					_thd.selend.x = x1;
+					_thd.selend.y = y1;
+					_thd.dir2 = HT_DIR_END;
 					break;
 				default:
 					NOT_REACHED();
@@ -2610,10 +2720,13 @@ void UpdateTileSelection()
 		}
 	}
 
+	if (new_drawstyle & HT_LINE) CalcNewPolylineOutersize();
+
 	/* redraw selection */
 	if (_thd.drawstyle != new_drawstyle ||
 			_thd.pos.x != _thd.new_pos.x || _thd.pos.y != _thd.new_pos.y ||
 			_thd.size.x != _thd.new_size.x || _thd.size.y != _thd.new_size.y ||
+			_thd.offs.x != _thd.new_offs.x || _thd.offs.y != _thd.new_offs.y ||
 			_thd.outersize.x != _thd.new_outersize.x ||
 			_thd.outersize.y != _thd.new_outersize.y ||
 			_thd.diagonal    != new_diagonal) {
@@ -2623,6 +2736,7 @@ void UpdateTileSelection()
 		_thd.drawstyle = new_drawstyle;
 		_thd.pos = _thd.new_pos;
 		_thd.size = _thd.new_size;
+		_thd.offs = _thd.new_offs;
 		_thd.outersize = _thd.new_outersize;
 		_thd.diagonal = new_diagonal;
 		_thd.dirty = 0xff;
@@ -2677,6 +2791,11 @@ void VpStartPlaceSizing(TileIndex tile, ViewportPlaceMethod method, ViewportDrag
 	} else if (_thd.place_mode & (HT_RAIL | HT_LINE)) {
 		_thd.place_mode = HT_SPECIAL | others;
 		_thd.next_drawstyle = _thd.drawstyle | others;
+		_current_snap_lock.x = -1;
+		if ((_thd.place_mode & HT_POLY) != 0 && GetRailSnapMode() == RSM_NO_SNAP) {
+			SetRailSnapMode(RSM_SNAP_TO_TILE);
+			SetRailSnapTile(tile);
+		}
 	} else {
 		_thd.place_mode = HT_SPECIAL | others;
 		_thd.next_drawstyle = HT_POINT | others;
@@ -2717,7 +2836,7 @@ void VpSetPresizeRange(TileIndex from, TileIndex to)
 	_thd.next_drawstyle = HT_RECT;
 
 	/* show measurement only if there is any length to speak of */
-	if (distance > 1) {
+	if (distance > 1  && _settings_client.gui.measure_tooltip) {
 		ShowMeasurementTooltips(STR_MEASURE_LENGTH, 1, &distance);
 	} else {
 		HideMeasurementTooltips();
@@ -2884,7 +3003,39 @@ static int CalcHeightdiff(HighLightStyle style, uint distance, TileIndex start_t
 	return (int)(h1 - h0) * TILE_HEIGHT_STEP;
 }
 
-static const StringID measure_strings_length[] = {STR_NULL, STR_MEASURE_LENGTH, STR_MEASURE_LENGTH_HEIGHTDIFF};
+/**
+ * Show a tooltip indicating the length of highlighted rail track.
+ * @param style                   Style of the highlight.
+ * @param start_tile              Tile where selection starts.
+ * @param end_tile                Tile where selection ends.
+ * @param close_cond              Close condition of the tooltip.
+ * @param show_single_tile_length Show a tooltip also when the length is 1 tile.
+ */
+static void ShowLengthMeasurement(HighLightStyle style, TileIndex start_tile, TileIndex end_tile, TooltipCloseCondition close_cond = TCC_NONE, bool show_single_tile_length = false)
+{
+	static const StringID measure_strings_length[] = {STR_NULL, STR_MEASURE_LENGTH, STR_MEASURE_LENGTH_HEIGHTDIFF};
+
+	if (_settings_client.gui.measure_tooltip) {
+		uint distance = DistanceManhattan(start_tile, end_tile) + 1;
+		byte index = 0;
+		uint64 params[2];
+
+		if (show_single_tile_length || distance != 1) {
+			int heightdiff = CalcHeightdiff(style, distance, start_tile, end_tile);
+			/* If we are showing a tooltip for horizontal or vertical drags,
+			 * 2 tiles have a length of 1. To bias towards the ceiling we add
+			 * one before division. It feels more natural to count 3 lengths as 2 */
+			if ((style & HT_DIR_MASK) != HT_DIR_X && (style & HT_DIR_MASK) != HT_DIR_Y) {
+				distance = CeilDiv(distance, 2);
+			}
+
+			params[index++] = distance;
+			if (heightdiff != 0) params[index++] = heightdiff;
+		}
+
+		ShowMeasurementTooltips(measure_strings_length[index], index, params, close_cond);
+	}
+}
 
 /**
  * Check for underflowing the map.
@@ -2915,6 +3066,198 @@ static void CheckOverflow(int &test, int &other, int max, int mult)
 	test = max;
 }
 
+static const uint X_DIRS = (1 << DIR_NE) | (1 << DIR_SW);
+static const uint Y_DIRS = (1 << DIR_SE) | (1 << DIR_NW);
+static const uint HORZ_DIRS = (1 << DIR_W) | (1 << DIR_E);
+static const uint VERT_DIRS = (1 << DIR_N) | (1 << DIR_S);
+
+/**
+ * Convert a given point and a given #Direction to best matching #Trackdir.
+ *
+ * For example, #DIR_N will be converted to #TRACKDIR_LEFT_N if the point
+ * is on left tile half or #TRACKDIR_RIGHT_N if the point is on right half.
+ *
+ * @param pt  The point expressed in inner-tile world "units".
+ * @param dir The direction.
+ * @return The matching #Trackdir.
+ */
+Trackdir PointDirToTrackdir(const Point &pt, Direction dir)
+{
+	Trackdir ret;
+
+	if (IsDiagonalDirection(dir)) {
+		ret = DiagDirToDiagTrackdir(DirToDiagDir(dir));
+	} else {
+		int x = pt.x & TILE_UNIT_MASK;
+		int y = pt.y & TILE_UNIT_MASK;
+		int ns = x + y;
+		int we = y - x;
+		if (HasBit(HORZ_DIRS, dir)) {
+			ret = TrackDirectionToTrackdir(ns < (int)TILE_SIZE ? TRACK_UPPER : TRACK_LOWER, dir);
+		} else {
+			ret = TrackDirectionToTrackdir(we < 0 ? TRACK_LEFT : TRACK_RIGHT, dir);
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * Try to fit a pair of rail track lines (polyline) based on a given end point
+ * (mouse cursor position) and a given snap point (begin point).
+ *
+ * @param pt       The end point expressed in inner-tile world "units".
+ * @param start    The snap point, begin of the lines.
+ * @param[out] ret Coordinates of the lines (if found).
+ * @return Whether the lines were found.
+ */
+
+static bool FindPolyline(const Point &pt, const LineSnapPoint &start, RailPolyline *ret) {
+	/* relative coordinates of the mouse point (offset against the snap point) */
+	int x = pt.x - start.x;
+	int y = pt.y - start.y;
+	int we = y - x;
+	int ns = x + y;
+
+	/* in-tile alignment of the snap point (there are two variants: [0, 8] or [8, 0]) */
+	uint align_x = start.x & TILE_UNIT_MASK;
+	uint align_y = start.y & TILE_UNIT_MASK;
+	assert((align_x == TILE_SIZE / 2 && align_y == 0 && !(start.dirs & X_DIRS)) || (align_x == 0 && align_y == TILE_SIZE / 2 && !(start.dirs & Y_DIRS)));
+
+	/* absolute distance between points (in tiles) */
+	uint d_x = abs(RoundDivSU(x < 0 ? x - align_y : x + align_y, TILE_SIZE));
+	uint d_y = abs(RoundDivSU(y < 0 ? y - align_x : y + align_x, TILE_SIZE));
+	uint d_ns = abs(RoundDivSU(ns, TILE_SIZE));
+	uint d_we = abs(RoundDivSU(we, TILE_SIZE));
+
+	/* Find on which quadrant is the mouse point (relatively to the snap point).
+	 * Numeration (clockwise like in Direction):
+	 * ortho            diag
+	 *   \   2   /       2 | 3
+	 *     \   /         --+---> [we]
+	 *  1    X    3      1 | 0
+	 *     /   \           v
+	 *  [x]  0  [y]       [ns]          */
+	uint ortho_quadrant = 2 * (x < 0) + ((x < 0) != (y < 0)); // implicit cast: false/true --> 0/1
+	uint diag_quadrant = 2 * (ns < 0) + ((ns < 0) != (we < 0));
+
+	/* direction from the snap point to the mouse point */
+	Direction ortho_line_dir = ChangeDir(DIR_S, (DirDiff)(2 * ortho_quadrant)); // DIR_S is the middle of the ortho quadrant no. 0
+	Direction diag_line_dir = ChangeDir(DIR_SE, (DirDiff)(2 * diag_quadrant));  // DIR_SE is the middle of the diag quadrant no. 0
+	if (!HasBit(start.dirs, ortho_line_dir) && !HasBit(start.dirs, diag_line_dir)) return false;
+
+	/* length of booth segments of auto line (choosing orthogonal direction first) */
+	uint ortho_len = 0, ortho_len2 = 0;
+	if (HasBit(start.dirs, ortho_line_dir)) {
+		bool is_len_even = (align_x != 0) ? d_x >= d_y : d_x <= d_y;
+		ortho_len = 2 * std::min(d_x, d_y) - (int)is_len_even;
+		assert((int)ortho_len >= 0);
+		if (d_ns == 0 || d_we == 0) { // just single segment?
+			ortho_len++;
+		} else {
+			ortho_len2 = abs((int)d_x - (int)d_y) + (int)is_len_even;
+		}
+	}
+
+	/* length of booth segments of auto line (choosing diagonal direction first) */
+	uint diag_len = 0, diag_len2 = 0;
+	if (HasBit(start.dirs, diag_line_dir)) {
+		if (d_x == 0 || d_y == 0) { // just single segment?
+			diag_len = d_x + d_y;
+		} else {
+			diag_len = std::min(d_ns, d_we);
+			diag_len2 = d_x + d_y - diag_len;
+		}
+	}
+
+	/* choose the best variant */
+	if (ortho_len != 0 && diag_len != 0) {
+		/* in the first place, choose this line whose first segment ends up closer
+		 * to the mouse point (thus the second segment is shorter) */
+		int cmp = ortho_len2 - diag_len2;
+		/* if equal, choose the shorter line */
+		if (cmp == 0) cmp = ortho_len - diag_len;
+		/* finally look at small "units" and choose the line which is closer to the mouse point */
+		if (cmp == 0) cmp = std::min(abs(we), abs(ns)) - std::min(abs(x), abs(y));
+		/* based on comparison, disable one of variants */
+		if (cmp > 0) {
+			ortho_len = 0;
+		} else {
+			diag_len = 0;
+		}
+	}
+
+	/* store results */
+	if (ortho_len != 0) {
+		ret->first_dir = ortho_line_dir;
+		ret->first_len = ortho_len;
+		ret->second_dir = (ortho_len2 != 0) ? diag_line_dir : INVALID_DIR;
+		ret->second_len = ortho_len2;
+	} else if (diag_len != 0) {
+		ret->first_dir = diag_line_dir;
+		ret->first_len = diag_len;
+		ret->second_dir = (diag_len2 != 0) ? ortho_line_dir : INVALID_DIR;
+		ret->second_len = diag_len2;
+	} else {
+		return false;
+	}
+
+	ret->start = start;
+	return true;
+}
+
+/**
+ * Calculate squared euclidean distance between two points.
+ * @param a the first point
+ * @param b the second point
+ * @return |b - a| ^ 2
+ */
+static inline uint SqrDist(const Point &a, const Point &b)
+{
+	return (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
+}
+
+/**
+ * Find best matching pair of lines (polyline).
+ *
+ * @param pt          The end point (mouse cursor position) expressed in inner-tile world "units".
+ * @param snap_points Array of snapping points, the best one will be chosen.
+ * @param num_points  Length of the array.
+ * @param[out] ret    Coordinates of the polyline (if found).
+ * @return The chosen snapping point or NULL if no matching line was found.
+ */
+static LineSnapPoint *FindBestPolyline(const Point &pt, LineSnapPoint *snap_points, uint num_points, RailPolyline *ret)
+{
+	/* Find the best polyline (a pair of two lines - the white one and the blue
+	 * one) led from any of saved snap points to the mouse cursor. */
+
+	LineSnapPoint *best_snap_point = NULL; // the best polyline we found so far is led from this snap point
+
+	for (int i = 0; i < (int)num_points; i++) {
+		/* try to fit a polyline */
+		RailPolyline polyline;
+		if (!FindPolyline(pt, snap_points[i], &polyline)) continue; // skip non-matching snap points
+		/* check whether we've found a better polyline */
+		if (best_snap_point != NULL) {
+			/* firstly choose shorter polyline (the one with smaller amount of
+			 * track pieces composing booth the white and the blue line) */
+			uint cur_len = polyline.first_len + polyline.second_len;
+			uint best_len = ret->first_len + ret->second_len;
+			if (cur_len > best_len) continue;
+			/* secondly choose that polyline which has longer first (white) line */
+			if (cur_len == best_len && polyline.first_len < ret->first_len) continue;
+			/* finally check euclidean distance to snap points and choose the
+			 * one which is closer */
+			if (cur_len == best_len && polyline.first_len == ret->first_len && SqrDist(pt, snap_points[i]) >= SqrDist(pt, *best_snap_point)) continue;
+		}
+		/* save the found polyline */
+		*ret = polyline;
+		best_snap_point = &snap_points[i];
+	}
+
+	return best_snap_point;
+}
+
 /** while dragging */
 static void CalcRaildirsDrawstyle(int x, int y, int method)
 {
@@ -3101,32 +3444,89 @@ static void CalcRaildirsDrawstyle(int x, int y, int method)
 		}
 	}
 
-	if (_settings_client.gui.measure_tooltip) {
-		TileIndex t0 = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
-		TileIndex t1 = TileVirtXY(x, y);
-		uint distance = DistanceManhattan(t0, t1) + 1;
-		byte index = 0;
-		uint64 params[2];
+	_thd.selend.x = x;
+	_thd.selend.y = y;
+	_thd.dir2 = HT_DIR_END;
+	_thd.next_drawstyle = b;
 
-		if (distance != 1) {
-			int heightdiff = CalcHeightdiff(b, distance, t0, t1);
-			/* If we are showing a tooltip for horizontal or vertical drags,
-			 * 2 tiles have a length of 1. To bias towards the ceiling we add
-			 * one before division. It feels more natural to count 3 lengths as 2 */
-			if ((b & HT_DIR_MASK) != HT_DIR_X && (b & HT_DIR_MASK) != HT_DIR_Y) {
-				distance = CeilDiv(distance, 2);
-			}
+	ShowLengthMeasurement(b, TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y));
+}
 
-			params[index++] = distance;
-			if (heightdiff != 0) params[index++] = heightdiff;
-		}
+/**
+ * Calculate how tiles should be highlighted (polyline mode).
+ * @param pt       Current mouse cursor position expressed in inner-tile world "units".
+ * @param dragging Whether currently drag-dropping, in this case direction of rail track line is locked.
+ * @return New highlight style.
+ */
+static HighLightStyle CalcPolyrailDrawstyle(Point pt, bool dragging)
+{
+	RailSnapMode snap_mode = GetRailSnapMode();
 
-		ShowMeasurementTooltips(measure_strings_length[index], index, params);
+	/* are we only within one tile? */
+	if (snap_mode == RSM_SNAP_TO_TILE && GetRailSnapTile() == TileVirtXY(pt.x, pt.y)) {
+		_thd.selend.x = pt.x;
+		_thd.selend.y = pt.y;
+		return GetAutorailHT(pt.x, pt.y);
 	}
 
-	_thd.selend.x = x;
-	_thd.selend.y = y;
-	_thd.next_drawstyle = b;
+	/* find the best track */
+	RailPolyline line;
+
+	bool lock_snapping = dragging && snap_mode == RSM_SNAP_TO_RAIL;
+	if (!lock_snapping) _current_snap_lock.x = -1;
+
+	const LineSnapPoint *snap_point;
+	if (_current_snap_lock.x != -1) {
+		snap_point = FindBestPolyline(pt, &_current_snap_lock, 1, &line);
+	} else if (snap_mode == RSM_SNAP_TO_TILE) {
+		snap_point = FindBestPolyline(pt, _tile_snap_points.data(), _tile_snap_points.size(), &line);
+	} else {
+		assert(snap_mode == RSM_SNAP_TO_RAIL);
+		snap_point = FindBestPolyline(pt, _rail_snap_points.data(), _rail_snap_points.size(), &line);
+	}
+
+	if (snap_point == NULL) return HT_NONE; // no match
+
+	if (lock_snapping && _current_snap_lock.x == -1) {
+		/* lock down the snap point */
+		_current_snap_lock = *snap_point;
+		_current_snap_lock.dirs &= (1 << line.first_dir) | (1 << ReverseDir(line.first_dir));
+	}
+
+	TileIndexDiffC first_dir = TileIndexDiffCByDir(line.first_dir);
+	_thd.selstart.x  = line.start.x;
+	_thd.selstart.y  = line.start.y;
+	_thd.selend.x    = _thd.selstart.x + line.first_len * first_dir.x * (IsDiagonalDirection(line.first_dir) ? TILE_SIZE : TILE_SIZE / 2);
+	_thd.selend.y    = _thd.selstart.y + line.first_len * first_dir.y * (IsDiagonalDirection(line.first_dir) ? TILE_SIZE : TILE_SIZE / 2);
+	_thd.selstart2.x = _thd.selend.x;
+	_thd.selstart2.y = _thd.selend.y;
+	_thd.selstart.x  += first_dir.x;
+	_thd.selstart.y  += first_dir.y;
+	_thd.selend.x    -= first_dir.x;
+	_thd.selend.y    -= first_dir.y;
+	Trackdir seldir = PointDirToTrackdir(_thd.selstart, line.first_dir);
+	_thd.selstart.x  &= ~TILE_UNIT_MASK;
+	_thd.selstart.y  &= ~TILE_UNIT_MASK;
+
+	if (line.second_len != 0) {
+		TileIndexDiffC second_dir = TileIndexDiffCByDir(line.second_dir);
+		_thd.selend2.x   = _thd.selstart2.x + line.second_len * second_dir.x * (IsDiagonalDirection(line.second_dir) ? TILE_SIZE : TILE_SIZE / 2);
+		_thd.selend2.y   = _thd.selstart2.y + line.second_len * second_dir.y * (IsDiagonalDirection(line.second_dir) ? TILE_SIZE : TILE_SIZE / 2);
+		_thd.selstart2.x += second_dir.x;
+		_thd.selstart2.y += second_dir.y;
+		_thd.selend2.x   -= second_dir.x;
+		_thd.selend2.y   -= second_dir.y;
+		Trackdir seldir2 = PointDirToTrackdir(_thd.selstart2, line.second_dir);
+		_thd.selstart2.x &= ~TILE_UNIT_MASK;
+		_thd.selstart2.y &= ~TILE_UNIT_MASK;
+		_thd.dir2 = (HighLightStyle)TrackdirToTrack(seldir2);
+	} else {
+		_thd.dir2 = HT_DIR_END;
+	}
+
+	HighLightStyle ret = HT_LINE | (HighLightStyle)TrackdirToTrack(seldir);
+	ShowLengthMeasurement(ret, TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y), TCC_HOVER, true);
+	return ret;
 }
 
 /**
@@ -3146,6 +3546,12 @@ void VpSelectTilesWithMethod(int x, int y, ViewportPlaceMethod method)
 		return;
 	}
 
+	if ((_thd.place_mode & HT_POLY) && GetRailSnapMode() != RSM_NO_SNAP) {
+		Point pt = { x, y };
+		_thd.next_drawstyle = CalcPolyrailDrawstyle(pt, true);
+		return;
+	}
+
 	/* Special handling of drag in any (8-way) direction */
 	if (method & (VPM_RAILDIRS | VPM_SIGNALDIRS)) {
 		_thd.selend.x = x;
@@ -3198,28 +3604,54 @@ calc_heightdiff_single_direction:;
 				x = sx + Clamp(x - sx, -limit, limit);
 				y = sy + Clamp(y - sy, -limit, limit);
 			}
-			if (_settings_client.gui.measure_tooltip) {
-				TileIndex t0 = TileVirtXY(sx, sy);
-				TileIndex t1 = TileVirtXY(x, y);
-				uint distance = DistanceManhattan(t0, t1) + 1;
-				byte index = 0;
-				uint64 params[2];
-
-				if (distance != 1) {
-					/* With current code passing a HT_LINE style to calculate the height
-					 * difference is enough. However if/when a point-tool is created
-					 * with this method, function should be called with new_style (below)
-					 * instead of HT_LINE | style case HT_POINT is handled specially
-					 * new_style := (_thd.next_drawstyle & HT_RECT) ? HT_LINE | style : _thd.next_drawstyle; */
-					int heightdiff = CalcHeightdiff(HT_LINE | style, 0, t0, t1);
+			/* With current code passing a HT_LINE style to calculate the height
+			 * difference is enough. However if/when a point-tool is created
+			 * with this method, function should be called with new_style (below)
+			 * instead of HT_LINE | style case HT_POINT is handled specially
+			 * new_style := (_thd.next_drawstyle & HT_RECT) ? HT_LINE | style : _thd.next_drawstyle; */
+			ShowLengthMeasurement(HT_LINE | style, TileVirtXY(sx, sy), TileVirtXY(x, y));
+			break;
 
-					params[index++] = distance;
-					if (heightdiff != 0) params[index++] = heightdiff;
+	case VPM_A_B_LINE: { // drag an A to B line
+			TileIndex t0 = TileVirtXY(sx, sy);
+			TileIndex t1 = TileVirtXY(x, y);
+			uint dx = Delta(TileX(t0), TileX(t1)) + 1;
+			uint dy = Delta(TileY(t0), TileY(t1)) + 1;
+			byte index = 0;
+			uint64 params[5];
+			memset( params, 0, sizeof( params ) );
+
+			/* If dragging an area (eg dynamite tool) and it is actually a single
+			 * row/column, change the type to 'line' to get proper calculation for height */
+			style = (HighLightStyle)_thd.next_drawstyle;
+			if (style & HT_RECT) {
+				if (dx == 1) {
+					style = HT_LINE | HT_DIR_Y;
+				} else if (dy == 1) {
+					style = HT_LINE | HT_DIR_X;
 				}
+			}
 
-				ShowMeasurementTooltips(measure_strings_length[index], index, params);
+			int heightdiff = 0;
+
+			if (dx != 1 || dy != 1) {
+				heightdiff = CalcHeightdiff(style, 0, t0, t1);
+				params[index++] = DistanceManhattan(t0, t1);
+				params[index++] = sqrtl(dx * dx + dy * dy); //DistanceSquare does not like big numbers
+
+			} else {
+				index += 2;
 			}
+
+			params[index++] = DistanceFromEdge(t1);
+			//params[index++] = GetTileMaxZ(t1) / TILE_HEIGHT * TILE_HEIGHT_STEP; //changed ^^
+			params[index++] = GetTileMaxZ(t1) * TILE_HEIGHT_STEP;
+			params[index++] = heightdiff;
+			//Show always the measurement tooltip
+			//GuiShowTooltips(_thd.GetCallbackWnd(),STR_MEASURE_DIST_HEIGHTDIFF, index, params, TCC_LEFT_CLICK);
+			GuiShowTooltips(_thd.GetCallbackWnd(),STR_MEASURE_DIST_HEIGHTDIFF, index, params, TCC_NONE);
 			break;
+		}
 
 		case VPM_X_AND_Y_LIMITED: // Drag an X by Y constrained rect area.
 			limit = (_thd.sizelimit - 1) * TILE_SIZE;
@@ -3297,6 +3729,7 @@ calc_heightdiff_single_direction:;
 
 	_thd.selend.x = x;
 	_thd.selend.y = y;
+	_thd.dir2 = HT_DIR_END;
 }
 
 /**
@@ -3338,7 +3771,7 @@ EventState VpHandlePlaceSizingDrag()
 	} else if (_thd.select_method & VPM_SIGNALDIRS) {
 		_thd.place_mode = HT_RECT | others;
 	} else if (_thd.select_method & VPM_RAILDIRS) {
-		_thd.place_mode = (_thd.select_method & ~VPM_RAILDIRS) ? _thd.next_drawstyle : (HT_RAIL | others);
+		_thd.place_mode = (_thd.select_method & ~VPM_RAILDIRS ? _thd.next_drawstyle : HT_RAIL) | others;
 	} else {
 		_thd.place_mode = HT_POINT | others;
 	}
@@ -3557,3 +3990,208 @@ void SetViewportCatchmentTown(const Town *t, bool sel)
 	}
 	if (_viewport_highlight_town != nullptr) SetWindowDirty(WC_TOWN_VIEW, _viewport_highlight_town->index);
 }
+
+/**
+ * Construct a rail snapping point based on a spot where a rail tracks segment
+ * has been placed.
+ *
+ * The snapping point will allow to stick new segment of tracks to the line that
+ * was placed before.
+ *
+ * @param tile Tile where the placed segment ended.
+ * @param exit_dir Tile side at which the segment ended.
+ * @param bidirectional Whether to allow to reverse at this point
+ *        (e.g. reversing after a bridges/tunnels is undesired).
+ * @param extended If not \c NULL, the snapping point will be extended over
+ *        a bridge/tunnel/station etc. if the last placed segment touches such
+ *        an object. Additional snapping point may be stored under \a extended
+ *        if needed, otherwise it will be set to { -1, -1, 0 }.
+ * @return New rail snapping point.
+ */
+static LineSnapPoint LineSnapPointAtRailTrackEndpoint(TileIndex tile, DiagDirection exit_dir, bool bidirectional, LineSnapPoint *extended)
+{
+	LineSnapPoint ret;
+	ret.x = (TILE_SIZE / 2) * (uint)(2 * TileX(tile) + TileIndexDiffCByDiagDir(exit_dir).x + 1);
+	ret.y = (TILE_SIZE / 2) * (uint)(2 * TileY(tile) + TileIndexDiffCByDiagDir(exit_dir).y + 1);
+	ret.dirs = 0;
+	if (extended != NULL) {
+		extended->x = -1;
+		extended->y = -1;
+		extended->dirs = 0;
+	}
+
+	/* Check whether to extend the snap point over a tunnel/bridge/station etc. */
+	tile = TileAddByDiagDir(tile, exit_dir);
+	if (extended != NULL && !IsTileType(tile, MP_RAILWAY) && !IsTileType(tile, MP_ROAD) &&
+			TrackStatusToTrackBits(GetTileTrackStatus(tile, TRANSPORT_RAIL, INVALID_DIAGDIR)) == AxisToTrackBits(DiagDirToAxis(exit_dir)) &&
+			IsTileOwner(tile, _local_company)) {
+		/* Check if this is a tunnel/bridge and move the tile to the other end if so. */
+		if (IsTileType(tile, MP_TUNNELBRIDGE)) tile = GetOtherTunnelBridgeEnd(tile);
+		LineSnapPoint ex = LineSnapPointAtRailTrackEndpoint(tile, exit_dir, false, extended);
+		if (!bidirectional) return ex; // if we are interested in forward direction only then return just the extended point
+		*extended = ex; // otherwise return two points, extended with forward direction and base with reverse direction
+	} else {
+		/* Add forward direction. */
+		SetBit(ret.dirs, DiagDirToDir(exit_dir));
+	}
+
+	/* Add reverse direction. */
+	if (bidirectional) SetBit(ret.dirs, ReverseDir(DiagDirToDir(exit_dir)));
+
+	/* Add 45 degree rotated directions. */
+	ret.dirs |= ROR<uint8>(ret.dirs, DIRDIFF_45LEFT);
+	ret.dirs |= ROR<uint8>(ret.dirs, DIRDIFF_45RIGHT);
+	return ret;
+}
+
+/**
+ * Store the position of lastly built rail track; for highlighting purposes.
+ *
+ * In "polyline" highlighting mode, the stored end point will be used as a snapping point for new
+ * tracks allowing to place multi-segment polylines.
+ *
+ * @param start_tile         tile where the track starts
+ * @param end_tile           tile where the track ends
+ * @param start_track        track piece on the start_tile
+ * @param bidirectional_exit whether to allow to highlight next track in any direction; otherwise new track will have to fallow the stored one (usefull when placing tunnels and bridges)
+ */
+void StoreRailPlacementEndpoints(TileIndex start_tile, TileIndex end_tile, Track start_track, bool bidirectional_exit)
+{
+	if (start_tile != INVALID_TILE && end_tile != INVALID_TILE) {
+		/* calculate trackdirs at booth ends of the track */
+		Trackdir exit_trackdir_at_start = TrackToTrackdir(start_track);
+		Trackdir exit_trackdir_at_end = ReverseTrackdir(TrackToTrackdir(start_track));
+		if (start_tile != end_tile) { // multi-tile case
+			/* determine proper direction (pointing outside of the track) */
+			uint distance = DistanceManhattan(start_tile, end_tile);
+			if (distance > DistanceManhattan(TileAddByDiagDir(start_tile, TrackdirToExitdir(exit_trackdir_at_start)), end_tile)) {
+				Swap(exit_trackdir_at_start, exit_trackdir_at_end);
+			}
+			/* determine proper track on the end tile - switch between upper/lower or left/right based on the length */
+			if (distance % 2 != 0) exit_trackdir_at_end = NextTrackdir(exit_trackdir_at_end);
+		}
+
+		LineSnapPoint snap_start, snap_start_ex, snap_end, snap_end_ex;
+		snap_start = LineSnapPointAtRailTrackEndpoint(start_tile, TrackdirToExitdir(exit_trackdir_at_start), bidirectional_exit, &snap_start_ex);
+		snap_end = LineSnapPointAtRailTrackEndpoint(end_tile, TrackdirToExitdir(exit_trackdir_at_end), bidirectional_exit, &snap_end_ex);
+		/* Find if we already had these coordinates before. */
+		bool had_start = false;
+		bool had_end = false;
+		for (auto &snap: _rail_snap_points) {
+			had_start |= (snap.x == snap_start.x && snap.y == snap_start.y);
+			had_end |= (snap.x == snap_end.x && snap.y == snap_end.y);
+		}
+		/* Create new snap point set. */
+		if (had_start && had_end) {
+			/* just stop snapping, don't forget snap points */
+			SetRailSnapMode(RSM_NO_SNAP);
+		} else {
+			/* include only new points */
+			_rail_snap_points.clear();
+			if (!had_start) {
+				_rail_snap_points.push_back(snap_start);
+				if (snap_start_ex.dirs != 0) _rail_snap_points.push_back(snap_start_ex);
+			}
+			if (!had_end) {
+				_rail_snap_points.push_back(snap_end);
+				if (snap_end_ex.dirs != 0) _rail_snap_points.push_back(snap_end_ex);
+			}
+			SetRailSnapMode(RSM_SNAP_TO_RAIL);
+		}
+	}
+}
+
+/**
+ * Store the position of lastly built rail station; for highlighting purposes.
+ *
+ * In "polyline" highlighting mode, the stored end points will be used as snapping points for new tracks.
+ *
+ * @param ta           Station area.
+ * @param station_axis Station axis.
+ */
+void StoreRailStationPlacementEndpoints(const TileArea &ta, Axis station_axis)
+{
+	uint start_x = TileX(ta.tile);
+	uint start_y = TileY(ta.tile);
+	uint end_x = start_x + ta.w - 1;
+	uint end_y = start_y + ta.h - 1;
+
+	_rail_snap_points.clear();
+	if (station_axis == AXIS_X) {
+		for (uint y = start_y; y <= end_y; y++) {
+			_rail_snap_points.push_back(LineSnapPointAtRailTrackEndpoint(TileXY(start_x, y), DIAGDIR_NE, false, NULL));
+			_rail_snap_points.push_back(LineSnapPointAtRailTrackEndpoint(TileXY(end_x, y), DIAGDIR_SW, false, NULL));
+		}
+	} else {
+		for (uint x = start_x; x <= end_x; x++) {
+			_rail_snap_points.push_back(LineSnapPointAtRailTrackEndpoint(TileXY(x, start_y), DIAGDIR_NW, false, NULL));
+			_rail_snap_points.push_back(LineSnapPointAtRailTrackEndpoint(TileXY(x, end_y), DIAGDIR_SE, false, NULL));
+		}
+	}
+}
+
+/**
+ * Get current rail track snapping mode.
+ * @return Current snapping mode.
+ *
+ * @note This function will return #RSM_NO_SNAP if there are no snapping points
+ *       set (yet), even thought the snapping was set to some different mode.
+ */
+RailSnapMode GetRailSnapMode()
+{
+	if (_rail_snap_mode == RSM_SNAP_TO_TILE && _tile_snap_points.empty()) return RSM_NO_SNAP;
+	if (_rail_snap_mode == RSM_SNAP_TO_RAIL && _rail_snap_points.empty()) return RSM_NO_SNAP;
+	return _rail_snap_mode;
+}
+
+/**
+ * Set current current rail track snapping mode.
+ * @param mode New snapping mode.
+ */
+void SetRailSnapMode(RailSnapMode mode)
+{
+	_rail_snap_mode = mode;
+
+	if ((_thd.place_mode & HT_POLY) && (GetRailSnapMode() == RSM_NO_SNAP)) {
+		SetTileSelectSize(1, 1);
+	}
+}
+
+/**
+ * Get the tile that is set to be a snapping point for rail tracks (used when
+ * #RSM_SNAP_TO_TILE mode is active).
+ *
+ * @return The tile.
+ */
+static TileIndex GetRailSnapTile()
+{
+	if (_tile_snap_points.empty()) return INVALID_TILE;
+	return TileVirtXY(_tile_snap_points[DIAGDIR_NE].x, _tile_snap_points[DIAGDIR_NE].y);
+}
+
+/**
+ * Set the tile that is meant to be a snapping point for rail tracks (used when
+ * #RSM_SNAP_TO_TILE mode is active).
+ *
+ * @param tile The tile.
+ */
+static void SetRailSnapTile(TileIndex tile)
+{
+	_tile_snap_points.clear();
+	if (tile == INVALID_TILE) return;
+
+	for (DiagDirection dir = DIAGDIR_BEGIN; dir < DIAGDIR_END; dir++) {
+		auto point = LineSnapPointAtRailTrackEndpoint(tile, dir, false, NULL);
+		point.dirs = ROR<uint8>(point.dirs, DIRDIFF_REVERSE);
+		_tile_snap_points.push_back(point);
+	}
+}
+
+/** Clear all stored rail snapping points and reset the snapping mode. */
+void ResetRailPlacementEndpoints()
+{
+	_rail_snap_mode = RSM_NO_SNAP;
+	_tile_snap_points.clear();
+	_rail_snap_points.clear();
+	_current_snap_lock.x = -1;
+}
diff --git a/src/viewport_func.h b/src/viewport_func.h
index e60df4d31..a67323cb3 100644
--- a/src/viewport_func.h
+++ b/src/viewport_func.h
@@ -58,7 +58,7 @@ void ViewportAddString(const DrawPixelInfo *dpi, ZoomLevel small_from, const Vie
 void StartSpriteCombine();
 void EndSpriteCombine();
 
-bool HandleViewportClicked(const Viewport *vp, int x, int y);
+bool HandleViewportClicked(const Viewport *vp, int x, int y, bool double_click);
 void SetRedErrorSquare(TileIndex tile);
 void SetTileSelectSize(int w, int h);
 void SetTileSelectBigSize(int ox, int oy, int sx, int sy);
diff --git a/src/viewport_gui.cpp b/src/viewport_gui.cpp
index 5047f04f3..57a64a10e 100644
--- a/src/viewport_gui.cpp
+++ b/src/viewport_gui.cpp
@@ -14,6 +14,12 @@
 #include "strings_func.h"
 #include "zoom_func.h"
 #include "window_func.h"
+#include "gfx_func.h"
+#include "industry.h"
+#include "town_map.h"
+#include "station_gui.h"
+#include "station_base.h"
+#include "cargotype.h"
 
 #include "widgets/viewport_widget.h"
 
@@ -152,6 +158,97 @@ public:
 		/* Only handle zoom message if intended for us (msg ZOOM_IN/ZOOM_OUT) */
 		HandleZoomMessage(this, this->viewport, WID_EV_ZOOM_IN, WID_EV_ZOOM_OUT);
 	}
+
+	virtual void OnMouseOver(Point pt, int widget)
+	{
+		/* Show tooltip with last month production or town name */
+		if (pt.x != -1 && _settings_client.gui.enable_extra_tooltips) {
+			GuiPrepareTooltipsExtra(this);
+		} else if (pt.x != -1) {
+			TileIndex tile;
+			const bool viewport_is_in_map_mode = (this->viewport->zoom > ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_DRAW_MAP);
+			if (viewport_is_in_map_mode) {
+				// Disabled, for now :)
+				/*NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(WID_EV_VIEWPORT);
+				const int a = ((ScaleByZoom(pt.x - nvp->pos_x, this->viewport->zoom) + this->viewport->virtual_left) >> 2) / ZOOM_LVL_BASE;
+				const int b = ((ScaleByZoom(pt.y - nvp->pos_y, this->viewport->zoom) + this->viewport->virtual_top) >> 1) / ZOOM_LVL_BASE;
+				tile = TileVirtXY(b - a, b + a);*/
+			} else {
+				const Point p = GetTileBelowCursor();
+				tile = TileVirtXY(p.x, p.y);
+			}
+			if (tile >= MapSize()) return;
+
+			switch (GetTileType(tile)) {
+				case MP_ROAD:
+					if (IsRoadDepot(tile)) return;
+					/* FALL THROUGH */
+				case MP_HOUSE: {
+					if (HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return; // No need for a town name tooltip when it is already displayed
+					if (!viewport_is_in_map_mode) return;
+					const TownID tid = GetTownIndex(tile);
+					if (!tid) return;
+					SetDParam(0, tid);
+					GuiShowTooltips(this, STR_TOWN_NAME_TOOLTIP, 0, NULL, TCC_HOVER);
+					break;
+				}
+				case MP_INDUSTRY: {
+					const Industry *ind = Industry::GetByTile(tile);
+					const IndustrySpec *indsp = GetIndustrySpec(ind->type);
+
+					StringID str = STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP;
+					uint prm_count = 0;
+					SetDParam(prm_count++, indsp->name);
+					for (byte i = 0; i < lengthof(ind->produced_cargo); i++) {
+						if (ind->produced_cargo[i] != CT_INVALID) {
+							SetDParam(prm_count++, ind->produced_cargo[i]);
+							SetDParam(prm_count++, ind->last_month_production[i]);
+							SetDParam(prm_count++, ToPercent8(ind->last_month_pct_transported[i]));
+							str++;
+						}
+					}
+					if (prm_count <= 19) {
+						GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+					}
+					break;
+				}
+				case MP_STATION: {
+					if (!IsRailWaypoint(tile)) {
+						if (!HasTileWaterGround(tile)) {
+							const Station *st = Station::GetByTile(tile);
+							StringID str = STR_STATION_VIEW_TRANSPORTED_TOOLTIP;
+							uint prm_count = 0;
+							SetDParam(prm_count++, st->index);
+							for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+								//const CargoSpec *cs = CargoSpec::Get(i);
+								if(cs == NULL) continue;
+								int cargoid = cs->Index();
+								//if (HasBit(st->goods[i].status,GoodsEntry::GES_RATING)) {
+								if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+									SetDParam(prm_count++, cs->Index());
+									SetDParam(prm_count++, st->goods[cargoid].cargo.TotalCount());
+									SetDParam(prm_count++, ToPercent8(st->goods[cargoid].rating));
+									str++;
+									if (prm_count == 19) {
+										str++;
+										break;
+									}
+								}
+							}
+							if (prm_count <= 19) {
+								GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+							}
+						}
+					}
+					break;
+				}
+				default:
+					return;
+			}
+		}
+	}
 };
 
 static WindowDesc _extra_viewport_desc(
diff --git a/src/viewport_type.h b/src/viewport_type.h
index 6665af19e..8f9e49c41 100644
--- a/src/viewport_type.h
+++ b/src/viewport_type.h
@@ -13,6 +13,7 @@
 #include "zoom_type.h"
 #include "strings_type.h"
 #include "table/strings.h"
+#include "math.h"
 
 class LinkGraphOverlay;
 
@@ -103,6 +104,7 @@ enum ViewportPlaceMethod {
 	VPM_FIX_VERTICAL    =    6, ///< drag only in vertical direction
 	VPM_X_LIMITED       =    7, ///< Drag only in X axis with limited size
 	VPM_Y_LIMITED       =    8, ///< Drag only in Y axis with limited size
+	VPM_A_B_LINE        =    9, ///< Drag a line from tile A to tile B
 	VPM_RAILDIRS        = 0x40, ///< all rail directions
 	VPM_SIGNALDIRS      = 0x80, ///< similar to VMP_RAILDIRS, but with different cursor
 };
@@ -123,6 +125,7 @@ enum ViewportDragDropSelectionProcess {
 	DDSP_CREATE_RIVER,         ///< Create rivers
 	DDSP_PLANT_TREES,          ///< Plant trees
 	DDSP_BUILD_BRIDGE,         ///< Bridge placement
+	DDSP_MEASURE,              ///< Measurement tool
 
 	/* Rail specific actions */
 	DDSP_PLACE_RAIL,           ///< Rail placement
diff --git a/src/watch_gui_1.cpp b/src/watch_gui_1.cpp
new file mode 100644
index 000000000..b6797bc2c
--- /dev/null
+++ b/src/watch_gui_1.cpp
@@ -0,0 +1,525 @@
+/* $Id: watch_gui.cpp  17678 2009-10-07 20:54:05  muxy $ */
+
+/** @file watch_gui.cpp GUI that follow other company building. */
+
+#include "stdafx.h"
+#include "watch_gui_1.h"
+#include "widget_type.h"
+#include "gfx_type.h"
+#include "gfx_func.h"
+#include "company_base.h"
+#include "company_gui.h"
+#include "viewport_func.h"
+#include "window_func.h"
+#include "strings_func.h"
+#include "zoom_func.h"
+#include "map_func.h"
+#include "base64.h"
+#include "error.h"
+
+#include "industry.h"
+#include "town_map.h"
+#include "station_gui.h"
+#include "station_base.h"
+#include "cargotype.h"
+#include "widgets/viewport_widget.h"
+
+#include "network/network.h"
+#include "network/network_func.h"
+#include "network/network_base.h"
+#include "network/network_gui.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+#include "safeguards.h"
+
+/** Make the widgets columns for company button, has_client and activity Blot.
+ * @param biggest_index Storage for collecting the biggest index used in the returned tree.
+ * @return Horizontal container with butons columns.
+ * @post \c *biggest_index contains the largest used index in the tree.
+ */
+static NWidgetBase *MakeCompanyButtons(int *biggest_index)
+{
+	NWidgetHorizontal *widget_container_horiz = NULL;         // Storage for all cols.
+	NWidgetVertical *widget_container_company_number = NULL;         // Storage for company number.
+	NWidgetVertical *widget_container_company = NULL;         // Storage for company Col.
+	NWidgetVertical *widget_container_hasclient = NULL;       // Storage for Has Client Blot.
+	NWidgetVertical *widget_container_activity = NULL;        // Storage for Activity Blot.
+	//NWidgetVertical *widget_container_action1 = NULL;         // Storage for Action 1
+
+	widget_container_horiz = new NWidgetHorizontal( );
+	widget_container_company_number = new NWidgetVertical( );
+	widget_container_company = new NWidgetVertical( );
+	widget_container_hasclient  = new NWidgetVertical( );
+	widget_container_activity = new NWidgetVertical( );
+	//widget_container_action1 = new NWidgetVertical( );
+
+	Dimension company_sprite_size = GetSpriteSize( SPR_COMPANY_ICON );
+	company_sprite_size.width  += WD_MATRIX_LEFT + WD_MATRIX_RIGHT;
+	company_sprite_size.height += WD_MATRIX_TOP + WD_MATRIX_BOTTOM + 1; // 1 for the 'offset' of being pressed
+
+	Dimension blot_sprite_size = GetSpriteSize( SPR_BLOT );
+	blot_sprite_size.width  += WD_MATRIX_LEFT + WD_MATRIX_RIGHT;
+	blot_sprite_size.height += WD_MATRIX_TOP + WD_MATRIX_BOTTOM + 1; // 1 for the 'offset' of being pressed
+
+
+	for (int company_num = COMPANY_FIRST; company_num < MAX_COMPANIES; company_num++ ) {
+
+		/* Manage Company Buttons */
+		NWidgetBackground *company_panel = new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_PB_COMPANY_FIRST1 + company_num );
+		company_panel->SetMinimalSize( company_sprite_size.width, company_sprite_size.height );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		company_panel->SetDataTip( 0x0, STR_WATCH_CLICK_TO_WATCH_COMPANY );
+		widget_container_company->Add( company_panel );
+
+		/* Manage Company Number Buttons */
+		NWidgetBackground *company_number_panel = new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_PB_COMPANY_NUMBER_FIRST1 + company_num );
+		//company_number_panel->SetMinimalSize( blot_sprite_size.width, blot_sprite_size.height );
+		company_panel->SetMinimalSize( blot_sprite_size.width, blot_sprite_size.height );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		company_number_panel->SetDataTip( 0x0, STR_WATCH_CLICK_TO_OPEN_COMPANY );
+		widget_container_company_number->Add( company_number_panel );
+
+		/* Manage Has Client Blot */
+		NWidgetBackground *hasclient_panel = new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_HAS_CLIENT_FIRST1 + company_num );
+		company_panel->SetMinimalSize( blot_sprite_size.width, blot_sprite_size.height );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		widget_container_hasclient->Add( hasclient_panel );
+	}
+
+	/* Add the verticals widgets to the horizontal container */
+	widget_container_horiz->Add( widget_container_company_number );
+	widget_container_horiz->Add( widget_container_company );
+	widget_container_horiz->Add( widget_container_hasclient );
+
+	/* return the horizontal widget container */
+	return widget_container_horiz;
+}
+
+
+/**
+ * Watch Company Window Widgets Array
+ * The Company Button, Has Client Blot and Activity Blot Columns
+ * Are made through a function regarding MAX_COMPANIES value
+ */
+static const NWidgetPart _nested_watch_company_widgets1[] = {
+	/* Title Bar with close box, title, shade and stick boxes */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, EWW_CAPTION1 ), SetDataTip(STR_WATCH_WINDOW_TITLE2, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_DEFSIZEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer( ),
+	NWidget( NWID_HORIZONTAL ),
+		NWidget( NWID_VERTICAL ),
+			NWidgetFunction( MakeCompanyButtons ),
+			/* Buton Zoom Out, In, Scrollto */
+			NWidget(NWID_HORIZONTAL),
+				NWidget( WWT_PUSHIMGBTN, COLOUR_GREY, EWW_ZOOMOUT1 ), SetDataTip( SPR_IMG_ZOOMOUT, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_OUT),
+				NWidget( WWT_PUSHIMGBTN, COLOUR_GREY, EWW_ZOOMIN1 ),  SetDataTip( SPR_IMG_ZOOMIN, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_IN),
+				NWidget( WWT_PUSHIMGBTN, COLOUR_GREY, EWW_CENTER1 ),  SetDataTip( SPR_CENTRE_VIEW_VEHICLE, STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW_TT),
+				NWidget( WWT_PANEL, COLOUR_GREY, EWW_NEW_WINDOW1 ),   SetDataTip( 0, STR_WATCH_CLICK_NEW_WINDOW ), EndContainer( ),
+			EndContainer( ),
+			/* Background panel for resize purpose */
+			NWidget( WWT_PANEL, COLOUR_GREY ), SetResize( 0, 1 ), EndContainer( ),
+		EndContainer( ),
+		/* Watch Pannel */
+		NWidget(WWT_PANEL, COLOUR_GREY),
+			NWidget(NWID_VIEWPORT, INVALID_COLOUR, EWW_WATCH1), SetPadding(2, 2, 2, 2), SetResize(1, 1), SetFill(1, 1),
+		EndContainer( ),
+	EndContainer( ),
+	/* Status Bar with resize buton */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY), SetFill(1, 1), SetResize(1, 0), EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer( ),
+};
+
+/**
+ * Watch Company Window Descriptor
+ */
+static WindowDesc _watch_company_desc(
+	WDP_AUTO, "watch_company", 330, 257,
+	WC_WATCH_COMPANY1, WC_NONE,
+	0,
+	_nested_watch_company_widgets1, lengthof( _nested_watch_company_widgets1 )
+);
+
+//static int WatchCompany::button1_state[MAX_COMPANIES];
+
+/** Watch Company Class Constructor
+ * @param desc Window Descriptor The Window Descriptor
+ * @param window_number The window number for the class
+ * @param company_to_watch Company ID for watching a particular company
+ */
+WatchCompany1::WatchCompany1(WindowDesc *desc, int window_number, CompanyID company_to_watch = INVALID_COMPANY ) : Window(desc)
+{
+	this->watched_company = company_to_watch;
+
+	this->InitNested(window_number);
+	this->owner = this->watched_company;
+
+	/* Reset activity and client count for all companies */
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		this->company_activity[i] = 0;
+		this->company_count_client[i] = 0;
+	}
+
+	GetString( this->company_name, STR_JUST_NOTHING, lastof(this->company_name) );
+
+	/* Init the viewport area */
+	NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(EWW_WATCH1);
+	//nvp->InitializeViewport(this, 0, ZOOM_LVL_NORMAL);
+	nvp->InitializeViewport(this, 0, ZOOM_LVL_OUT_8X);
+
+	Point pt;
+	/* the main window with the main view */
+	const Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+
+	/* center on same place as main window (zoom is maximum, no adjustment needed) */
+	pt.x = w->viewport->scrollpos_x + w->viewport->virtual_width / 2;
+	pt.y = w->viewport->scrollpos_y + w->viewport->virtual_height / 2;
+
+	this->viewport->scrollpos_x = pt.x - this->viewport->virtual_width / 2;
+	this->viewport->scrollpos_y = pt.y - this->viewport->virtual_height / 2;
+	this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
+	this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
+
+	if ( this->watched_company != INVALID_COMPANY ) {
+		Company *c = Company::Get( this->watched_company );
+		this->ScrollToTile( c->last_build_coordinate );
+	}
+	this->InvalidateData( );
+}
+
+void WatchCompany1::SetStringParameters(int widget) const
+{
+	switch (widget) {
+		case EWW_CAPTION1:
+			SetDParamStr( 0, this->company_name );
+			SetDParam( 1, this->watched_company + 1 );
+			break;
+	}
+}
+
+void WatchCompany1::DrawWidget(const Rect &r, int widget) const
+{
+	/* draw the widget */
+	/* Company Number Button */
+	if (IsInsideMM(widget, EWW_PB_COMPANY_NUMBER_FIRST1, EWW_PB_COMPANY_NUMBER_LAST1 + 1)) {
+		if (this->IsWidgetDisabled(widget)) return;
+		if ( Company::IsValidID( widget - EWW_PB_COMPANY_NUMBER_FIRST1 ) ) {
+				CompanyID cid = (CompanyID)(widget - ( EWW_PB_COMPANY_NUMBER_FIRST1 ) );
+				Dimension sprite_size = GetSpriteSize(SPR_BLOT);
+				SetDParam(0, widget);
+				DrawString(r.left, r.right, (r.top + r.bottom - sprite_size.height) / 2, STR_WATCH_CLICK_TO_WATCH_COMPANY_NUMBER, TC_FROMSTRING, SA_CENTER);
+		}
+		return;
+	}
+	/* Company Button */
+	if (IsInsideMM(widget, EWW_PB_COMPANY_FIRST1, EWW_PB_COMPANY_LAST1 + 1)) {
+		if (this->IsWidgetDisabled(widget)) return;
+		if ( Company::IsValidID( widget - EWW_PB_COMPANY_FIRST1 ) ) {
+				CompanyID cid = (CompanyID)(widget - ( EWW_PB_COMPANY_FIRST1 ) );
+				int offset = (cid == this->watched_company) ? 1 : 0;
+				Dimension sprite_size = GetSpriteSize(SPR_COMPANY_ICON);
+				DrawCompanyIcon(cid, (r.left + r.right - sprite_size.width) / 2 + offset, (r.top + r.bottom - sprite_size.height) / 2 + offset);
+		}
+		return;
+	}
+	/* Has Client Blot */
+	if (IsInsideMM( widget, EWW_HAS_CLIENT_FIRST1, EWW_HAS_CLIENT_LAST1 + 1 )) {
+		if ( Company::IsValidID( widget-EWW_HAS_CLIENT_FIRST1 ) ) {
+			/* Draw the Blot only if Company Exists */
+			Dimension sprite_size = GetSpriteSize(SPR_BLOT);
+			if (!_networking) { // Local game, draw the Blot
+				DrawSprite(SPR_BLOT, Company::IsValidAiID(widget-EWW_HAS_CLIENT_FIRST1)?PALETTE_TO_ORANGE:PALETTE_TO_GREEN, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2 );
+			} else { // Network game, draw the blot according to company client count
+				DrawSprite(SPR_BLOT, this->company_count_client[widget-EWW_HAS_CLIENT_FIRST1]>0?(company_activity[widget-EWW_HAS_CLIENT_FIRST1]>0?PALETTE_TO_RED:PALETTE_TO_GREEN):PALETTE_TO_GREY, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2 );
+			}
+		}
+	}
+}
+
+void WatchCompany1::OnResize()
+{
+	if (this->viewport != NULL) {
+		NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(EWW_WATCH1);
+		nvp->UpdateViewportCoordinates(this);
+	}
+}
+
+void WatchCompany1::OnScroll(Point delta)
+{
+	const Viewport *vp = IsPtInWindowViewport(this, _cursor.pos.x, _cursor.pos.y);
+	if (vp == NULL) return;
+
+	this->viewport->scrollpos_x += ScaleByZoom(delta.x, vp->zoom);
+	this->viewport->scrollpos_y += ScaleByZoom(delta.y, vp->zoom);
+	this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
+	this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
+}
+
+void WatchCompany1::OnMouseWheel( int wheel )
+{
+	ZoomInOrOutToCursorWindow(wheel < 0, this);
+}
+
+void WatchCompany1::OnClick(Point pt, int widget, int click_count)
+{
+	if (IsInsideMM(widget, EWW_PB_COMPANY_FIRST1, EWW_PB_COMPANY_LAST1 + 1)) {
+		/* Click on Company Button */
+		if (!this->IsWidgetDisabled(widget)) {
+			if (this->watched_company != INVALID_COMPANY) {
+				/* Raise the watched company button  */
+				this->RaiseWidget(this->watched_company + EWW_PB_COMPANY_FIRST1);
+			}
+			if (this->watched_company == (CompanyID)(widget - EWW_PB_COMPANY_FIRST1)) {
+				/* Stop watching watched_company */
+				this->watched_company = INVALID_COMPANY;
+				GetString( this->company_name, STR_JUST_NOTHING, lastof(this->company_name) );
+			} else {
+				/* Lower the new watched company button */
+				this->watched_company = (CompanyID)(widget - EWW_PB_COMPANY_FIRST1);
+				this->LowerWidget(this->watched_company + EWW_PB_COMPANY_FIRST1);
+				Company *c = Company::Get( this->watched_company );
+				SetDParam( 0, c->index );
+				GetString( this->company_name, STR_COMPANY_NAME, lastof(this->company_name) );
+
+				this->ScrollToTile( c->last_build_coordinate );
+			}
+			this->owner = this->watched_company;
+			this->SetDirty();
+		}
+	} else if ( IsInsideMM(widget, EWW_PB_ACTION1_FIRST1, EWW_PB_ACTION1_LAST1 + 1)) {
+		if ( !this->IsWidgetDisabled(widget) ) {
+			this->ToggleWidgetLoweredState( widget );
+			this->SetDirty();
+		}
+	} // Handle when clicking on company numbers to open Company window
+		else if (IsInsideMM(widget, EWW_PB_COMPANY_NUMBER_FIRST1, EWW_PB_COMPANY_NUMBER_LAST1 + 1)) {
+			if (!this->IsWidgetDisabled(widget)) {
+				this->watched_company_window = (CompanyID)(widget - EWW_PB_COMPANY_NUMBER_FIRST1);
+				ShowCompany(this->watched_company_window);
+			}
+			////////////////////
+		}
+	else if ( IsInsideMM(widget, EWW_HAS_CLIENT_FIRST1, EWW_HAS_CLIENT_LAST1 + 1)) {
+		if(_networking && Company::IsValidID(widget - EWW_HAS_CLIENT_FIRST1)){
+			ShowNetworkChatQueryWindow(DESTTYPE_TEAM, widget - EWW_HAS_CLIENT_FIRST1);
+		}
+	}
+	else {
+		switch (widget) {
+			case EWW_ZOOMOUT1: DoZoomInOutWindow(ZOOM_OUT, this); break;
+			case EWW_ZOOMIN1: DoZoomInOutWindow(ZOOM_IN,  this); break;
+
+			case EWW_CENTER1: { // location button (move main view to same spot as this view) 'Center Main View'
+				Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+				int x = this->viewport->scrollpos_x; // Where is the watch looking at
+				int y = this->viewport->scrollpos_y;
+
+				/* set the main view to same location. Based on the center, adjusting for zoom */
+				w->viewport->dest_scrollpos_x =  x - (w->viewport->virtual_width -  this->viewport->virtual_width) / 2;
+				w->viewport->dest_scrollpos_y =  y - (w->viewport->virtual_height - this->viewport->virtual_height) / 2;
+			} break;
+
+			case EWW_NEW_WINDOW1:
+				ShowWatchWindow1( this->watched_company );
+				break;
+		}
+	}
+}
+
+void WatchCompany1::OnMouseOver(Point pt, int widget)
+	{
+		/* Show tooltip with last month production or town name */
+		if (pt.x != -1) {
+			TileIndex tile;
+			const bool viewport_is_in_map_mode = (this->viewport->zoom > ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_DRAW_MAP);
+			if (viewport_is_in_map_mode) {
+				// Disabled, for now :)
+				/*NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(WID_EV_VIEWPORT);
+				const int a = ((ScaleByZoom(pt.x - nvp->pos_x, this->viewport->zoom) + this->viewport->virtual_left) >> 2) / ZOOM_LVL_BASE;
+				const int b = ((ScaleByZoom(pt.y - nvp->pos_y, this->viewport->zoom) + this->viewport->virtual_top) >> 1) / ZOOM_LVL_BASE;
+				tile = TileVirtXY(b - a, b + a);*/
+			} else {
+				const Point p = GetTileBelowCursor();
+				tile = TileVirtXY(p.x, p.y);
+			}
+			if (tile >= MapSize()) return;
+
+			switch (GetTileType(tile)) {
+				case MP_ROAD:
+					if (IsRoadDepot(tile)) return;
+					/* FALL THROUGH */
+				case MP_HOUSE: {
+					if (HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return; // No need for a town name tooltip when it is already displayed
+					if (!viewport_is_in_map_mode) return;
+					const TownID tid = GetTownIndex(tile);
+					if (!tid) return;
+					SetDParam(0, tid);
+					GuiShowTooltips(this, STR_TOWN_NAME_TOOLTIP, 0, NULL, TCC_HOVER);
+					break;
+				}
+				case MP_INDUSTRY: {
+					const Industry *ind = Industry::GetByTile(tile);
+					const IndustrySpec *indsp = GetIndustrySpec(ind->type);
+
+					StringID str = STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP;
+					uint prm_count = 0;
+					SetDParam(prm_count++, indsp->name);
+					for (byte i = 0; i < lengthof(ind->produced_cargo); i++) {
+						if (ind->produced_cargo[i] != CT_INVALID) {
+							SetDParam(prm_count++, ind->produced_cargo[i]);
+							SetDParam(prm_count++, ind->last_month_production[i]);
+							SetDParam(prm_count++, ToPercent8(ind->last_month_pct_transported[i]));
+							str++;
+						}
+					}
+					if (prm_count <= 19) {
+						GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+					}
+					break;
+				}
+				case MP_STATION: {
+					if (!IsRailWaypoint(tile)) {
+						if (!HasTileWaterGround(tile)) {
+							const Station *st = Station::GetByTile(tile);
+							StringID str = STR_STATION_VIEW_TRANSPORTED_TOOLTIP;
+							uint prm_count = 0;
+							SetDParam(prm_count++, st->index);
+							for (const CargoSpec *cs : _sorted_standard_cargo_specs) {
+								//const CargoSpec *cs = CargoSpec::Get(i);
+								if(cs == NULL) continue;
+								int cargoid = cs->Index();
+								//if (HasBit(st->goods[i].status,GoodsEntry::GES_RATING)) {
+								if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+									SetDParam(prm_count++, cs->Index());
+									SetDParam(prm_count++, st->goods[cargoid].cargo.TotalCount());
+									SetDParam(prm_count++, ToPercent8(st->goods[cargoid].rating));
+									str++;
+									if (prm_count == 19) {
+										str++;
+										break;
+									}
+								}
+							}
+							if (prm_count <= 19) {
+								GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+							}
+						}
+					}
+					break;
+				}
+				default:
+					return;
+			}
+		}
+	}
+
+void WatchCompany1::OnInvalidateData(int data, bool gui_scope)
+{
+	/* Disable the companies who are not active */
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		this->SetWidgetDisabledState(EWW_PB_COMPANY_FIRST1 + i , !Company::IsValidID(i) );
+		this->SetWidgetDisabledState(EWW_PB_ACTION1_FIRST1 + i , !Company::IsValidID(i) );
+	}
+	/* Check if the currently selected company is still active. */
+	if (this->watched_company != INVALID_COMPANY) {
+		/* Make sure the widget is lowered */
+		this->LowerWidget(EWW_PB_COMPANY_FIRST1 + this->watched_company);
+		/* Check if the watched Company is still a valid one */
+		if (!Company::IsValidID(this->watched_company)) {
+			/* Invalid Company Raise the associated widget. */
+			this->RaiseWidget(this->watched_company + EWW_PB_COMPANY_FIRST1 );
+			this->watched_company = INVALID_COMPANY;
+			GetString( this->company_name, STR_JUST_NOTHING, lastof(this->company_name) );
+		} else {
+			Company *c = Company::Get( this->watched_company );
+			SetDParam( 0, c->index );
+			GetString( this->company_name, STR_COMPANY_NAME, lastof(this->company_name) );
+		}
+	} else {
+		GetString( this->company_name, STR_JUST_NOTHING, lastof(this->company_name) );
+
+	}
+	if (_networking) { // Local game, draw the Blot
+		/* Reset company count - network only */
+		for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+			this->company_count_client[i] = 0;
+		}
+		/* Calculate client count into company - network only */
+		for (NetworkClientInfo *ci : NetworkClientInfo::Iterate()) {
+			if (Company::IsValidID(ci->client_playas)) {
+				company_count_client[ci->client_playas]+=1;
+			}
+		}
+	}
+	HandleZoomMessage(this, this->viewport, EWW_ZOOMIN1, EWW_ZOOMOUT1);
+}
+
+void WatchCompany1::ScrollToTile( TileIndex tile )
+{
+	/* Scroll window to the tile, only if not zero */
+	if (tile != 0) {
+		ScrollWindowTo( TileX(tile) * TILE_SIZE + TILE_SIZE / 2, TileY(tile) * TILE_SIZE + TILE_SIZE / 2, -1, this );
+	}
+}
+
+/** OnDoCommand function - Called by the DoCommand
+ *  @param company The company ID who's client is building
+ *  @param tile The tile number where action took place
+ */
+void WatchCompany1::OnDoCommand( CompanyID company, TileIndex tile )
+{
+	/* Check if its my company */
+	if (this->watched_company == company)
+	{
+		this->ScrollToTile( tile );
+	}
+	/* set the company_activity to its max in order to paint the BLOT in red
+	 * This will result by having the activity blot set to red for all companies
+	 * even the one watched. To avoid this behaviour and not to light the blot of
+	 * the watched company, the code can be moved just after the ScrollToTile call.
+	 */
+	if (tile != 0) {
+		this->company_activity[company] = MAX_ACTIVITY;
+		this->SetDirty( );
+	}
+}
+
+/** Used to decrement the activity counter
+ *
+ */
+void WatchCompany1::OnTick()
+{
+	bool set_dirty = false;
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		if ( this->company_activity[i]>0 ) {
+			this->company_activity[i]--;
+			if ( this->company_activity[i]==0 ) {
+				set_dirty = true;
+			}
+		}
+	}
+	/* If one company_activity reaches 0, then redraw */
+	if (set_dirty) {
+		this->SetDirty();
+	}
+}
+
+void ShowWatchWindow1(CompanyID company_to_watch = INVALID_COMPANY)
+{
+	int i = 0;
+	/* find next free window number for watch viewport */
+	while (FindWindowById(WC_WATCH_COMPANY1, i) != NULL) i++;
+	new WatchCompany1(&_watch_company_desc, i, company_to_watch);
+}
diff --git a/src/watch_gui_1.h b/src/watch_gui_1.h
new file mode 100644
index 000000000..7c9463f60
--- /dev/null
+++ b/src/watch_gui_1.h
@@ -0,0 +1,67 @@
+/* $Id: watch_gui.h 17678 2009-10-07 20:54:05  muxy $ */
+
+/** @file watch_gui.h GUI Functions related to watching. */
+
+#ifndef WATCH_GUI_1_H
+#define WATCH_GUI_1_H
+
+#include "window_gui.h"
+#include "company_base.h"
+
+#define MAX_ACTIVITY 30
+
+enum WatchCompany1Widgets {
+	EWW_CAPTION1,
+	EWW_PB_COMPANY_NUMBER_FIRST1,
+	EWW_PB_COMPANY_NUMBER_LAST1  = EWW_PB_COMPANY_NUMBER_FIRST1 + MAX_COMPANIES - 1,
+	EWW_PB_COMPANY_FIRST1,
+	EWW_PB_COMPANY_LAST1  = EWW_PB_COMPANY_FIRST1 + MAX_COMPANIES - 1,
+	EWW_HAS_CLIENT_FIRST1,
+	EWW_HAS_CLIENT_LAST1 = EWW_HAS_CLIENT_FIRST1 + MAX_COMPANIES - 1,
+	EWW_ACTIVITY_FIRST1,
+	EWW_ACTIVITY_LAST1 = EWW_ACTIVITY_FIRST1 + MAX_COMPANIES - 1,
+	EWW_PB_ACTION1_FIRST1,
+	EWW_PB_ACTION1_LAST1 = EWW_PB_ACTION1_FIRST1 + MAX_COMPANIES - 1,
+	EWW_WATCH1,
+	EWW_ZOOMIN1,
+	EWW_ZOOMOUT1,
+	EWW_CENTER1,
+	EWW_NEW_WINDOW1
+};
+
+class WatchCompany1 : public Window
+{
+
+protected:
+
+	CompanyID watched_company;                            // Company ID beeing watched.
+	CompanyID watched_company_window;                            // Company ID to open Company window.
+	int company_activity[MAX_COMPANIES];                  // int array for activity blot.
+	int company_count_client[MAX_COMPANIES];              // company client count.
+	char company_name[MAX_LENGTH_COMPANY_NAME_CHARS];     // company name for title display
+
+	void SetWatchWindowTitle( );
+	void ScrollToTile( TileIndex tile );
+
+
+public:
+
+	WatchCompany1(WindowDesc *desc, int window_number, CompanyID company_to_watch );
+
+	virtual void SetStringParameters(int widget) const;
+	//virtual void OnPaint( );
+	virtual void DrawWidget(const Rect &r, int widget) const;
+	virtual void OnClick(Point pt, int widget, int click_count);
+	virtual void OnResize( );
+	virtual void OnScroll(Point delta);
+	virtual void OnMouseWheel(int wheel);
+	virtual void OnInvalidateData(int data, bool gui_scope );
+	virtual void OnTick( );
+	virtual void OnMouseOver(Point pt, int widget);
+
+	void OnDoCommand( CompanyID company, TileIndex tile );
+};
+
+void ShowWatchWindow1( CompanyID company_to_watch );
+
+#endif // WATCH_GUI_1_H
diff --git a/src/widgets/CMakeLists.txt b/src/widgets/CMakeLists.txt
index 5586870a3..a741ccf91 100644
--- a/src/widgets/CMakeLists.txt
+++ b/src/widgets/CMakeLists.txt
@@ -5,6 +5,7 @@ add_files(
     bootstrap_widget.h
     bridge_widget.h
     build_vehicle_widget.h
+    cargo_table_widget.h
     cheat_widget.h
     company_widget.h
     console_widget.h
diff --git a/src/widgets/cargo_table_widget.h b/src/widgets/cargo_table_widget.h
new file mode 100644
index 000000000..823cc481b
--- /dev/null
+++ b/src/widgets/cargo_table_widget.h
@@ -0,0 +1,20 @@
+/* $Id: cargo_table_widget.h 23600 2011-12-19 20:46:17Z TheDude $ */
+
+/** @file cargo_table_widget.h Types related to the cargos widgets. */
+
+#ifndef WIDGETS_CARGO_TABLE_WIDGET_H
+#define WIDGETS_CARGO_TABLE_WIDGET_H
+
+/** Widgets of the #CargosWindow class. */
+enum CargosWidgets {
+	WID_CT_BACKGROUND,  ///< Caption of the window.
+	WID_CT_CAPTION,
+	WID_CT_HEADER_CARGO,
+	WID_CT_HEADER_AMOUNT,
+	WID_CT_HEADER_INCOME,
+	WID_CT_LIST,
+	WID_CT_AMOUNT,
+	WID_CT_INCOME,
+};
+
+#endif /* WIDGETS_CARGO_TABLE_WIDGET_H */
diff --git a/src/widgets/industry_widget.h b/src/widgets/industry_widget.h
index 5e3a656c1..6ed89544d 100644
--- a/src/widgets/industry_widget.h
+++ b/src/widgets/industry_widget.h
@@ -37,10 +37,34 @@ enum IndustryDirectoryWidgets {
 	WID_ID_DROPDOWN_CRITERIA,    ///< Dropdown for the criteria of the sort.
 	WID_ID_FILTER_BY_ACC_CARGO,  ///< Accepted cargo filter dropdown list.
 	WID_ID_FILTER_BY_PROD_CARGO, ///< Produced cargo filter dropdown list.
+	WID_ID_DROPDOWN_FILTER_TRANSPORTED,   ///< Dropdown for filtering on industry is transported or not
+	WID_ID_DROPDOWN_FILTER_INDUSTRY_TYPE, ///< Dropdown for filtering on industry type
 	WID_ID_INDUSTRY_LIST,        ///< Industry list.
 	WID_ID_SCROLLBAR,            ///< Scrollbar of the list.
 };
 
+/** Widgets of the #AdvancedIndustryDirectoryWindow */
+enum AdvancedIndustryDirectoryWidgets {
+        WID_AD_SLOT_LIST, //< Slot list.
+        WID_AD_SLOTLIST_NAME, //< Slot list name.
+        WID_AD_NEWSLOTLIST, //< Button to create new slot list.
+        WID_AD_LOADSLOTLIST, //< Button to load slot list,
+        WID_AD_DELETESLOTLIST, //< Button to delete slot list,
+        WID_AD_SAVESLOTLIST, //< Button to save slot list.
+        WID_AD_SLOTINFOPANEL, //< Panel containing slotinfo widgets.
+        WID_AD_SLOTNAME, //< Editbox for slot names.
+        WID_AD_STATIONSIZE, //< Editbox for station size.
+        WID_AD_LIMIT, //< Output limit.
+        WID_AD_ADDCARGO, //< Button to add cargo to list.
+        WID_AD_AUTOREFRESH, //< Button to de-/activate auto-update
+        WID_AD_CARGOLIST, //< Cargo list.
+        WID_AD_CARGOSCROLLBAR, //< Scrollbar of cargo list.
+        WID_AD_ADDITIVEWEIGHT, //< Button toggle, if cargo weight is additive
+        WID_AD_SEARCH, //< Button to start search.
+        WID_AD_INDUSTRY_LIST, //< Advanced industry list.
+        WID_AD_SCROLLBAR, //< Scrollbar of the ai list.
+};
+
 /** Widgets of the #IndustryCargoesWindow class */
 enum IndustryCargoesWidgets {
 	WID_IC_CAPTION,        ///< Caption of the window.
diff --git a/src/widgets/intro_widget.h b/src/widgets/intro_widget.h
index d2eeacf64..00d1b8a93 100644
--- a/src/widgets/intro_widget.h
+++ b/src/widgets/intro_widget.h
@@ -33,6 +33,55 @@ enum SelectGameIntroWidgets {
 	WID_SGI_CONTENT_DOWNLOAD,      ///< Content Download button.
 	WID_SGI_AI_SETTINGS,           ///< AI button.
 	WID_SGI_EXIT,                  ///< Exit button.
+
+	WID_SGI_CC_HEADER,
+
+	WID_SGI_SERVERS_FORUM,
+	WID_SGI_WEBSITE,
+	WID_SGI_IRC_CHAT,
+	WID_SGI_IRC_SERVERS_CHAT,
+	WID_SGI_SERVER_RULES,
+	WID_SGI_SERVER_WIKI,
+	WID_SGI_SERVER_VIP,
+
+	WID_SGI_CC_USER,
+	WID_SGI_CC_USER_ENTER,
+	WID_SGI_CC_PASSWORD,
+	WID_SGI_CC_SELECT_NICE,
+	WID_SGI_CC_SELECT_BTPRO,
+	WID_SGI_CC_SERVERS,
+
+	WID_SGI_SERVERS,
+	WID_SGI_CC1,
+	WID_SGI_CC2,
+	WID_SGI_CC3,
+	WID_SGI_CC4,
+	WID_SGI_CC5,
+	WID_SGI_CC6,
+	WID_SGI_CC7,
+	WID_SGI_CC8,
+	WID_SGI_CC9,
+	WID_SGI_CC10,
+	WID_SGI_CC11,
+	WID_SGI_CC12,
+	WID_SGI_CC13,
+	WID_SGI_CC14,
+	WID_SGI_CC15,
+	WID_SGI_CC16,
+	WID_SGI_CC17,
+	WID_SGI_CC18,
+	WID_SGI_CC19,
+	WID_SGI_CC20,
+	WID_SGI_CC21,
+	WID_SGI_CC22,
+	WID_SGI_CC23,
+	WID_SGI_CC24,
+	WID_SGI_CC25,
+};
+
+enum SelectGameQuery {
+	SGQ_CC_USER,
+	SGQ_CC_PASSWORD,
 };
 
 #endif /* WIDGETS_INTRO_WIDGET_H */
diff --git a/src/widgets/network_widget.h b/src/widgets/network_widget.h
index f50bf04e9..fa6cb75c5 100644
--- a/src/widgets/network_widget.h
+++ b/src/widgets/network_widget.h
@@ -48,6 +48,11 @@ enum NetworkGameWidgets {
 	WID_NG_ADD,                ///< 'Add server' button.
 	WID_NG_START,              ///< 'Start server' button.
 	WID_NG_CANCEL,             ///< 'Cancel' button.
+
+	WID_NG_CC_NICE,            ///< n-ice filter
+	WID_NG_CC_BTPRO,           ///< btpro filter
+	WID_NG_CC_REDDIT,          ///< reddit filter
+	WID_NG_CC_CITYMANIA,       ///< citymania filter
 };
 
 /** Widgets of the #NetworkStartServerWindow class. */
@@ -85,6 +90,7 @@ enum ClientListWidgets {
 	WID_CL_SERVER_INVITE_CODE,         ///< Invite code for this server.
 	WID_CL_SERVER_CONNECTION_TYPE,     ///< The type of connection the Game Coordinator detected for this server.
 	WID_CL_CLIENT_NAME,                ///< Client name.
+	WID_CL_CLIENT_TOKEN_LOGIN,         ///< Token Login
 	WID_CL_CLIENT_NAME_EDIT,           ///< Edit button for client name.
 	WID_CL_MATRIX,                     ///< Company/client list.
 	WID_CL_SCROLLBAR,                  ///< Scrollbar for company/client list.
diff --git a/src/widgets/rail_widget.h b/src/widgets/rail_widget.h
index 2874bac45..21593baff 100644
--- a/src/widgets/rail_widget.h
+++ b/src/widgets/rail_widget.h
@@ -19,6 +19,7 @@ enum RailToolbarWidgets {
 	WID_RAT_BUILD_EW,       ///< Build rail along the game view X axis.
 	WID_RAT_BUILD_Y,        ///< Build rail along the game grid Y axis.
 	WID_RAT_AUTORAIL,       ///< Autorail tool.
+	WID_RAT_POLYRAIL,       ///< Polyline rail tool.
 	WID_RAT_DEMOLISH,       ///< Destroy something with dynamite!
 	WID_RAT_BUILD_DEPOT,    ///< Build a depot.
 	WID_RAT_BUILD_WAYPOINT, ///< Build a waypoint.
@@ -113,6 +114,7 @@ enum BuildRailDepotWidgets {
 	WID_BRAD_DEPOT_SE, ///< Build a depot with the entrance in the south east.
 	WID_BRAD_DEPOT_SW, ///< Build a depot with the entrance in the south west.
 	WID_BRAD_DEPOT_NW, ///< Build a depot with the entrance in the north west.
+	WID_BRAD_DEPOT_AUTO, ///< Build a depot, autoselect entrance.
 };
 
 /** Widgets of the #BuildRailWaypointWindow class. */
diff --git a/src/widgets/road_widget.h b/src/widgets/road_widget.h
index 3d49e9ae9..01a6fd1ee 100644
--- a/src/widgets/road_widget.h
+++ b/src/widgets/road_widget.h
@@ -36,6 +36,7 @@ enum BuildRoadDepotWidgets {
 	WID_BROD_DEPOT_SE,  ///< Depot with SE entry.
 	WID_BROD_DEPOT_SW,  ///< Depot with SW entry.
 	WID_BROD_DEPOT_NW,  ///< Depot with NW entry.
+	WID_BROD_DEPOT_AUTO, ///< Depot, autodetect entry.
 };
 
 /** Widgets of the #BuildRoadStationWindow class. */
@@ -49,6 +50,8 @@ enum BuildRoadStationWidgets {
 	WID_BROS_STATION_NW,    ///< Terminal station with NW entry.
 	WID_BROS_STATION_X,     ///< Drive-through station in x-direction.
 	WID_BROS_STATION_Y,     ///< Drive-through station in y-direction.
+	WID_BROS_STATION_AUTO,     ///< Terminal station, autoselect entry.
+	WID_BROS_STATION_XY_AUTO,  ///< Drive-through station, autoselect direction.
 	WID_BROS_LT_OFF,        ///< Turn off area highlight.
 	WID_BROS_LT_ON,         ///< Turn on area highlight.
 	WID_BROS_INFO,          ///< Station acceptance info.
diff --git a/src/widgets/statusbar_widget.h b/src/widgets/statusbar_widget.h
index bb8149e46..6ab0554be 100644
--- a/src/widgets/statusbar_widget.h
+++ b/src/widgets/statusbar_widget.h
@@ -15,6 +15,8 @@ enum StatusbarWidgets {
 	WID_S_LEFT,   ///< Left part of the statusbar; date is shown there.
 	WID_S_MIDDLE, ///< Middle part; current news or company name or *** SAVING *** or *** PAUSED ***.
 	WID_S_RIGHT,  ///< Right part; bank balance.
+	WID_S_RULES,
+	WID_S_USER,
 };
 
 #endif /* WIDGETS_STATUSBAR_WIDGET_H */
diff --git a/src/widgets/terraform_widget.h b/src/widgets/terraform_widget.h
index 0fd216d72..115cf38c1 100644
--- a/src/widgets/terraform_widget.h
+++ b/src/widgets/terraform_widget.h
@@ -20,6 +20,7 @@ enum TerraformToolbarWidgets {
 	WID_TT_DEMOLISH,                          ///< Demolish aka dynamite button.
 	WID_TT_BUY_LAND,                          ///< Buy land button.
 	WID_TT_PLANT_TREES,                       ///< Plant trees button (note: opens separate window, no place-push-button).
+	WID_TT_MEASUREMENT_TOOL,                  ///< Ruler tool button
 	WID_TT_PLACE_SIGN,                        ///< Place sign button.
 	WID_TT_PLACE_OBJECT,                      ///< Place object button.
 };
diff --git a/src/widgets/toolbar_widget.h b/src/widgets/toolbar_widget.h
index d68de4970..ac4c74b5c 100644
--- a/src/widgets/toolbar_widget.h
+++ b/src/widgets/toolbar_widget.h
@@ -21,6 +21,7 @@ enum ToolbarNormalWidgets {
 	WID_TN_SUBSIDIES,     ///< Subsidy menu.
 	WID_TN_STATIONS,      ///< Station menu.
 	WID_TN_FINANCES,      ///< Finance menu.
+	WID_TN_CARGOS,        ///< Transported cargo menu
 	WID_TN_COMPANIES,     ///< Company menu.
 	WID_TN_STORY,         ///< Story menu.
 	WID_TN_GOAL,          ///< Goal menu.
diff --git a/src/widgets/town_widget.h b/src/widgets/town_widget.h
index 1a3291a3d..02290c8ae 100644
--- a/src/widgets/town_widget.h
+++ b/src/widgets/town_widget.h
@@ -18,6 +18,7 @@ enum TownDirectoryWidgets {
 	WID_TD_LIST,             ///< List of towns.
 	WID_TD_SCROLLBAR,        ///< Scrollbar for the town list.
 	WID_TD_WORLD_POPULATION, ///< The world's population.
+	TDW_CAPTION_TEXT,
 };
 
 /** Widgets of the #TownAuthorityWindow class. */
@@ -42,6 +43,7 @@ enum TownViewWidgets {
 	WID_TV_CATCHMENT,      ///< Toggle catchment area highlight.
 	WID_TV_EXPAND,         ///< Expand this town (scenario editor only).
 	WID_TV_DELETE,         ///< Delete this town (scenario editor only).
+	WID_TV_CB,
 };
 
 /** Widgets of the #FoundTownWindow class. */
@@ -63,4 +65,33 @@ enum TownFoundingWidgets {
 	WID_TF_LAYOUT_RANDOM,     ///< Selection for a randomly chosen town layout.
 };
 
+enum TownHK {
+	HK_SADVERT,
+	HK_MADVERT,
+	HK_LADVERT,
+	HK_ROADS,
+	HK_STATUE,
+	HK_FUND,
+};
+
+enum CBTownWidgets {
+	WID_CB_LOCATION,
+	WID_CB_ADVERT,
+	WID_CB_ADVERT_REGULAR,
+	WID_CB_FUND,
+	WID_CB_FUND_REGULAR,
+	WID_CB_POWERFUND,
+	WID_CB_DETAILS,
+	WID_CB_CARGO_NAME,
+	WID_CB_CARGO_AMOUNT,
+	WID_CB_CARGO_REQ,
+	WID_CB_CARGO_PREVIOUS,
+	WID_CB_CARGO_STORE,
+	WID_CB_CARGO_STORE_PCT,
+	WID_CB_CARGO_FROM,
+	WID_CB_CENTER_VIEW,
+	WID_CB_TOWN_VIEW,
+	WID_CB_SHOW_AUTHORITY,
+};
+
 #endif /* WIDGETS_TOWN_WIDGET_H */
diff --git a/src/widgets/transparency_widget.h b/src/widgets/transparency_widget.h
index 2b096e733..01266c40a 100644
--- a/src/widgets/transparency_widget.h
+++ b/src/widgets/transparency_widget.h
@@ -23,6 +23,7 @@ enum TransparencyToolbarWidgets {
 	WID_TT_STRUCTURES,               ///< Object structure transparency toggle button.
 	WID_TT_CATENARY,                 ///< Catenary transparency toggle button.
 	WID_TT_LOADING,                  ///< Loading indicators transparency toggle button.
+	WID_TT_TUNNELS,
 	WID_TT_END,                      ///< End of toggle buttons.
 
 	/* Panel with buttons for invisibility */
diff --git a/src/widgets/vehicle_widget.h b/src/widgets/vehicle_widget.h
index 954e72f70..0818296ca 100644
--- a/src/widgets/vehicle_widget.h
+++ b/src/widgets/vehicle_widget.h
@@ -45,6 +45,7 @@ enum VehicleRefitWidgets {
 /** Widgets of the #VehicleDetailsWindow class. */
 enum VehicleDetailsWidgets {
 	WID_VD_CAPTION,                     ///< Caption of window.
+	WID_VD_TRIP_HISTORY,                ///< Show the trip history of vehicle.
 	WID_VD_TOP_DETAILS,                 ///< Panel with generic details.
 	WID_VD_INCREASE_SERVICING_INTERVAL, ///< Increase the servicing interval.
 	WID_VD_DECREASE_SERVICING_INTERVAL, ///< Decrease the servicing interval.
diff --git a/src/window.cpp b/src/window.cpp
index d07b597e4..140f73a9b 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -1229,6 +1229,7 @@ void ChangeWindowOwner(Owner old_owner, Owner new_owner)
 		switch (w->window_class) {
 			case WC_COMPANY_COLOUR:
 			case WC_FINANCES:
+			case WC_CARGOS:
 			case WC_STATION_LIST:
 			case WC_TRAINS_LIST:
 			case WC_ROADVEH_LIST:
@@ -2858,7 +2859,7 @@ static void MouseLoop(MouseClick click, int mousewheel)
 		switch (click) {
 			case MC_DOUBLE_LEFT:
 			case MC_LEFT:
-				if (HandleViewportClicked(vp, x, y)) return;
+				if (HandleViewportClicked(vp, x, y, click == MC_DOUBLE_LEFT)) return;
 				if (!(w->flags & WF_DISABLE_VP_SCROLL) &&
 						_settings_client.gui.scroll_mode == VSM_MAP_LMB) {
 					_scrolling_viewport = true;
diff --git a/src/window_gui.h b/src/window_gui.h
index 58d14a54e..d3bf1eac8 100644
--- a/src/window_gui.h
+++ b/src/window_gui.h
@@ -946,7 +946,9 @@ Wcls *AllocateWindowDescFront(WindowDesc *desc, int window_number, bool return_e
 
 void RelocateAllWindows(int neww, int newh);
 
+void ShowLandInfo(TileIndex tile, TooltipCloseCondition cond = TCC_HOVER, TileIndex end_tile=INVALID_TILE);
 void GuiShowTooltips(Window *parent, StringID str, uint paramcount = 0, const uint64 params[] = nullptr, TooltipCloseCondition close_tooltip = TCC_HOVER);
+void GuiPrepareTooltipsExtra(Window *parent);
 
 /* widget.cpp */
 int GetWidgetFromPos(const Window *w, int x, int y);
diff --git a/src/window_type.h b/src/window_type.h
index 6eb9573b6..a33b3bd6d 100644
--- a/src/window_type.h
+++ b/src/window_type.h
@@ -106,6 +106,7 @@ enum WindowClass {
 	 *   - 0 = #ToolTipsWidgets
 	 */
 	WC_TOOLTIPS,
+	WC_TOOLTIPS_EXTRA,
 
 	/**
 	 * Query string window; %Window numbers:
@@ -215,6 +216,12 @@ enum WindowClass {
 	 */
 	WC_VEHICLE_TIMETABLE,
 
+	/**
+	 * Vehicle trip history; %Window numbers:
+	 *   - #VehicleID = #VehicleTripHistoryWidgets
+	 */
+	WC_VEHICLE_TRIP_HISTORY,
+
 	/**
 	 * Company colour selection; %Window numbers:
 	 *   - #CompanyID = #SelectCompanyLiveryWidgets
@@ -354,6 +361,12 @@ enum WindowClass {
 	 */
 	WC_INDUSTRY_VIEW,
 
+	/**
+	 * Advanced industry directory; %Windows numbers:
+	 *       - 0 = #AdvancedIndustryDirectoryWidgets
+	 */
+	WC_ADVANCED_INDUSTRY_DIRECTORY,
+
 	/**
 	 * Company view; %Window numbers:
 	 *   - #CompanyID = #CompanyWidgets
@@ -512,6 +525,7 @@ enum WindowClass {
 	 *   - #CompanyID = #CompanyWidgets
 	 */
 	WC_FINANCES,
+	WC_CARGOS,
 
 	/**
 	 * Income graph; %Window numbers:
@@ -664,6 +678,8 @@ enum WindowClass {
 	 *   - 0 = #SpriteAlignerWidgets
 	 */
 	WC_SPRITE_ALIGNER,
+	WC_ZONING_TOOLBAR,
+	WC_CB_TOWN,
 
 	/**
 	 * Linkgraph legend; %Window numbers:
@@ -695,6 +711,9 @@ enum WindowClass {
 	 */
 	WC_SCREENSHOT,
 
+	WC_CC_TOKENLOGIN,
+	WC_WATCH_COMPANY1,
+
 	WC_INVALID = 0xFFFF, ///< Invalid window.
 };
 
diff --git a/src/zoning.h b/src/zoning.h
new file mode 100644
index 000000000..41f6346ec
--- /dev/null
+++ b/src/zoning.h
@@ -0,0 +1,33 @@
+/** @file zoning.h */
+
+#ifndef ZONING_H_
+#define ZONING_H_
+
+#include "tile_cmd.h"
+
+enum EvaluationMode {
+	   CHECKNOTHING = 0,
+	   CHECKOPINION = 1,  ///< Check the local authority's opinion.
+	   CHECKBUILD = 2,    ///< Check wither or not the player can build.
+	   CHECKSTACATCH = 3, ///< Check catchment area for stations
+	   CHECKBULUNSER = 4, ///< Check for unserved buildings
+	   CHECKINDUNSER = 5, ///< Check for unserved industries
+	   CHECKTOWNZONES = 6,  ///< Town zones (Tz*)
+	   CHECKCBBORDERS = 7,  ///< Citybuilder cargo acceptment zone
+	   CHECKCBTOWNBORDERS = 8,  ///< Citybuilder server town borders
+	   CHECKTOWNADZONES = 9,  ///< Town advertisement zone
+	   CHECKTOWNGROWTHTILES = 10 ///< Town growth tiles (new house, skipped/removed house)
+};
+
+struct Zoning {
+	   EvaluationMode inner;
+	   EvaluationMode outer;
+};
+
+extern Zoning _zoning;
+
+SpriteID TileZoningSpriteEvaluation(TileIndex tile, Owner owner, EvaluationMode ev_mode);
+void DrawTileZoning(const TileInfo *ti);
+void ShowZoningToolbar();
+
+#endif /*ZONING_H_*/
diff --git a/src/zoning_cmd.cpp b/src/zoning_cmd.cpp
new file mode 100644
index 000000000..fc10f2dab
--- /dev/null
+++ b/src/zoning_cmd.cpp
@@ -0,0 +1,293 @@
+/** @file zoning_cmd.cpp */
+#include "stdafx.h"
+#include "station_base.h"
+#include "industry.h"
+#include "viewport_func.h"
+#include "town.h"
+#include "zoning.h"
+
+Zoning _zoning = {CHECKNOTHING, CHECKNOTHING};
+static const SpriteID INVALID_SPRITE_ID = UINT_MAX;
+//RED GREEN BLACK LIGHT_BLUE ORANGE WHITE YELLOW PURPLE
+
+/**
+ * Draw the zoning sprites.
+ * @param SpriteID image
+ *        the image
+ * @param SpriteID colour
+ *        the colour of the zoning
+ * @param TileInfo ti
+ *        the tile
+ */
+const byte _tileh_to_sprite[32] = {
+	   0, 1, 2, 3, 4, 5, 6,  7, 8, 9, 10, 11, 12, 13, 14, 0,
+	   0, 0, 0, 0, 0, 0, 0, 16, 0, 0,  0, 17,  0, 15, 18, 0,
+};
+
+void DrawZoningSprites(SpriteID image, SpriteID colour, const TileInfo *ti) {
+	   if (colour != INVALID_SPRITE_ID){
+			   AddSortableSpriteToDraw(image + _tileh_to_sprite[ti->tileh], colour, ti->x, ti->y, 0x10, 0x10, 1, ti->z + 7);
+	   }
+}
+
+/**
+ * Detect whether this area is within the acceptance of any station.
+ * @param TileArea area
+ *        the area to search by
+ * @return true if a station is found
+ */
+bool IsAreaWithinAcceptanceZoneOfStation(TileArea area) {
+	int catchment = _settings_game.station.station_spread + (_settings_game.station.modified_catchment ? MAX_CATCHMENT : CA_UNMODIFIED);
+	TileArea target(TileXY(TileX(area.tile) - catchment / 2, TileY(area.tile) - catchment / 2), TileX(area.tile) + area.w + catchment, TileY(area.tile) + area.h + catchment);
+	if (area.tile > MapSize()) return false;
+
+	StationFinder morestations(target);
+
+	for (Station * st : *morestations.GetStations()) {
+		Rect rect = st->GetCatchmentRect();
+		return TileArea(TileXY(rect.left, rect.top), TileXY(rect.right, rect.bottom)).Intersects(area);
+	}
+	return false;
+}
+
+/**
+ * Detect whether this tile is within the acceptance of any station.
+ * @param TileIndex tile
+ *        the tile to search by
+ * @return true if a station is found
+ */
+bool IsTileWithinAcceptanceZoneOfStation(TileIndex tile) {
+	int catchment = _settings_game.station.station_spread + (_settings_game.station.modified_catchment ? MAX_CATCHMENT : CA_UNMODIFIED);
+
+	TileArea area(TileXY(TileX(tile) - catchment / 2, TileY(tile) - catchment / 2), catchment, catchment);
+	if (area.tile > MapSize()) return false;
+
+	StationFinder morestations(area);
+
+	for (Station * st : *morestations.GetStations()) {
+		Rect rect = st->GetCatchmentRect();
+		if ((uint)rect.left <= TileX(tile) && TileX(tile) <= (uint)rect.right
+			&& (uint)rect.top <= TileY(tile) && TileY(tile) <= (uint)rect.bottom ) {
+			return true;
+		}
+	}
+	return false;
+}
+
+//Check the opinion of the local authority in the tile.
+SpriteID TileZoneCheckOpinionEvaluation(TileIndex tile, Owner owner) {
+	   Town *town = ClosestTownFromTile(tile, _settings_game.economy.dist_local_authority);
+
+	   if (town == NULL) return INVALID_SPRITE_ID; // no town
+	   else if (HasBit(town->have_ratings, owner)) {  // good : bad
+			   int16 rating = town->ratings[owner];
+			   if(rating <= RATING_APPALLING) return SPR_PALETTE_ZONING_RED;
+			   if(rating <= RATING_POOR) return SPR_PALETTE_ZONING_ORANGE;
+			   if(rating <= RATING_MEDIOCRE) return SPR_PALETTE_ZONING_YELLOW;
+			   if(rating <= RATING_GOOD) return SPR_PALETTE_ZONING_WHITE;
+			   if(rating <= RATING_VERYGOOD) return SPR_PALETTE_ZONING_PURPLE;
+			   if(rating <= RATING_EXCELLENT) return SPR_PALETTE_ZONING_LIGHT_BLUE;
+			   return SPR_PALETTE_ZONING_GREEN;
+	   }
+	   else {
+			   return SPR_PALETTE_ZONING_BLACK;      // no opinion
+	   }
+}
+
+//Check whether the player can build in tile.
+SpriteID TileZoneCheckBuildEvaluation(TileIndex tile, Owner owner) {
+	   /* Let's first check for the obvious things you cannot build on */
+	   switch ( GetTileType(tile) ) {
+			   case MP_INDUSTRY:
+			   case MP_OBJECT:
+			   case MP_HOUSE:
+					   return SPR_PALETTE_ZONING_RED; //can't build
+			   case MP_STATION:
+			   case MP_TUNNELBRIDGE:
+			   case MP_ROAD:
+			   case MP_RAILWAY: {
+					   if (GetTileOwner(tile) != owner) return SPR_PALETTE_ZONING_RED; //can't build
+					   else return INVALID_SPRITE_ID;
+			   }
+			   default: return INVALID_SPRITE_ID;
+	   }
+}
+
+//Detect whether the tile is within the catchment zone of a station.
+//black if within, light blue if only in acceptance zone and nothing if no nearby station.
+ SpriteID TileZoneCheckStationCatchmentEvaluation(TileIndex tile) {
+	   // Never on a station.
+	   if (IsTileType(tile, MP_STATION)){
+			   return INVALID_SPRITE_ID;
+	   }
+	   // For provided goods
+	   StationFinder stations(TileArea(tile, 1, 1));
+	   if (stations.GetStations()->size() > 0) {
+			   return SPR_PALETTE_ZONING_GREEN;
+	   }
+	   // For accepted goods
+	   if (IsTileWithinAcceptanceZoneOfStation(tile)){
+			   return SPR_PALETTE_ZONING_LIGHT_BLUE;
+	   }
+	   return INVALID_SPRITE_ID;
+}
+
+//Detect whether a building is unserved by a station of owner.
+//return red if unserved, orange if only accepting, nothing if served or not a building
+SpriteID TileZoneCheckUnservedBuildingsEvaluation(TileIndex tile) {
+	   CargoArray dat;
+
+	   if (IsTileType (tile, MP_HOUSE))
+			   //&& ( ( memset(&dat, 0, sizeof(dat)), AddAcceptedCargo(tile, dat, NULL), (dat[CT_MAIL] + dat[CT_PASSENGERS] > 0) )
+			   //      || ( memset(&dat, 0, sizeof(dat)), AddProducedCargo(tile, dat), (dat[CT_MAIL] + dat[CT_PASSENGERS] > 0) ) ) )
+	   {
+			   StationFinder stations(TileArea(tile, 1, 1));
+
+			   if (stations.GetStations()->size() > 0) {
+					   return INVALID_SPRITE_ID;
+			   }
+			   // For accepted goods
+			   if (IsTileWithinAcceptanceZoneOfStation(tile)){
+					   return SPR_PALETTE_ZONING_ORANGE;
+			   }
+			   return SPR_PALETTE_ZONING_RED;
+	   }
+	   return INVALID_SPRITE_ID;
+}
+
+//Detect whether an industry is unserved by a station of owner.
+//return red if unserved, orange if only accepting, nothing if served or not a building
+SpriteID TileZoneCheckUnservedIndustriesEvaluation(TileIndex tile) {
+	   if (IsTileType(tile, MP_INDUSTRY)) {
+			   Industry *ind = Industry::GetByTile(tile);
+			   StationFinder stations(ind->location);
+
+			   if (stations.GetStations()->size() > 0){
+					   return INVALID_SPRITE_ID;
+			   }
+
+			   // For accepted goods
+			   if (IsAreaWithinAcceptanceZoneOfStation(ind->location)){
+					   return SPR_PALETTE_ZONING_ORANGE;
+			   }
+			   return SPR_PALETTE_ZONING_RED;
+	   }
+	   return INVALID_SPRITE_ID;
+}
+
+//Check which town zone tile belongs to.
+SpriteID TileZoneCheckTownZones(TileIndex tile) {
+	   HouseZonesBits next_zone = HZB_BEGIN, tz = HZB_END;
+
+	   for (Town *town : Town::Iterate()) {
+			   while (next_zone < HZB_END
+					   && (town->cache.squared_town_zone_radius[next_zone] == 0
+							   || DistanceSquare(tile, town->xy) <= town->cache.squared_town_zone_radius[next_zone])
+			   ){
+					   if(town->cache.squared_town_zone_radius[next_zone] != 0)  tz = next_zone;
+					   next_zone++;
+			   }
+	   }
+
+	   switch (tz) {
+			   case HZB_TOWN_EDGE:         return SPR_PALETTE_ZONING_LIGHT_BLUE; // Tz0
+			   case HZB_TOWN_OUTSKIRT:     return SPR_PALETTE_ZONING_RED; // Tz1
+			   case HZB_TOWN_OUTER_SUBURB: return SPR_PALETTE_ZONING_YELLOW; // Tz2
+			   case HZB_TOWN_INNER_SUBURB: return SPR_PALETTE_ZONING_GREEN; // Tz3
+			   case HZB_TOWN_CENTRE:       return SPR_PALETTE_ZONING_WHITE; // Tz4 - center
+			   default:                    return INVALID_SPRITE_ID; // no town
+	   }
+	   return INVALID_SPRITE_ID;
+}
+
+//Check CB town acceptance area
+SpriteID TileZoneCheckCBBorders(TileIndex tile) {
+	   Town *town = CalcClosestTownFromTile(tile);
+
+	   if (town != NULL) {
+			   if (DistanceManhattan(town->xy, tile) <= _settings_client.gui.cb_distance_check) {
+					   return SPR_PALETTE_ZONING_LIGHT_BLUE; //cb catchment
+			   }
+	   }
+	   return INVALID_SPRITE_ID; // no town
+}
+
+//Check whether the tile is within citybuilder server town border (where houses could be built)
+SpriteID TileZoneCheckCBTownBorders(TileIndex tile) {
+	   for (Town *town : Town::Iterate()) {
+			   uint32 distMax = DistanceMax(town->xy, tile);
+			   if (distMax * distMax < town->cache.squared_town_zone_radius[0]){
+					   return SPR_PALETTE_ZONING_GREEN;
+			   }
+	   }
+	   return INVALID_SPRITE_ID;
+}
+
+//Check which advertisement zone(small, medium, large) tile belongs to
+SpriteID TileZoneCheckTownAdvertisementZones(TileIndex tile) {
+	   Town *town = CalcClosestTownFromTile(tile, 21U);
+	   if (town == NULL) return INVALID_SPRITE_ID; //nothing
+
+	   uint dist = DistanceManhattan(town->xy, tile);
+
+	   if (dist <= 10) return SPR_PALETTE_ZONING_GREEN;
+	   if (dist <= 15) return SPR_PALETTE_ZONING_YELLOW;
+	   if (dist <= 20) return SPR_PALETTE_ZONING_LIGHT_BLUE;
+	   return INVALID_SPRITE_ID;
+}
+
+//Checks for tile in growth tiles info
+SpriteID TileZoneCheckTownsGrowthTiles(TileIndex tile) {
+	   switch (std::max(_towns_growth_tiles[tile], _towns_growth_tiles_last_month[tile])) {
+			   case TGTS_CB_HOUSE_REMOVED_NOGROW: return SPR_PALETTE_ZONING_LIGHT_BLUE;
+			   case TGTS_RH_REMOVED:              return SPR_PALETTE_ZONING_LIGHT_BLUE;
+			   case TGTS_RH_REBUILT:              return SPR_PALETTE_ZONING_WHITE;
+			   case TGTS_NEW_HOUSE:               return SPR_PALETTE_ZONING_GREEN;
+			   case TGTS_CYCLE_SKIPPED:           return SPR_PALETTE_ZONING_ORANGE;
+			   case TGTS_HOUSE_SKIPPED:           return SPR_PALETTE_ZONING_YELLOW;
+			   case TGTS_CB_HOUSE_REMOVED:        return SPR_PALETTE_ZONING_RED;
+			   default: return INVALID_SPRITE_ID;
+	   }
+}
+
+/**
+ * General evaluation function; calls all the other functions depending on
+ * evaluation mode.
+ * @param TileIndex tile
+ *        Tile to be evaluated.
+ * @param EvaluationMode ev_mode
+ *        The current evaluation mode.
+ * @return The colour returned by the evaluation functions (none if no ev_mode).
+ */
+SpriteID TileZoningSpriteEvaluation(TileIndex tile, Owner owner, EvaluationMode ev_mode) {
+	   switch (ev_mode) {
+			   case CHECKOPINION:     return TileZoneCheckOpinionEvaluation(tile, owner);
+			   case CHECKBUILD:       return TileZoneCheckBuildEvaluation(tile, owner);
+			   case CHECKSTACATCH:    return TileZoneCheckStationCatchmentEvaluation(tile);
+			   case CHECKBULUNSER:    return TileZoneCheckUnservedBuildingsEvaluation(tile);
+			   case CHECKINDUNSER:    return TileZoneCheckUnservedIndustriesEvaluation(tile);
+			   case CHECKTOWNZONES:   return TileZoneCheckTownZones(tile);
+			   case CHECKCBBORDERS:   return TileZoneCheckCBBorders(tile);
+			   case CHECKCBTOWNBORDERS: return TileZoneCheckCBTownBorders(tile);
+			   case CHECKTOWNADZONES: return TileZoneCheckTownAdvertisementZones(tile);
+			   case CHECKTOWNGROWTHTILES: return TileZoneCheckTownsGrowthTiles(tile);
+			   default:               return INVALID_SPRITE_ID;
+	   }
+}
+
+/**
+ * Draw the the zoning on the tile.
+ * @param TileInfo ti
+ *        the tile to draw on.
+ */
+void DrawTileZoning(const TileInfo *ti) {
+	   if(_zoning.outer == CHECKNOTHING && _zoning.inner == CHECKNOTHING) return; //nothing to do
+	   if (_game_mode != GM_NORMAL || ti->tile >= MapSize() || IsTileType(ti->tile, MP_VOID)) return; //check invalid
+	   if (_zoning.outer != CHECKNOTHING){
+			   DrawZoningSprites(SPR_SELECT_TILE, TileZoningSpriteEvaluation(ti->tile, _local_company, _zoning.outer), ti);
+	   }
+	   if (_zoning.inner != CHECKNOTHING){
+			   DrawZoningSprites(SPR_INNER_HIGHLIGHT_BASE, TileZoningSpriteEvaluation(ti->tile, _local_company, _zoning.inner), ti);
+	   }
+}
+
diff --git a/src/zoning_gui.cpp b/src/zoning_gui.cpp
new file mode 100644
index 000000000..fb7d02e87
--- /dev/null
+++ b/src/zoning_gui.cpp
@@ -0,0 +1,198 @@
+/** @file zoning_gui.cpp */
+#include "stdafx.h"
+#include "widgets/dropdown_func.h"
+#include "table/strings.h"
+#include "strings_func.h"
+#include "gfx_func.h"
+#include "core/geometry_func.hpp"
+#include "zoning.h"
+#include "hotkeys.h"
+
+const StringID _zone_types[] = {
+	//STR_ZONING_NO_ZONING,
+	STR_ZONING_AUTHORITY,
+	STR_ZONING_CAN_BUILD,
+	STR_ZONING_STA_CATCH,
+	STR_ZONING_BUL_UNSER,
+	STR_ZONING_IND_UNSER,
+	STR_ZONING_TOWN_ZONES,
+	STR_ZONING_CB_BORDERS,
+	STR_ZONING_CB_TOWN_BORDERS,
+	STR_ZONING_ADVERTISEMENT_ZONES,
+	STR_ZONING_TOWN_GROWTH_TILES,
+};
+
+enum ZoningToolbarWidgets {
+	ZTW_CAPTION,
+	ZTW_OUTER_FIRST,
+	ZTW_INNER_FIRST = ZTW_OUTER_FIRST + 10,
+	ZTW_INNER_END = ZTW_INNER_FIRST + 10,
+};
+
+struct ZoningWindow : public Window {
+	uint maxwidth;
+	uint maxheight;
+
+	ZoningWindow(WindowDesc *desc, int window_number) : Window(desc) {
+		int zone_types_size = lengthof(_zone_types);
+		Dimension dim;
+		this->maxwidth = 0;
+		this->maxheight = 0;
+		for (int i = 0; i < zone_types_size; i++) {
+			dim = GetStringBoundingBox(_zone_types[i]);
+			this->maxwidth = std::max(this->maxwidth, dim.width);
+			this->maxheight = std::max(this->maxheight, dim.height);
+		}
+
+		this->InitNested(window_number);
+		this->InvalidateData();
+		if(_zoning.outer != CHECKNOTHING) this->LowerWidget(ZTW_OUTER_FIRST + _zoning.outer - 1); //-1:skip CHECKNOTHING
+		if(_zoning.inner != CHECKNOTHING) this->LowerWidget(ZTW_INNER_FIRST + _zoning.inner - 1);
+	}
+
+	virtual void OnPaint() {
+		this->DrawWidgets();
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count) {
+		bool outer = true;
+		bool deselect = false;
+		EvaluationMode clicked;
+		if (widget >= ZTW_OUTER_FIRST && widget < ZTW_INNER_FIRST){
+			clicked = (EvaluationMode)(widget - ZTW_OUTER_FIRST + 1); //+1:skip CHECKNOTHING
+			deselect = _zoning.outer == clicked;
+			_zoning.outer = deselect ? CHECKNOTHING : clicked;
+		}
+		else if (widget >= ZTW_INNER_FIRST && widget < ZTW_INNER_END){
+			clicked = (EvaluationMode)(widget - ZTW_INNER_FIRST + 1);
+			deselect = _zoning.inner == clicked;
+			_zoning.inner = deselect ? CHECKNOTHING : clicked;
+			outer = false;
+		}
+		else return;
+
+		this->RaiseAllWidgets(outer);
+		if(!deselect) this->ToggleWidgetLoweredState(widget);
+		this->InvalidateData();
+		MarkWholeScreenDirty();
+	}
+
+	void DrawWidget(const Rect &r, int widget) const
+	{
+		StringID strid = STR_EMPTY;
+		if (widget >= ZTW_OUTER_FIRST && widget < ZTW_INNER_FIRST){
+			strid = _zone_types[widget - ZTW_OUTER_FIRST];
+		}
+		else if (widget >= ZTW_INNER_FIRST && widget < ZTW_INNER_END){
+			strid = _zone_types[widget - ZTW_INNER_FIRST];
+		}
+		else return;
+
+		bool rtl = _current_text_dir == TD_RTL;
+		byte clk_dif = this->IsWidgetLowered(widget) ? 1 : 0;
+		int x = r.left + WD_FRAMERECT_LEFT;
+		int y = r.top;
+
+		DrawString(rtl ? r.left : x + clk_dif + 1, (rtl ? r.right + clk_dif : r.right), y + 1 + clk_dif, strid, TC_FROMSTRING, SA_LEFT);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize) {
+		if (widget >= ZTW_OUTER_FIRST && widget < ZTW_INNER_END){
+			size->width = this->maxwidth + padding.width + 8;
+			size->height = this->maxheight + 2;
+		}
+	}
+
+	void RaiseAllWidgets(bool outer){
+		byte start = outer ? ZTW_OUTER_FIRST : ZTW_INNER_FIRST;
+		byte end = outer ? ZTW_INNER_FIRST : ZTW_INNER_END;
+		for(byte i = start; i < end; i++){
+			if(this->IsWidgetLowered(i)){
+				this->ToggleWidgetLoweredState(i);
+				break;
+			}
+		}
+	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
+};
+
+
+static EventState ZoningWindowGlobalHotkeys(int hotkey) {
+	EvaluationMode zoning = (EvaluationMode)(hotkey - ZTW_OUTER_FIRST + 1); // +1:skip CHECKNOTHING
+	bool deselect = (_zoning.outer == zoning);
+	_zoning.outer = deselect ? CHECKNOTHING : zoning;
+	MarkWholeScreenDirty();
+	return ES_HANDLED;
+}
+
+static Hotkey zoning_hotkeys[] = {
+	Hotkey(WKC_SHIFT | '1', "authority", ZTW_OUTER_FIRST),
+	Hotkey(WKC_SHIFT | '2', "build_status", ZTW_OUTER_FIRST + 1),
+	Hotkey(WKC_SHIFT | '3', "station_catchment", ZTW_OUTER_FIRST + 2),
+	Hotkey(WKC_SHIFT | '4', "unserved_buildings", ZTW_OUTER_FIRST + 3),
+	Hotkey(WKC_SHIFT | '5', "unserved_industries", ZTW_OUTER_FIRST + 4),
+	Hotkey(WKC_SHIFT | '6', "town_zone", ZTW_OUTER_FIRST + 5),
+	Hotkey(WKC_SHIFT | '7', "CB_acceptance", ZTW_OUTER_FIRST + 6),
+	Hotkey(WKC_SHIFT | '8', "CB_build_borders", ZTW_OUTER_FIRST + 7),
+	Hotkey(WKC_SHIFT | '9', "advertisement", ZTW_OUTER_FIRST + 8),
+	Hotkey(WKC_SHIFT | '0', "growth_tiles", ZTW_OUTER_FIRST + 9),
+	HOTKEY_LIST_END
+};
+
+HotkeyList ZoningWindow::hotkeys("zoning_gui", zoning_hotkeys, ZoningWindowGlobalHotkeys);
+
+
+/** Construct the row containing the digit keys. */
+static NWidgetBase *MakeZoningButtons(int *biggest_index)
+{
+	NWidgetHorizontal *hor = new NWidgetHorizontal(NC_EQUALSIZE);
+	int zone_types_size = lengthof(_zone_types);
+	hor->SetPadding(1, 1, 1, 1);
+
+	for(int i = 0; i < 2; i++){
+		NWidgetVertical *ver = new NWidgetVertical;
+
+		int offset = (i == 0) ? ZTW_OUTER_FIRST : ZTW_INNER_FIRST;
+
+		for (int j = 0; j < zone_types_size; j++) {
+			NWidgetBackground *leaf = new NWidgetBackground(WWT_PANEL, i==0 ? COLOUR_ORANGE : COLOUR_YELLOW, offset + j, NULL);
+			leaf->SetFill(1, 0);
+			leaf->SetPadding(0, 0, 0, 0);
+			ver->Add(leaf);
+		}
+		hor->Add(ver);
+	}
+	*biggest_index = ZTW_INNER_END - 1;
+	return hor;
+}
+
+static const NWidgetPart _nested_zoning_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, ZTW_CAPTION), SetDataTip(STR_ZONING_TOOLBAR, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY),
+		NWidgetFunction(MakeZoningButtons),
+	EndContainer()
+};
+
+static WindowDesc _zoning_desc (
+	WDP_AUTO, NULL, 0, 0,
+	WC_ZONING_TOOLBAR, WC_NONE,
+	0,
+	_nested_zoning_widgets, lengthof(_nested_zoning_widgets),
+	&ZoningWindow::hotkeys
+);
+
+void ShowZoningToolbar() {
+	AllocateWindowDescFront<ZoningWindow>(&_zoning_desc, 0);
+}
+
diff --git a/src/zoom_type.h b/src/zoom_type.h
index 0945e1cc0..1faa3e260 100644
--- a/src/zoom_type.h
+++ b/src/zoom_type.h
@@ -46,7 +46,6 @@ enum ZoomLevel : byte {
 
 	ZOOM_LVL_MIN      = ZOOM_LVL_NORMAL, ///< Minimum zoom level.
 	ZOOM_LVL_MAX      = ZOOM_LVL_OUT_32X, ///< Maximum zoom level.
-
 };
 DECLARE_POSTFIX_INCREMENT(ZoomLevel)
 
